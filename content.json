{"meta":{"title":"Leah's Blog","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"Vue-(八)列表渲染","slug":"Vue-(八)列表渲染","date":"2019-04-19T07:46:29.651Z","updated":"2019-04-19T07:49:19.387Z","comments":true,"path":"2019/04/19/Vue-(八)列表渲染/","link":"","permalink":"http://yoursite.com/2019/04/19/Vue-(八)列表渲染/","excerpt":"","text":"8-1.用v-for把陣列轉換為一組元素 (影片)v-for項目基本語法12345&lt;div id=&quot;app&quot;&gt; &lt;ol&gt; &lt;li v-for=&quot;item in colors&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; 123456new Vue(&#123; el:'#app', data:&#123; colors:['學習javascrip','學會vue框架','做作品','準備面試'] &#125;,&#125;) 補充：HTML ul 與 ol 差異== 將item拿出來當作屬性1234567&lt;div id=&quot;app&quot;&gt; &lt;ol&gt; &lt;li v-for=&quot;item in todo&quot; v-bind:class=&apos;item.key&apos;&gt; &#123;&#123;item.date&#125;&#125; &#123;&#123;item.content&#125;&#125; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; 123456.first&#123; color:red;&#125;.second&#123; color:green;&#125; 123456789new Vue(&#123; el:'#app', data:&#123; todo:[&#123;key:'first',date:'3/9',content:'學習javascrip'&#125;, &#123;key:'second',date:'3/10',content:'學會vue框架'&#125;, &#123;key:'second',date:'3/11',content:'做作品'&#125;, &#123;key:'second',date:'3/12',content:'準備面試'&#125;] &#125;,&#125;) 用index綁定value12345&lt;div id=&quot;app&quot;&gt; &lt;select &gt; &lt;option v-for=&quot;(item,index) in monthes&quot; :value=&quot;index&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/option&gt; &lt;/select&gt;&lt;/div&gt; 123456new Vue(&#123; el:'#app', data:&#123; monthes:['1月','2月','3月','4月','5月','6月','7月','8月','9月','10月','11月','12月'], &#125;,&#125;) 8-2.用v-for把物件轉換為一組元素 (影片)注意v-forrender出來的順序不一定會跟物件中的順序一樣，所以如果是需要遵從順序的情況，盡可能使用陣列123&lt;div id=&quot;app&quot;&gt; &lt;span v-for=&quot;(value,key) in me&quot;&gt;&#123;&#123;key&#125;&#125;-&#123;&#123;value&#125;&#125;&lt;br/&gt;&lt;/span&gt;&lt;/div&gt; 12345678910new Vue(&#123; el:'#app', data:&#123; me:&#123; name:'Leah', age:26, gender:\"Female\", &#125; &#125;&#125;) 8-3.修改陣列或物件的注意事項 (影片)陣列新增、刪減、排列基本語法 push(ew item)從陣列後面新增 pop()從陣列後面刪減 unshift(new item)從陣列前面新增 shift()從陣列前面刪減 123456789&lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in steps&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;button @click=&quot;push&quot;&gt;Push&lt;/button&gt; &lt;button @click=&quot;pop&quot;&gt;Pop&lt;/button&gt; &lt;button @click=&quot;shift&quot;&gt;Shift&lt;/button&gt; &lt;button @click=&quot;unshift&quot;&gt;Unshift&lt;/button&gt;&lt;/div&gt; 123456789101112131415161718192021new Vue(&#123; el:'#app', data:&#123; steps:[1,2,3,4,5], &#125;, methods:&#123; push()&#123; this.steps.push(this.steps.length+1); &#125;, pop()&#123; this.steps.pop(); &#125;, shift()&#123; this.steps.shift(); &#125;, unshift()&#123; this.steps.unshift(0); &#125;, &#125;&#125;) splice(index,length)從陣列中切割第一個參數index代表陣列中要開始被切割的元素索引，第二個length參數代表要被切割掉的長度(元素數量) 123splice()&#123;//切除陣列中倒數第二個元素 this.steps.splice(this.steps.length-2,1);&#125; splice(index,length,...)從陣列中切除，並添加新的元素 123splice()&#123;//從steps[1]開始切除0個，並從該位置添加元素'new1','new2','new3' this.steps.splice(1,0,'new1','new2','new3'); &#125; slice(from,to)從陣列中取出部分元素，並重組出一個新的陣列==slice()不會改變原先的陣列，會產出一個新的陣列== 123456789slice()&#123; this.steps = this.steps.slice(1,4); &#125;,``` * `sort()`從陣列中的元素從小到大排列```javascript=sort()&#123; this.steps.sort(); &#125; reverse()從陣列中的元素反過來從後面到前面排列 123reverse()&#123; this.steps.reverse(); &#125; filter()從陣列中的過濾符合條件的元素，並重組出一個陣列 1234567//將steps中的每個元素一個個檢查//若符合(item%2===0)，則會被放入新陣列中//最後將新的陣列作為filter()的回傳值//並重新assign給this.stepsfilter()&#123; this.steps = this.steps.filter(item =&gt; item%2 === 0); &#125; 注意！！！！ this.steps[0]=10, 不會修改陣列元素的值，應用splice()達到此目的 this.steps.length=0, 沒辦法清空陣列中的元素，應用splice()，或是slice()達到此目的。 this.obj.z=30, 沒有辦法達到新增物件屬性的功能1234&lt;div id=&quot;app&quot;&gt; &lt;h4 v-for=&quot;(value,key) in obj&quot;&gt;&#123;&#123;key&#125;&#125;=&#123;&#123;value&#125;&#125;&lt;/h4&gt; &lt;button @click=&quot;addZ&quot;&gt;Add Z&lt;/button&gt;&lt;/div&gt; this代表Vue實例，Vue實例中有個方法$set()，第一個參數是設定的目標物件，第二個參數代表新增的key，第三個參數代表新增的value1234addZ()&#123; // this.obj.z = 300;//無效 this.$set(this.obj,'z',300); &#125; 或是，這樣寫123addZ()&#123; Vue.set(this.obj,'z',300); &#125; 注意：this.$set()與Vue.set()用於物件原先沒有該屬性的情況;若情況是要修改物件本來就存在的屬性值，直接改寫就可以 8-4.列表的過濾與排序 (影片)12345678&lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in nums&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;button @click=&quot;initiate&quot;&gt;Initiate&lt;/button&gt; &lt;button @click=&quot;filter&quot;&gt;Filter&lt;/button&gt; &lt;button @click=&quot;sort&quot;&gt;Sort&lt;/button&gt;&lt;/div&gt; sort()會改變原先的this.num陣列;又因為data中nums=orgNums，所以最外面的orgNums也被改變了12345678910111213141516171819const orgNums = [5,6,1,2,4,3,8,7,9];new Vue(&#123; el:'#app', data:&#123; nums:orgNums, &#125;, methods:&#123; initiate()&#123; this.nums = orgNums; &#125;, filter()&#123; this.nums = this.nums.filter(item =&gt;item%2===0); &#125;, sort()&#123; this.nums.sort(); &#125;, &#125;&#125;) 因此，若要避免原先的陣列被改動而喚不回初始值，可以利用slice()語法，先複製一個新的陣列12345678910111213141516171819const orgNums = [5,6,1,2,4,3,8,7,9];new Vue(&#123; el:'#app', data:&#123; nums:orgNums, &#125;, methods:&#123; initiate()&#123; this.nums = orgNums; &#125;, filter()&#123; this.nums = this.nums.filter(item =&gt;item%2===0); &#125;, sort()&#123; this.nums = this.nums.slice().sort(); &#125;, &#125;&#125;) 8-5.用v-for渲染templete [(影片)](https://hiskio.com/courses/145/lectures/5382) 每次迴圈需要被render出來的不只一個元素，而是包含多個標籤元素，可以使用&lt;templete&gt;&lt;/templete&gt;，並將v-for指令放在templete標籤中。123456&lt;div id=&quot;app&quot;&gt; &lt;template v-for=&apos;item in header&apos;&gt; &lt;h1&gt;&#123;&#123;item&#125;&#125;&lt;/h1&gt; &lt;hr/&gt; &lt;/template&gt;&lt;/div&gt; 123456789new Vue(&#123; el:'#app', data:&#123; header:['Home','About','Product','Contact'] &#125;, methods:&#123; &#125;&#125;) 8-6.實作：從JSON資料渲染課程列表 [(影片)](https://hiskio.com/courses/145/lectures/5383) 在mounted()階段引入JSON格式資料 用原生的fetch() 12345mounted()&#123; fetch('./data.json') .then(res =&gt; res.json()) .then(lessons =&gt; this.lessons = lessons);&#125;, 引入jquery寫法 12$.getJSON('./data.json') .then(lessons =&gt; this.lessons = lessons); axios寫法 1axios.get('./data.json').then(res =&gt;this.lessons = res.data); 結果呈現 github完整程式碼 補充vscode 擴充套件 - Live Server：可以快速地建造一個本地端的server 8-7.片尾彩蛋：認識JSON格式 [(影片)](https://hiskio.com/courses/145/lectures/5470) 「JSON格式」本身是一個「字串」JSON格式的限制 JSON格式的key一定要有雙引號”” 最後一個value不能有,結尾 value不能是函式（不過可以把它存成字串，之後再轉為函式執行）格式轉換 javascript物件轉為JSON格式：JSON.stringify(); 12345678const data = &#123; name:\"point\", x:100, y:200&#125;const dataJSON = JSON.stringify(data);console.log(dataJSON); 印出結果，用“”代表是一個字串(JSON格式字串) JSON格式轉為javascript物件：JSON.parse(); 12const dataObj = JSON.parse(dataJSON);console.log(dataObj); 印出結果，是一個物件 replacer:重建JSON資料將物件轉換為JSON格式時，只取其中部分的key值。作法：在stringify()的第二個參數放上key字串組成的陣列[‘x’,’y’];若放null，則代表曲全部的資料123456789console.clear();const data = &#123; name:\"point\", x:100, y:200&#125;const dataJSON = JSON.stringify(data,['x','y']);console.log(dataJSON); 印出結果，產出的JSON格式資料中，只有出’x’,’y’ 提高JSON格式易讀性為了易讀性，讓JSON格式排列整齊，每個key值前面補上空格作法：在stringify()的第三個參數空格數量12const dataJSON = JSON.stringify(data,null,2);console.log(dataJSON); 格式JSON搭配try,catch()因為不能保證每次能成功將JSON格式轉換為物件，為了避免城市卡住，通常會搭配try,catch(err)處理錯誤12345try&#123; const data = JSON.parse(dataJSON);&#125;catch(err)&#123; const data = &#123;&#125;;&#125;","categories":[],"tags":[]},{"title":"Vue筆記-(七)條件判斷","slug":"Vue-(七)條件判斷","date":"2019-04-19T07:45:07.200Z","updated":"2019-04-19T07:46:12.572Z","comments":true,"path":"2019/04/19/Vue-(七)條件判斷/","link":"","permalink":"http://yoursite.com/2019/04/19/Vue-(七)條件判斷/","excerpt":"","text":"7-1.v-if (影片)補充:本身並非元素，只是用來包著許多元素的模板12345678&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;show&quot;/&gt;勾選秀出內容 &lt;templete v-if=&quot;show&quot;&gt; &lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt; &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;h3&gt;&#123;&#123;message&#125;&#125;&lt;/h3&gt; &lt;/templete&gt;&lt;/div&gt; 1234567new Vue(&#123; el:'#app', data:&#123; message:'跳樓大拍賣', show:false, &#125;,&#125;) 7-2.v-else (影片)v-else一定要依附在v-if之後，且是同一層的東西12345678910&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;show&quot;/&gt; &lt;span v-if=&apos;show&apos;&gt;隱藏內容&lt;/span&gt; &lt;span v-else&gt;秀出內容&lt;/span&gt; &lt;templete v-if=&quot;show&quot;&gt; &lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt; &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;h3&gt;&#123;&#123;message&#125;&#125;&lt;/h3&gt; &lt;/templete&gt;&lt;/div&gt; ==如果中間有其他東西，v-else會無效1234567891011&lt;div id=\"app\"&gt; &lt;input type=\"checkbox\" v-model=\"show\"/&gt; &lt;span v-if='show'&gt;隱藏內容&lt;/span&gt; &lt;br/&gt;//錯誤：不得再v-if/v-else插入其他東西，會出錯 &lt;span v-else&gt;秀出內容&lt;/span&gt; &lt;templete v-if=\"show\"&gt; &lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt; &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;h3&gt;&#123;&#123;message&#125;&#125;&lt;/h3&gt; &lt;/templete&gt;&lt;/div&gt; 7-3.v-else-if (影片)v-if若有成立，就不會render下面的v-else-if與v-else123456789&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;showRed&quot;/&gt;red &lt;input type=&quot;checkbox&quot; v-model=&quot;showGreen&quot;/&gt;green &lt;input type=&quot;checkbox&quot; v-model=&quot;showBlue&quot;/&gt;blue &lt;h1 v-if=&quot;showRed&quot;&gt;I&apos;m Red.&lt;/h1&gt; &lt;h1 v-else-if=&quot;showGreen&quot;&gt;I&apos;m Green.&lt;/h1&gt; &lt;h1 v-else-if=&quot;showBlue&quot;&gt;I&apos;m Blue.&lt;/h1&gt; &lt;h1 v-else&gt;Non&lt;/h1&gt;&lt;/div&gt; 12345678new Vue(&#123; el:'#app', data:&#123; showRed:false, showGreen:false, showBlue:false, &#125;,&#125;) 7-4.v-show (影片) v-if是讓程式判斷是否被render出來 v-show是用css控制是否在畫面中顯示(意即套用display: none)，所以該元素在原始碼中有被render出來，只是不在畫面顯示 可以搭配v-if使用，代表裡面的東西是否render出來;但是不能用v-show，因為本身並非一個元素，只是一個模板，無法被顯示處理","categories":[],"tags":[]},{"title":"Vue-(六)HTML元素的屬性綁定","slug":"Vue-(六)HTML元素的屬性綁定","date":"2019-04-19T07:43:32.669Z","updated":"2019-04-19T07:44:48.247Z","comments":true,"path":"2019/04/19/Vue-(六)HTML元素的屬性綁定/","link":"","permalink":"http://yoursite.com/2019/04/19/Vue-(六)HTML元素的屬性綁定/","excerpt":"","text":"6-1.綁定資料為一個元素的class (影片)以下寫法：會綁定css中命名為btnEnter的樣式1&lt;button class=\"btnEnter\"&gt;Enter&lt;/button&gt; 以下v-bind寫法：會綁定JS中的屬性btnEnter的回傳值(可以是字串、物件、陣列)1&lt;button v-bind:class=\"btnEnter\"&gt;Enter&lt;/button&gt; 完整案例示範-綁定回傳值：字串1234&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&apos;text&apos;/&gt; &lt;button v-bind:class=&apos;btnEnter&apos;&gt;Enter&lt;/button&gt;&lt;/div&gt; 12345678910111213#app&#123; text-align:center;&#125;.enter&#123; background-color:green; color:white; border:none; border-radius:8px; padding:9px;&#125;.enter.disable&#123; background-color:grey;&#125; 123456789101112131415new Vue(&#123; el:'#app', data:&#123; text:'', &#125;, computed:&#123; btnEnter()&#123; if(this.text.length === 0)&#123; return 'btnEnter disable'; &#125;else&#123; return 'btnEnter'; &#125; &#125;, &#125;&#125;) 改寫-綁定回傳值：物件 btnEnter:true —&gt;render出來的class會含有btnEnter disabled:true —&gt;render出來的class會含有disabled disabled:false —&gt;render出來的class不會含有disabled12345678910111213141516171819202122new Vue(&#123; el:'#app', data:&#123; text:'', &#125;, computed:&#123; btnEnter()&#123; console.log('111'); if(this.text.length === 0)&#123; return &#123; btnEnter:true, disabled:true, &#125; &#125;else&#123; return &#123; btnEnter:true, disabled:false, &#125; &#125; &#125;, &#125;&#125;) 簡化寫法，只有在條件式成立為true時，class才會含有disable這個屬性12345678computed:&#123; btnEnter()&#123; return &#123; btnEnter:true, disabled:this.text.length === 0, &#125; &#125; &#125; 改寫-綁定回傳值：陣列陣列中可以放入多個字串，代表含有這些css樣式1234567891011121314151617new Vue(&#123; el:'#app', data:&#123; text:'', btnEnterAble:['btnEnter'], btnEnterDisabled:['btnEnter','disabled'], &#125;, computed:&#123; btnEnter()&#123; if(this.text.length === 0)&#123; return this.btnEnterDisabled; &#125;else&#123; return this.btnEnterAble; &#125; &#125; &#125;&#125;) 6-2.綁定資料為一個元素的style (影片)以下寫法：在css定義樣式123&lt;div id=&apos;app&apos;&gt; &lt;h1&gt;Hello&lt;/h1&gt;&lt;/div&gt; 123.h1&#123; color:red;&#125; 以下寫法：直接在元素中定義style1&lt;h1 style=&apos;color:red&apos;&gt;Hello&lt;/h1&gt; 以下v-bind寫法：動態綁定在Vue實例中的屬性字串1&lt;h1 v-bind:style=&quot;h1Style&quot;&gt;Hello&lt;/h1&gt; 完整案例示範-綁定回傳值：字串123&lt;div id=&quot;app&quot; :style=&quot;textCenter&quot;&gt; &lt;h1 :style=&quot;h1Style&quot;&gt;Hello&lt;/h1&gt;&lt;/div&gt; 1234567new Vue(&#123; el:\"#app\", data:&#123; textCenter:'text-align:center', h1Style:\"color:red\", &#125;,&#125;) 改寫-綁定回傳值：物件12345678910new Vue(&#123; el:\"#app\", data:&#123; h1Style:&#123; color:'white', fontSize:'20px', backgroundColor:'gray' &#125;, &#125;,&#125;) 改寫-綁定回傳值：陣列陣列中放物件，會依序套用陣列中的物件所定義的樣式補充：樣式的定義中，key要用駝峰式命名，例：”font-size”要寫為”fontSize”123456789101112131415const commonStyle = &#123; fontSize:'20px',&#125;const whiteWord = &#123; color:'white',&#125;const grayBackground = &#123; backgroundColor:'gray'&#125;new Vue(&#123; el:\"#app\", data:&#123; h1Style:[commonStyle,whiteWord,grayBackground] &#125;,&#125;) 實作練習：1234&lt;div id=&quot;app&quot;&gt; &lt;h1 :style=&quot;h1Style&quot;&gt;Hello&lt;/h1&gt; &lt;button @click=&quot;shrink&quot;&gt;縮小&lt;/button&gt;&lt;/div&gt; 12345678910111213141516new Vue(&#123; el:\"#app\", data:&#123; h1Style:&#123; color:'green', fontSize:'30px', &#125; &#125;, methods:&#123; shrink()&#123; const size = parseInt(this.h1Style.fontSize.replace('px'),10); console.log(size); this.h1Style.fontSize = `$&#123;size-1&#125;px`; &#125; &#125;&#125;) 改寫為更精簡化12345678910111213141516171819new Vue(&#123; el:\"#app\", data:&#123; size: 40, &#125;, computed:&#123; h1Style()&#123; return &#123; color:'green', fontSize:`$&#123;this.size&#125;px`, &#125; &#125; &#125;, methods:&#123; shrink()&#123; this.size--; &#125; &#125;&#125;)","categories":[],"tags":[]},{"title":"Vue-(五)Vue實例","slug":"Vue-(五)Vue實例","date":"2019-04-19T07:38:46.934Z","updated":"2019-04-19T07:43:11.299Z","comments":true,"path":"2019/04/19/Vue-(五)Vue實例/","link":"","permalink":"http://yoursite.com/2019/04/19/Vue-(五)Vue實例/","excerpt":"","text":"5-1.創建Vue實例 (影片)「實例」為何？* 類別：廣泛的描述、藍圖 * 實例：具體的個體 1234567// 1.先描述Human類別Human;//Human是一種類別// 2.再創立個體，new是把類別產生一個實例的語法const me = new Human(); //me是一個實例const you = new Human(); //you是另外一個實例 創建Vue實例的語法123new Vue(&#123;&#125;); 也可以宣告一個變數，並將將new出來的實例，assign給該變數123const vm = new Vue(&#123;&#125;); 5-2.元素(el)、掛載($mount)、模板(template) (影片)掛載(mount)？掛載(mount)：將「vue實例」與「html元素」做連結 創建Vue實例之初，在el中用css選擇器，找到元素元素通常只有一個，所以通常都用id，而非class123&lt;div id=&quot;aaa&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt; //Hello&lt;div class=&quot;bbb&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt; //Hi&lt;div class=&quot;bbb&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt; //&#123;&#123;msg&#125;&#125; （一個vue實例只能掛載到一個元素上，所以這裡會出錯） 123456789101112const a = new Vue(&#123; el:'#aaa', data:&#123; msg:'Hello', &#125;&#125;);const b = new Vue(&#123; el:'.bbb', data:&#123; msg:'Hi', &#125;&#125;); 創建Vue實例之初，在el中用元素的參照，找到元素123&lt;div id=&quot;app&quot;&gt; &#123;&#123;message&#125;&#125;&lt;/div&gt; 123456new Vue(&#123; el:document.getElementById('app'), data:&#123; message:'Hello!', &#125;,&#125;) 創造Vue實例時先不掛載，之後當需要的時候再掛載到元素上宣告一個DOM元素，id命名為app123&lt;div id=&quot;app&quot;&gt; &#123;&#123;message&#125;&#125;&lt;/div&gt; 先創建Vue實例12345const vm = new Vue(&#123; data:&#123; message:'Hello!', &#125;,&#125;) 之後再掛載到元素上 方法1：（css選擇器寫法） 1vm.$mount('#app'); 方法2：（元素參照寫法） 1vm.$mount(document.getElementById('app')); 用template模板取代html元素？template裡面的字串內容被解析之後，會取代html元素中的內容，所以html元素可以是空的1&lt;div id=&quot;app&quot;&gt;&lt;/div&gt; 1234567const vm = new Vue(&#123; el:'#app', template:\"&lt;div&gt;&lt;h1&gt;&#123;&#123;message&#125;&#125;&#123;&#123;message&#125;&#125;&lt;/h1&gt;&lt;/div&gt;\", data:&#123; message:'Hello!', &#125;,&#125;) 5-3.狀態(data) (影片)Vue實例中同步宣告data1234567const vm = new Vue(&#123; el:'#app', data:&#123; x:1, y:2, &#125;,&#125;) 先宣告data，再assign到Vue實例中12345678const data = &#123; x:1, y:2,&#125;const vm = new Vue(&#123; el:'#app', data:data,&#125;) data改為shorthand語法12345678const data = &#123; x:1, y:2,&#125;const vm = new Vue(&#123; el:'#app', data,&#125;) 此時，vm.x等同於data.x，是同一個參照123456789101112const data = &#123; x:1, y:2,&#125;const vm = new Vue(&#123; el:'#app', data,&#125;)vm.x = 5;//此時，data.x = 5console.log(data.x === vm.x);//trueconsole.log(vm.$data === data);//true 5-4.方法(methods) (影片)Vue實例中宣告方法注意：methods裡面不能用箭頭函式，因為箭頭函式中的this等於global或window，會出錯1234&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;&#123;&#123;number&#125;&#125;&lt;/h1&gt; &lt;button v-on:click=&quot;add&quot;&gt;+Add &#123;&#123;count&#125;&#125;&lt;/button&gt;&lt;/div&gt; 12345678910111213const vm = new Vue(&#123; el:'#app', data:&#123; number:0, count:0, &#125;, methods:&#123; add()&#123; this.number += this.count; this.count += 1; &#125; &#125;&#125;) 呼叫methods中的方法注意：methods中的函式命名不得與data的屬性命名相同，會出錯1234&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;&#123;&#123;number&#125;&#125;&lt;/h1&gt; &lt;button v-on:click=&quot;add2&quot;&gt;+Add &#123;&#123;count&#125;&#125;&lt;/button&gt;&lt;/div&gt; 12345678910111213141516const vm = new Vue(&#123; el:'#app', data:&#123; number:0, count:0, &#125;, methods:&#123; add()&#123; this.number += this.count; this.count += 1; &#125;, add2()&#123; this.add(); &#125; &#125;&#125;) 5-5.計算屬性(computed) (影片)computed代表計算之後的屬性，用物件的形式宣告 computed中的函式，一定要return一個值==注意：== computed裡面不能用箭頭函式，因為箭頭函式中的this等於global或window，會出錯1234567&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;number&quot; v-model=&apos;a&apos;&gt; + &lt;input type=&quot;number&quot; v-model=&apos;b&apos;&gt; = &lt;span&gt;&#123;&#123;c&#125;&#125;&lt;/span&gt;&lt;/div&gt; 在computed中有一個函式c，其中有使用到a和b，會自動偵聽a與b，當a或b有變動時，會自動重新計算c的返回值123456789101112const vm = new Vue(&#123; el:'#app', data:&#123; a:0, b:0, &#125;, computed:&#123; c()&#123; return parseInt(this.a,10)+parseInt(this.b,10); &#125;, &#125;&#125;) computed中也可以宣告物件，物件中有getter和setter123456789&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;number&quot; v-model=&apos;a&apos;&gt; + &lt;input type=&quot;number&quot; v-model=&apos;b&apos;&gt; = &lt;input type=&quot;number&quot; v-model=&apos;c&apos;&gt; &lt;br/&gt; &#123;&#123;a&#125;&#125; + &#123;&#123;b&#125;&#125; = &#123;&#123;c&#125;&#125;&lt;/div&gt; 1234567891011121314151617const vm = new Vue(&#123; el:'#app', data:&#123; a:0, b:0, &#125;, computed:&#123; c:&#123; get()&#123; return parseInt(this.a,10) + parseInt(this.b,10); &#125;, set(value)&#123; this.b = parseInt(value,10) - parseInt(this.a,10) &#125; &#125;, &#125;&#125;) 5-6.偵聽器(watch) (影片)watch 可以偵聽 data 與 computed 的屬性或方法變動當被偵聽的“data中的屬性”有變動，就會觸發在watch中同名的函式123&lt;div id=&quot;app&quot;&gt; &lt;input/ type=&quot;number&quot; v-model=&quot;value&quot;&gt;&lt;/div&gt; 1234567891011const vm = new Vue(&#123; el:'#app', data:&#123; value:0, &#125;, watch:&#123; value(val, oldVal)&#123; console.log(`$&#123;oldVal&#125;----&gt;$&#123;val&#125;`); &#125; &#125;&#125;) 當被偵聽的“computed中的屬性或方法”有變動，就會觸發在watch中同名的函式1234567891011121314151617const vm = new Vue(&#123; el:'#app', data:&#123; a:0, b:0, &#125;, computed:&#123; c()&#123; return parseInt(this.a, 10) + parseInt(this.b, 10); &#125; &#125;, watch:&#123; c(val, oldVal)&#123; console.log(`$&#123;oldVal&#125;----&gt;$&#123;val&#125;`); &#125; &#125;&#125;) 進階用法：將watch中的屬性宣告為物件watch中的value被改寫為一個物件12345678910111213const vm = new Vue(&#123; el:'#app', data:&#123; value:0, &#125;, watch:&#123; value:&#123; handler(val,oldVal)&#123; console.log(`$&#123;oldVal&#125;----&gt;$&#123;val&#125;`); &#125;, &#125;, &#125;&#125;) 在物件中增加immediate屬性(true or false)true:在Vue實例被創建時，就會跑這個watch 1234567891011121314const vm = new Vue(&#123; el:'#app', data:&#123; value:0, &#125;, watch:&#123; value:&#123; handler(val,oldVal)&#123; console.log(`$&#123;oldVal&#125;----&gt;$&#123;val&#125;`); &#125;, immediate:true,//所以會馬上console出\"undefined----&gt;0\" &#125;, &#125;&#125;) 在物件中增加deep屬性(true or false)true:當被偵聽的屬性為物件或陣列時，會去偵聽該物件或陣列裡面一層的值是否有被改變 123&lt;div id=&quot;app&quot;&gt; &lt;input/ type=&quot;number&quot; v-model=&quot;value.a&quot;&gt;&lt;/div&gt; 被偵聽的value其實沒有改變，被改變的是value物件中的a，因此要新增deep屬性去偵聽value物件內層的a值12345678910111213141516const vm = new Vue(&#123; el:'#app', data:&#123; value:&#123; a:0, &#125; &#125;, watch:&#123; value:&#123; handler(val,oldVal)&#123; console.log(`$&#123;oldVal.a&#125;----&gt;$&#123;val.a&#125;`);//\"1----&gt;1\" &#125;, deep:true, &#125;, &#125;&#125;) 5-7.生命週期 (影片)Vue實例從創建、更新、消滅的過程中，中間過程會去執行生命週期函式(lifecycle hooks function) 主要四個步驟：1.建立—&gt; 2.掛載—&gt; 3.更新—&gt; 4.消滅 建立（唯二兩個在server side rendering） beforeCreate()：Vue建立之前 created()：Vue建立之後，data與computed中的屬性放到Vue實例中，此時用this.拿得到data與computed中的屬性 掛載 beforeMount()：掛載之前 mounted()：掛載之後，經常用ajax取得資料 並且把資料塞進 data123456789101112const vm = new Vue(&#123; el:'#app', data:&#123; list:[], &#125;, mounted()&#123; $.getJSON('...',(data)=&gt;&#123; this.list = data; &#125;) &#125; &#125;&#125;) 更新 beforeUpdate()：更新之前 updated()：更新之後 消滅 beforeDestroy():消滅之前 destroyed()：消滅之後 5-8.實作「密碼強度檢查」 (影片) codepen實作結果1234567&lt;div id=&quot;app&quot;&gt; &lt;input id=&quot;inputBox&quot; v-bind:type=&quot;showType&quot; v-model=&quot;password&quot; placeholder=&quot;請輸入密碼&quot;/&gt; &lt;button id=&quot;statusBtn&quot; v-on:click=&quot;changeStatus&quot;&gt;&#123;&#123;statusBtn&#125;&#125;&lt;/button&gt; &lt;button&gt;確定送出&lt;/button&gt; &lt;br/&gt; &lt;span&gt;密碼強度:&#123;&#123;strength&#125;&#125;&lt;/span&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738const vm = new Vue(&#123; el:'#app', data:&#123; password:'', show:false, statusBtn:'顯示密碼' &#125;, methods:&#123; changeStatus()&#123; this.show = !this.show; &#125; &#125;, computed:&#123; showType()&#123; if(this.show) &#123; this.statusBtn = '隱藏密碼'; return 'text'; &#125; else&#123; this.statusBtn = '顯示密碼'; return 'password'; &#125; &#125;, strength()&#123; let score = this.password.length; if(/[A-Z]/.test(this.password)) score *= 1.25; if(/[a-z]/.test(this.password)) score *= 1.25; if(/[0-9]/.test(this.password)) score *= 1.25; if(/[^A-Za-z0-9]/.test(this.password)) score *= 1.25; if(score&gt;40) return \"Perfect\"; if(score&gt;30) return \"Great\"; if(score&gt;20) return \"Good\"; return \"Weak\" &#125; &#125; &#125;) 5-9.片尾彩蛋：你聽過Single source of truth嗎？ (影片) 以下這種寫法，要找到有‘被選擇的項目’，有兩個data參照來源 a,b,c各自的值 selected陣列有兩種參照來源就不符合single source原則1234567&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;checkbox&quot; :check=&apos;a&apos; @change=&quot;changeStatus(&apos;a&apos;)&quot;&gt;A:&#123;&#123;a&#125;&#125;&lt;/input&gt; &lt;input type=&quot;checkbox&quot; :check=&quot;b&quot; @change=&quot;changeStatus(&apos;b&apos;)&quot;&gt;B:&#123;&#123;b&#125;&#125;&lt;/input&gt; &lt;input type=&quot;checkbox&quot; :check=&quot;c&quot; @change=&quot;changeStatus(&apos;c&apos;)&quot;&gt;C:&#123;&#123;c&#125;&#125;&lt;/input&gt; &lt;br/&gt; &lt;span&gt;Selected：&#123;&#123;selected&#125;&#125;&lt;/span&gt;&lt;/div&gt; 1234567891011121314151617181920new Vue(&#123; el:'#app', data:&#123; a:false, b:false, c:false, selected:[], &#125;, methods:&#123; changeStatus(item)&#123; const index = this.selected.indexOf(item); if(index == -1)&#123; this.selected.push(item); &#125;else&#123; this.selected.splice(index, 1); &#125; this[item] = !this[item] ; &#125;, &#125;,&#125;) 為了符合single source原則，將selected改寫為computed，確保‘被選擇的項目’資料單一一致 12345678910111213141516171819202122new Vue(&#123; el:'#app', data:&#123; a:false, b:false, c:false, &#125;, methods:&#123; changeStatus(item)&#123; this[item] = !this[item] ; &#125;, &#125;, computed:&#123; selected()&#123; const result = []; if(this.a) result.push('A'); if(this.b) result.push('B'); if(this.c) result.push('C'); return result; &#125; &#125;&#125;) 更進一步簡化程式：將input的data改為v-model雙向綁定，且改用filter寫法 1234567&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;checkbox&quot; v-model=&apos;a&apos;&gt;A:&#123;&#123;a&#125;&#125;&lt;/input&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;b&quot;&gt;B:&#123;&#123;b&#125;&#125;&lt;/input&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;c&quot;&gt;C:&#123;&#123;c&#125;&#125;&lt;/input&gt; &lt;br/&gt; &lt;span&gt;Selected options:&#123;&#123;selected&#125;&#125;&lt;/span&gt;&lt;/div&gt; 12345678910111213new Vue(&#123; el:'#app', data:&#123; a:false, b:false, c:false, &#125;, computed:&#123; selected()&#123; return ['a','b','c'].filter(item =&gt; this[item]) &#125; &#125;&#125;) 學習來源 Hiskio-姚偉揚老師-精通 VueJS 前端開發完全指南","categories":[],"tags":[]},{"title":"Vue-(四)模板語法","slug":"Vue-(四)模板語法","date":"2019-04-19T07:28:29.477Z","updated":"2019-04-19T07:38:37.356Z","comments":true,"path":"2019/04/19/Vue-(四)模板語法/","link":"","permalink":"http://yoursite.com/2019/04/19/Vue-(四)模板語法/","excerpt":"","text":"4-1.用括號語法，插入動態的數值或文字 (影片)雙大括號：動態綁定123&lt;div id=&quot;app&quot;&gt; &lt;span v-once&gt;&#123;&#123;message&#125;&#125;&lt;/span&gt;&lt;div&gt; 123456new Vue(&#123; el:\"#app\", data:&#123; message:'Hello', &#125;,&#125;) v-once：模板只渲染一次，不被二次變更第一個”“因為加上v-once，即使按button會執行函式改變message的值，但第二個”“在畫面中，並不會被重新渲染1234567&lt;div id=&quot;app&quot;&gt; &lt;span v-once&gt;&#123;&#123;message&#125;&#125;&lt;/span&gt; &lt;br/&gt; &lt;span&gt;&#123;&#123;message&#125;&#125;&lt;/span&gt; &lt;br/&gt; &lt;button v-on:click=&quot;append&quot;&gt;Append&lt;/button&gt;&lt;/div&gt; 1234567891011new Vue(&#123; el:\"#app\", data:&#123; message:'Hello', &#125;, methods:&#123; append()&#123; this.message += \"!\"; &#125;, &#125;&#125;) v-html：渲染出html字串123&lt;div id=&quot;app&quot;&gt; &lt;span v-html=&quot;message&quot;&gt;&lt;/span&gt;&lt;/div&gt; 123456new Vue(&#123; el:\"#app\", data:&#123; message:'&lt;h1 style=\"color:red;\"&gt;Hello&lt;/h1&gt;' &#125;,&#125;) 使用v-html的風險：因為允許使用者輸入的內容包含html，使用者可以故意用 ‘xxxx‘，裡面包了挖礦或攻擊程式。所以使用v-html時，要確保資料來源，資料來源應當是資料庫中的安全內容。 4-2.v-bind, v-on指令 (影片)v-bind：透過資料綁定，改變某個屬性的值123&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;checkbox&quot; v-bind:checked=&quot;check_status&quot;&gt;&lt;/div&gt; 123456new Vue(&#123; el:\"#app\", data:&#123; check_status:false, &#125;,&#125;) v-on：用來偵聽DOM事件，以改變資料 v-on:click v-on:load v-on:mouseover ….其他事件1234&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;checkbox&quot; v-bind:checked=&quot;check_status&quot;&gt; &lt;button v-on:click=&quot;change&quot;&gt;Change status&lt;/button&gt;&lt;/div&gt; 1234567891011new Vue(&#123; el:\"#app\", data:&#123; check_status:false, &#125;, methods:&#123; change()&#123; this.check_status = !this.check_status; &#125; &#125;&#125;) v-bind也可以加入表達式表達式：用()括起來會是一個值，就代表它是一個表達式12345&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;&#123;&#123;count&#125;&#125;&lt;/h1&gt; &lt;input type=&quot;checkbox&quot; v-bind:checked=&quot;(count%2==0)&quot;&gt; &lt;button v-on:click=&quot;add&quot;&gt;Add&lt;/button&gt;&lt;/div&gt; 123456789101112new Vue(&#123; el:\"#app\", data:&#123; count:0, check_status:false, &#125;, methods:&#123; add()&#123; this.count += 1; &#125; &#125;&#125;) 雙大括號中也可以使用表達式1234&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;&#123;&#123;count*2&#125;&#125;&lt;/h1&gt; &lt;button v-on:click=&quot;add&quot;&gt;Add&lt;/button&gt;&lt;/div&gt; 1234567891011new Vue(&#123; el:\"#app\", data:&#123; count:0, &#125;, methods:&#123; add()&#123; this.count += 1; &#125; &#125;&#125;) 4-3.v-bind, v-on的縮寫 (影片) v-on：click ——–&gt; @click v-bind：xxx ——–&gt; :xxx 4-4.雙向綁定的v-model (影片)v-model12345&lt;div id=&quot;app&quot;&gt; &lt;span&gt;&#123;&#123;message&#125;&#125;&lt;/span&gt; &lt;br/&gt; &lt;input type=&quot;text&quot; v-model=&quot;message&quot;/&gt;&lt;/div&gt; 123456new Vue(&#123; el:\"#app\", data:&#123; message:'', &#125;,&#125;) 重點釐清 v-bind: 單向綁定 v-model: 雙向綁定 學習來源Hiskio-姚偉揚老師-精通 VueJS 前端開發完全指南","categories":[],"tags":[]},{"title":"Vue-(三)基本概念","slug":"Vue-(三)基本概念","date":"2019-04-19T07:24:38.026Z","updated":"2019-04-19T07:27:36.658Z","comments":true,"path":"2019/04/19/Vue-(三)基本概念/","link":"","permalink":"http://yoursite.com/2019/04/19/Vue-(三)基本概念/","excerpt":"","text":"3-1.關於Vue (影片)followMVVM架構 透過DOM裡面的監聽event來控制/影響View Model，然後去修改Model中的資料內容; 當Model中的資料變更，會讓View Model知道，再去修改相對應DOM中的內容 Vue的學習重點 3-2.Hello World (影片)創建新的html模板![](https://i.imgur.com/8t8CEQP.png) 加入vue的cdn在cdnjs網站上，搜尋vue，將其cdn複製貼上html的head中，為一個script tag，即可使用vue 的library12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/vue/2.6.8/vue.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 在html的body中創建一個容器讓這個容器可以跟vue做綁定，習慣用div，並給予一個id(習慣會命名為app)123&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt; 在html的body中宣告一個vue先有一個script tag，接這用new vue的方式去宣告出一個vue的實體(vue裡面是一個{}物件)12345678&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script&gt; new Vue(&#123; &#125;); &lt;/script&gt;&lt;/body&gt; 將該vue綁定到某個元素(id)上面在Vue實例中，使用el屬性，其值為html中定義的元素，兩者作綁定 12345678910111213new Vue(&#123; el:&quot;#app&quot;,&#125;);``` ### 定義vue中的data在Vue實例中，使用data屬性，並以物件的寫法，將資料放於其中```htmlmixed=new Vue(&#123; el:&quot;#app&quot;, data:&#123; message:&quot;Hello world!&quot;, &#125; &#125;); data被呼叫使用用大括號呼叫出data12345678910111213141516171819&lt;div id=&quot;app&quot;&gt; &#123;&#123;message&#125;&#125;&lt;/div&gt;``` ### html模板與vue的綁定大功告成！存檔之後，點開html檔案，在瀏覽器上可以看到message被呈現出來![](https://i.imgur.com/Q2IBvDL.png) ## 3-3.相對於「命令式」與「宣告式」渲染 [(影片)](https://hiskio.com/courses/145/lectures/5327)### 製作一個計數器(聲明式寫法)：給他一個目標先在html中宣告一個div容器，命名id為counter，裡面有一個文字h1其中顯示data中的count;另外有一個按鈕button，如果被點按會執行add函式```htmlmixed=&lt;div id=&quot;counter&quot;&gt; &lt;h1&gt;&#123;&#123;count&#125;&#125;&lt;/h1&gt; &lt;button v-on:click=&quot;add&quot;&gt;點我+1&lt;/button&gt;&lt;/div&gt; 改為jquery(命令式寫法)：一個口令一個動作1234&lt;div id=&quot;counter&quot;&gt; &lt;h1&gt;0&lt;/h1&gt; &lt;button&gt;點我+1&lt;/button&gt;&lt;/div&gt; 當button被點按，會執行{}中的流程：將h1中的文字轉為10進位的數字型態int，宣告其為count，完成count+=1之後，再將count存回h1中12345$('button').click(()=&gt;&#123; let count = parseInt ($('h1').text(),10); count += 1; $('h1').text(count);&#125;) ![](https://i.imgur.com/RmCLUp5.png) 主流框架皆為聲明式寫法 聲明式(舉一反三): React, Vue, Angular 命令式(一個口令): jQuery 3-4.if-else:流程控制與迴圈 (影片)v-if與v-else:如果為true成立，則…v-if可以單獨存在;但是，v-else不可以單獨存在，前面一定要搭配v-if使用1234567891011121314151617&lt;div id=&quot;app&quot;&gt; &lt;span v-if=&quot;see&quot;&gt;Now you see mee.&lt;/span&gt; &lt;span v-else&gt;Now you don&apos;t.&lt;/span&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el:&quot;#app&quot;, data:&#123; see:true, &#125;, methods:&#123; change_status()&#123; this.see = ! this.see; &#125;, &#125; &#125;)&lt;/script&gt; v-for在v-for=”step in steps”語法中，定義每次從steps中拿出來的東西是step;接著，再用”“將step的內容顯示出來1234567891011121314151617&lt;div id=&quot;app&quot;&gt; &lt;div v-for=&quot;step in steps&quot;&gt;&#123;&#123;step&#125;&#125;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el:&quot;#app&quot;, data:&#123; see:true, steps:[&apos;步驟一&apos;,&apos;步驟二&apos;,&apos;步驟三&apos;] &#125;, methods:&#123; change_status()&#123; this.see = ! this.see; &#125;, &#125; &#125;)&lt;/script&gt; 3-5.處理使用者輸入 (影片)偵聽事件v-on按鈕button被偵聽點按click事件，每當click事件發生，就會執行remove123456&lt;div id=&quot;counter&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in counts&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;button v-on:click=&quot;remove&quot;&gt;remove a number&lt;/button&gt;&lt;/div&gt; 每當remove()函式被呼叫執行，就會從this.counts陣列中拿走一個項目1234567891011new Vue(&#123; el:'#counter', data:&#123; counts:[1,2,3,4,5], &#125;, methods:&#123; remove()&#123; this.counts.pop(); &#125;, &#125;&#125;) 自動雙向綁定v-model透過v-model語法將input跟show_word綁定，若input中的內容改變，會自動更新到data的show_word1234&lt;div id=&quot;inputer&quot;&gt; &lt;h1&gt;&#123;&#123;show_word&#125;&#125;&lt;/h1&gt; &lt;input type=&quot;text&quot; v-model=&quot;show_word&quot; placeholder=&quot;請輸入文字內容&quot;/&gt;&lt;/div&gt; 123456new Vue(&#123; el:'#inputer', data:&#123; show_word:'', &#125;,&#125;) 3-6.實作：老梗才是好梗「Todo List」 (影片)用內容比對刪除如果內容重複，只會找到第一筆一樣的資料，會出錯12345678910111213141516171819202122232425262728293031&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;input&quot;&gt;&lt;/input&gt; &lt;button v-on:click=&quot;addItem&quot;&gt;add&lt;/button&gt; &lt;ul&gt; &lt;li v-for=&quot;item in lists&quot;&gt; &lt;span&gt; &#123;&#123;item&#125;&#125;&lt;button v-on:click=&quot;removeItem(item)&quot;&gt;delete&lt;/button&gt; &lt;span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el:&apos;#app&apos;, data:&#123; input:&apos;&apos;, lists:[], &#125;, methods:&#123; addItem()&#123; this.lists.push(this.input); this.input=&apos;&apos; &#125;, removeItem(item)&#123; //只找到第一筆內容符合的項目，會出錯 const idx = this.lists.indexOf(item); this.lists.splice(idx,1); &#125; &#125;, &#125;) &lt;/script&gt; 用index刪除直接指定該index的數值，刪除在陣列中第(index+1)筆資料1234567891011121314151617181920212223242526272829&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;input&quot;&gt;&lt;/input&gt; &lt;button v-on:click=&quot;addItem&quot;&gt;add&lt;/button&gt; &lt;ul&gt; &lt;li v-for=&quot;(item, index) in lists&quot;&gt; &lt;span&gt; 第&#123;&#123;index+1&#125;&#125;點：&#123;&#123;item&#125;&#125;&lt;button v-on:click=&quot;removeItem(index)&quot;&gt;delete&lt;/button&gt; &lt;span&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el:&apos;#app&apos;, data:&#123; input:&apos;&apos;, lists:[], &#125;, methods:&#123; addItem()&#123; this.lists.push(this.input); this.input=&apos;&apos; &#125;, removeItem(index)&#123; this.lists.splice(index,1); &#125; &#125;,&#125;)&lt;/script&gt; 3-7.Vue/React/Angular，我該上哪部攻城車？ (影片) React需要較多的JS基礎，因此若JS功力深厚者，React可以很快上手 若為初學JS，建議可以從Vue開始學習 Angular學習框架成本高","categories":[],"tags":[]},{"title":"Vue-(一)課程前言、(二)行前準備","slug":"Vue-(一)課程前言、(二)行前準備","date":"2019-04-17T08:15:12.750Z","updated":"2019-04-17T09:19:02.399Z","comments":true,"path":"2019/04/17/Vue-(一)課程前言、(二)行前準備/","link":"","permalink":"http://yoursite.com/2019/04/17/Vue-(一)課程前言、(二)行前準備/","excerpt":"","text":"1-1.老師的話 (文章)如何設計出好架構，如何寫出好程式?許多人問過我，要如何設計出好架構，寫出好程式 我回答的都是同一個方法: 空氣朋友 在你寫 code 時請你想像一個不存在的朋友 你要向他解釋你寫出來的每一行程式碼，他甚至可能提問 如果在某處你無法流暢清晰的解釋 代表那個地方你必須想的更深更廣，作更多的研究 長此以往，必定可以有顯著的進步! 2-1：課程準備(影片) 在vscode中安裝Vue 2 Snippets套件針對編譯器中coding，做不同文字顏色的呈現，便於檢視code 在codepen中載入Vuejavascript的地方新增框架vue，即可使用vue 2-2：取代var的let與const(影片) var是全域變數 1234全域變數var i可以在所有地方被使用for(var i=0;i&lt;3;i++)&#123;&#125;console.log(i);//會印出3 let與const是區域變數區域變數let i只在for迴圈中可以被使用 123for(let i=0;i&lt;3;i++)&#123;&#125;console.log(i);//錯誤：i is not defined const 宣告出來的變數是無法被re-assign的123for(const i=0;i&lt;3;i++)&#123;&#125;console.log(i);//錯誤：i無法被修改 若const被宣告為物件，是可以改變其中的內容const若被宣告為物件，const本身無法被重新re-assign，但是物件{}其中的內容是可以重新被re-assign 12const c =&#123;x:0&#125;;c.x = 3; javascript的hoisting特性可以先執行Function，再補宣告 123a();//先呼叫執行function a()&#123; //再補宣告&#125; 可以先呼叫a,再補宣告var;但是，不能補宣告let12a+=1;var a; 12a+=1;//會報錯，找不到alet a; 2-3：簡潔快速的縮寫shorthands(影片) object中的屬性縮寫當object裡的內容，其key與value是同名的情況（key=value=x)，1234567function makePoint(x,y)&#123; return&#123; x:x,//左邊的x代表key,右邊的x代表value y:y, name:name, &#125;&#125; 可以改寫為1234567function makePoint(x,y)&#123; return&#123; x,//x key的value也是‘x’,所以會往上找到參數‘x’ y, name, &#125;&#125; 補充：物件object物件的內容是由屬性組成的，而屬性是由 key-value pair 構成，value 可為任意資料型別的值，並且值是以參考型別（reference)的方式（存位置）儲存。 如何存取物件的屬性呢？有兩種方式121. 特性存取（property access），使用 .2. 鍵值存取（key access），使用 [ ] 12345const obj = &#123; &apos;a&apos;: &apos;Hello World&apos;,&#125;;console.log(obj.a);&lt;!--&quot;Hello World&quot; --&gt;console.log(obj[&apos;a&apos;]);&lt;!--&quot;Hello World&quot; --&gt; 計算屬性若object中的key為動態的，key可以用中括號[]括起來，代表[]裡面是計算後的屬性。 12345678function createObj(key,value)&#123; const obj=&#123;&#125;; obj[key]=value; return obj;&#125;const person = createObj('name','John');// 會生成出一個物件// person=&#123;name:'John'&#125; 改寫為 12345678function createObj(key,value)&#123; const obj=&#123; [key]:value; &#125;; return obj;&#125;const person = createObj('name','John');const cat = createObj('legs',4); []裡面也可以放運算子123456function createObj(key,value)&#123; const obj=&#123; [key+1]:value; &#125;; return obj;&#125; 函式縮寫當物件中有函式function()12345678910const options=&#123; name:'Options', level:3, created:function()&#123; &#125;, mounted:function()&#123; &#125;, &#125;; 可以改寫為12345678910const options=&#123; name:'Options', level:3, created()&#123; &#125;, mounted()&#123; &#125;, &#125;; 2-4：便利的取出元素：解構賦值(影片)解構賦值(Destructuring assignment)語法是一種 JavaScript 運算式，可以將陣列或物件中的資料取出成獨立變數。 陣列解構（拿多個） 1234const nums = [111,222,333];const first = nums[0];const second = nums[1];const third = nums[2]; 可以將陣列解構，改寫為 1234const nums = [111,222,333];// const [first,second] = nums;const [first,second,third,forth]=nums;//forth會是undefineconst result = first+second+third+forth;//錯誤：因為forth是undefine 陣列解構（預設值）若想避免為undefined，可以在解構的同時給予預設值 12const nums = [111,222,333];const[first, second, third, forth=0 ]=nums;//forth會是undefine 陣列解構（忽略元素，拿一個）假設只要拿出third為333，前面可以忽略 12const nums = [111,222,333];const [,,third] = nums; 陣列解構(變數交換) 12345let a = 1;let b = 2;let temp = a;a = b;b = temp; 利用解構賦值做變數交換的改寫123let a = 1;let b = 2;[a,b]=[b,a] 陣列解構(剩餘部分) 12345const nums = [1,2,3,4];const[first,...others]=nums;//// first = 1;// others = [2,3,4] 物件解構 123456const point=&#123; x:100, y:150,&#125;const x = point.x;const y = point.y; 物件解構可以用大括號{}改寫 12345const point=&#123; x:100, y:150,&#125;const &#123;x,y&#125;= point; 物件解構(預設值)為了避免undefined，可以在解構的同時給予預設值 12345const point=&#123; x:100, y:150, &#125;const &#123;x, y, z = 0&#125; = point; 物件解構(指派新名稱)透過冒號：給予新名稱 1234567const point = &#123; x:100, y:150,&#125;const[x:px, y:py] = point;const result = px*py;const result = x*y;//錯誤：找不到x,y 解構函式參數計算point到圓點的距離數學算式：（x平方＋y評分）=&gt;再開根號 1234567const point = &#123; x:100, y:150,&#125;function distance(point)&#123; return Math.sqrt(point.x*point.x + point.y*point.y);&#125; 可以改寫為1234function distance(point)&#123; const&#123;x,y&#125; = point; return Math.sqrt(x*x + y*y);&#125; 或是直接在函式的參數中作解構123function distance(&#123;x,y&#125;)&#123; return Math.sqrt(x*x + y*y);&#125; 甚至還可以在參數中給予預設值，並重新命名123function distance(&#123;x:px=0;y:py=0&#125;)&#123; return Math.sqrt(px*px + py*py);&#125; 2-5：更強的字串：字串模板與多行字串(影片) 字串模板(string templete)原始寫法1234function greet(name)&#123; console.log('Hello, ' + name + '!');&#125;greet('Jack');//印出 Hello, Jack! 改寫用backtick`宣告字串模板，在要放入變數的地方用＄{}將變數括起來123function greet(name)&#123; console.log(`Hello, $&#123;name&#125;!`); &#125; 補充：表達式(expression)vs.陳述式(statement)陳述式statement:只做行動但不立即產生結果表達式expression:用小括號()將內容包起來，()裡面是值12const a;//陳述式(a+1);//表達式 字串模板中插入表達式1234function greet(name,days)&#123; const hours = days * 24; console.log(`Hello, $&#123;name&#125;! It's been $&#123;hours&#125; hours!`);&#125; 在字串模板中，加入表達式的改寫123function greet(name,days)&#123; console.log(`Hello, $&#123;name&#125;!It's been $&#123;days * 24&#125; hours!`);&#125; 字串模板中加入三元判斷式三元判斷式解釋：若(days&lt;7)成立，則回傳’’,否則回傳’Long time no see.’ 123456function greet(name,days)&#123; console.log(`Hello, $&#123;name&#125;! $&#123;(days&lt;7)?'':'Long time no see.'&#125;`)&#125;greet('Jack',3);//Hello, Jack!greet('Peter',8);//Hello, Peter! Long tome no see. 多行字串長文章斷行，宣告多行字串不能斷行，若要換行只能使用+ 1const words = 'aaa\\n'+'bbbb\\n'+'ccccc'; 用字串模板改寫（字串模板支援多行字串）12345const words = ` aaa bbbb ccccc`; 2-6：不只更簡短：箭頭函式(影片) 箭頭函式，語法簡短123var double = function(x)&#123; return x*2;&#125; 123const double = (x) =&gt; &#123; return x*2;&#125; 如果參數只有一個，可以將小括號()省略123const double = x =&gt; &#123;&#125; 如果函式本體只有一行，而且是return，可以省略{}，將return內容直接寫在後面，1const double = x =&gt; x*2; 箭頭函式，自動綁定箭頭函式內部的this與外部相同12345const a =()=&gt;&#123; console.log(this);//等於外面的this&#125;console.log(this);//第2行、第4行執行的this，指向同一個 1234567const a = () =&gt;&#123; console.log(this); const aa = () =&gt;&#123; console.log(this);/等於外面的this &#125;&#125;//第2行、第4行執行的this，指向同一個 補充：函式裡面的this是什麼？this是函式的context，情境不同，執行結果也不同 直接執行：“this”代表window(瀏覽器的global是window) 12345var name = 'Heisenburg';var sayMyName = function()&#123; console.log(this.name);&#125;sayMyName();//Heisenburg 宣告一個物件，將函式作為該物件的成員函式：“this”代表該物件 12345var teacher = &#123; name:'Jack',&#125;teacher.sayMyName = sayMyName;//物件的成員函式teacher.sayNyName();//Jack 作為DOM中的監聽函式：“this”代表該DOM元素 假設html中有一個button1&lt;button id=&quot;btn&quot; name=&quot;Btn-click&quot;&gt;click me!&lt;/button&gt; 當button被按下之後，會執行函式sayMyName12btn.addEventListener('click',sayMyName);//Btn-click ==但是，若將函式改為箭頭函式…==箭頭函式中的this代表外面的this，所以三種執行結果的name都ㄧ樣1234567891011121314var name = 'Heisenburg';var sayMyName = () =&gt;&#123; console.log(this.name);&#125;var teacher = &#123; name = 'Jack',&#125;teacher.sayMyName = sayMyName;sayMyName();//Heisenburgteacher.sayMyName();//Heisenburgbtn.addEventListener('click',sayMyName);//Heisenburg 2-7：片尾彩蛋：ES5、ES6、Es2017!?到底是什麼東西？(影片) ECMAScript(往往被稱作JavaScript) ECMA組織訂出JavaScript的語法規範，再讓各家瀏覽器依照規範實作 學習來源 Hiskio-姚偉揚老師-精通 VueJS 前端開發完全指南","categories":[],"tags":[]},{"title":"CSS-將footer置底","slug":"CSS-將footer置底","date":"2019-04-16T10:50:13.935Z","updated":"2019-04-16T10:53:23.126Z","comments":true,"path":"2019/04/16/CSS-將footer置底/","link":"","permalink":"http://yoursite.com/2019/04/16/CSS-將footer置底/","excerpt":"","text":"通常一個頁面中包含三個部分：header、main-content、footer，可是當main-content中的內容不足以撐開整個頁面高度，footer下方就會出現一塊空白區域。這種情況，如果希望footer可以維持底部，整理兩種做法： 方法1. 設定main-content的最小高度為100%方法2. 在最外部再包一層wrapper，設定期高度為100% ; 且讓footer設定為絕對定位bottom:0 方法1.設定main-content的最小高度為100% html, body 高度為100%main-content 最小高度為100% 上、下padding空間，作為放置header、footer的空間 header 使用絕對定位，top為0 設定z-index確保在最上方 footer 使用相對定位，top為自己的高度 123456&lt;!-- html --&gt;&lt;body&gt; &lt;header class=&apos;header&apos;&gt;&lt;/header&gt; &lt;div class=&quot;main-content&quot;&gt;&lt;/div&gt; &lt;footer class=&quot;footer&quot;&gt;&lt;/footer&gt;&lt;/body&gt; 1234567891011121314151617181920html,body&#123; height: 100%; /* background-color: azure; */&#125;.header&#123; height: 50px; position: absolute; top:0; z-index: 900;&#125;.main-content&#123; min-height: 100%; padding-top:50px; padding-bottom:50px;&#125;.footer&#123; position: relative; top: -100px; height: 50px;&#125; 方法2.在最外部再包一層wrapper html, body 高度為100% wrapper 最小高度為100% footer 使用絕對定位，bottom為0 12345678&lt;!-- html --&gt;&lt;body&gt; &lt;div class=&apos;wrapper&apos;&gt; &lt;header class=&apos;header&apos;&gt;&lt;/header&gt; &lt;div class=&quot;main-content&quot;&gt;&lt;/div&gt; &lt;footer class=&quot;footer&quot;&gt;&lt;/footer&gt; &lt;/div&gt;&lt;/body&gt; 12345678910html, body&#123; height: 100%&#125;.wrapper&#123; min-height: 100%;&#125;.footer&#123; position: absolute; bottom: 0;&#125;","categories":[],"tags":[]},{"title":"jQuery-改變CSS樣式","slug":"jQuery-改變CSS樣式","date":"2019-04-16T10:49:34.889Z","updated":"2019-04-16T10:58:29.546Z","comments":true,"path":"2019/04/16/jQuery-改變CSS樣式/","link":"","permalink":"http://yoursite.com/2019/04/16/jQuery-改變CSS樣式/","excerpt":"","text":"語法結構1$(&apos;選擇器&apos;).css(&apos;屬性&apos;,&apos;值&apos;); $()函式的功能是將HTML元素轉換為jQuery特殊元素，經此方法轉換後的HTML元素稱為「jQuery物件」 css()中所定義的指令是「jQuery方法」，意即「jQuery其js中定義了的css()這個函式」 選擇器：與CSS相同的選擇器 屬性：CSS的屬性 值：若為字串，需用單引號或雙引號（&quot;&quot;、&#39;&#39;)括號起來;若值為數值，則不需要。 補充：jQuery可以修改元素的CSS屬性中的值，但若有使用!important的項目仍會優先套用。 語法執行概念 先利用$()函式，將作為指令對象的HTML元素，轉換為jQuery物件 針對jQuery物件呼叫方法，以進行相關操作簡易範例 12345$(function()&#123; $('#typo').css('color','#556A5B'); $('#typo').css('transform','rotate(10deg)') $('#typo .inner').css('opacity',0.5)&#125;)","categories":[],"tags":[]},{"title":"jQuery-事件處理","slug":"jQuery-事件處理","date":"2019-04-16T10:49:25.993Z","updated":"2019-04-16T10:52:57.966Z","comments":true,"path":"2019/04/16/jQuery-事件處理/","link":"","permalink":"http://yoursite.com/2019/04/16/jQuery-事件處理/","excerpt":"","text":"事件處理函式語法結構123$(&apos;選擇器&apos;).on(&apos;事件類型&apos;, function()&#123; 任意處理程序&#125;) $()函式的功能是將HTML元素轉換為jQuery特殊元素，經此方法轉換後的HTML元素稱為「jQuery物件」 on()是設定「當某事件發生時，執行某指令」的方法。 第一個參數是「事件類型(Event Type)」：事件觸發的條件 第二個參數是「處理程序(Event Handler)」：事件被觸發後，接著要调用的方法。 語法執行概念 先利用$()函式，將作為指令對象的HTML元素，轉換為jQuery物件 針對jQuery物件呼叫on()方法 在on()方法中傳入兩個參數，定義要被觸發的「事件類型」以及接下來要執行的「處理程序」 簡易範例當滑鼠移入#typo，接著會執行：透過css樣式修改#typo的顏色 12345$function()&#123; $('#typo').on('mouseover',function()&#123; $('#typo').css('color','#ebc000') &#125;)&#125; 多個處理程序在.on()方法中的第一個參數「事件類型」被觸發之後，第二個參數「處理程序函式」中可以執行數個個別處理的程序 語法結構12345$(&apos;選擇器&apos;).on(&apos;事件類型&apos;, function()&#123; 處理1; 處理2; 處理3...;&#125;) 簡易範例 當滑鼠移入#typo，接著會執行： 透過css樣式修改#typo的顏色 透過css樣式修改header的背景顏色123456$function()&#123; $('#typo').on('mouseover',function()&#123; $('#typo').css('color','#ebc000') ; $('header').css('background-color','#ffffff') &#125;)&#125; 設定多個事件類型一個jQuery物件，可以有多個.on()方法，例如：當A事件(滑鼠移入)時要執行a程序，而當B事件(滑鼠移出)時要執行b程序 方法鏈串語法多個方法如鎖鏈一般串連起來，針對$()產生的同一個jQuery物件作為執行對象，程式會從左到右開始執行。1$(&apos;選擇器&apos;).事件A().事件B().事件C().... 簡易案例 當滑鼠移入#typo元素時，會改變文字即背景顏色 當滑鼠移出#typo元素時，會回復為原本的顏色 多個事件一般寫法(效能差) 針對同一個物件，寫兩次$()函式，瀏覽器花時間分析HTML並取得目標元素，會造成CPU負擔1234567891011121314$(function()&#123; $('#typo').on('mouseover',function()&#123; $('#typo').css(&#123; color:'#ebc000', backgroundColor:'#ae5e96' &#125;); &#125;); $('#typo').on('mouseout',function()&#123; $('#typo').css(&#123; color:'', backgroundColor:'' &#125;); &#125;);&#125;) 修改為鏈串寫法(效能佳) 只需要使用一次$()函式，除了簡化程式碼，也提稱程式處理速度123456789101112131415$(function()&#123; $('#typo') .on('mouseover',function()&#123; $('#typo').css(&#123; color:'#ebc000', backgroundColor:'#ae5e96' &#125;) &#125;) .on('mouseout',function()&#123; $('#typo').css(&#123; color:'', backgroundColor:'' &#125;) &#125;)&#125;) 主要的事件類型 jQuery中，大部分的操作都基於HTML DOM，所以必須確定頁面文件已經完全下載好，才能開始執行程式。jQuery 提供下面這個函式來處理 DOM ready事件 當DOM載入後，執行ready()方法。123$(document).ready(function() &#123; // 這裡放你要執行的程式碼&#125;); 也可以這樣寫123$function()&#123; // 這裡放你要執行的程式碼&#125;","categories":[],"tags":[]},{"title":"Hexo-使用靜態生成器，建立blog(3/3)變更主題","slug":"Hexo-使用靜態生成器，建立blog(3_3)變更主題","date":"2019-04-11T08:50:43.538Z","updated":"2019-04-11T08:58:48.491Z","comments":true,"path":"2019/04/11/Hexo-使用靜態生成器，建立blog(3_3)變更主題/","link":"","permalink":"http://yoursite.com/2019/04/11/Hexo-使用靜態生成器，建立blog(3_3)變更主題/","excerpt":"","text":"系列文章 Hexo-使用靜態生成器，建立blog(1/3)本地端 Hexo-使用靜態生成器，建立blog(2/3)推上github Hexo-使用靜態生成器，建立blog(3/3)變更主題複製主題到自己的專案 將別人的製作好的主題repository clone下來的時候，可能會連.git 一起 clone下來，出現「Git Submodule」 「Git Submodule」就是原先的repository中，還內嵌一到多個外部repository 查看clone下來的repository是否含有.git123//進入themes資料夾，查看檔案列表$ cd themes$ ls -al 123//進入內部主題資料夾，查看其中檔案列表$ cd hiero$ ls -al 刪除內部主題資料夾中的.git123//強制刪除.git（-rf : recursive + force）$ rm -rf .git$ ls -al 刪除快取 1$ git rm --cached themes/hiero -f 查看尚未commit的當案 1$ git status 新增檔案 1$ git add &lt;file name&gt; 使用git管理檔案 1$ git commit -m&quot;&lt;commit message&gt;&quot; 檢視提交紀錄(也可以用soursetree檢視) 1$ git log 使用hexo產生靜態網頁hexo 是把產生出來的網站push到github(可以理解為，hexo的deploy指令會先把原始碼變成網站瀏覽器可以閱讀的程式碼 再push到github)1$ hexo deploy -g","categories":[],"tags":[]},{"title":"Hexo-使用靜態生成器，建立blog(2/3)推上github","slug":"Hexo-使用靜態生成器，建立blog(2_3)推上github","date":"2019-04-11T08:50:37.359Z","updated":"2019-04-11T08:58:20.972Z","comments":true,"path":"2019/04/11/Hexo-使用靜態生成器，建立blog(2_3)推上github/","link":"","permalink":"http://yoursite.com/2019/04/11/Hexo-使用靜態生成器，建立blog(2_3)推上github/","excerpt":"","text":"系列文章 Hexo-使用靜態生成器，建立blog(1/3)本地端 Hexo-使用靜態生成器，建立blog(2/3)推上github Hexo-使用靜態生成器，建立blog(3/3)變更主題push上github 先在github新增一個repository，命名邏輯為 12[github account].github.io例：leahlin912.github.io 複製該repository的網址(例：`git@github.com:leahlin912/leahlin912.github.io.git`) 用vscode(或其他編譯器)打開_config.yml檔案，並修改# Deployment的部分 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: git@github.com:leahlin912/leahlin912.github.io.git branch: master 安裝git 1$ npm install hexo-deployer-git --save 輸入指令，將網站佈署到伺服器上 1$ hexo deploy -g 設定repository的主題在github的該repository頁面，進入「setting」往下滑，點按「change theme」 在瀏覽器中查看網址，成功！https://leahlin912.github.io/ 若有檔案更新，則重複輸入指令 1hexo deploy -g 更換主題 選擇要套用的主題[Themes](https://hexo.io/themes/index.html) 點進該主題的github頁面 在README.md中，依照install指令複製起來，並在terminal中進入blog資料夾中執行指令完畢 用vscode開啟blog資料夾，並進入_config.yml檔案中，修改主題theme(參考readme中開發者定義的theme名稱) 因為檔案有更新，所以需要在terminal輸入指令 1hexo deploy -g","categories":[],"tags":[]},{"title":"Hexo-使用靜態生成器，建立blog(1/3)本地端","slug":"Hexo-使用靜態生成器，建立blog(1_3)本地端","date":"2019-04-11T08:50:30.497Z","updated":"2019-04-11T08:57:51.116Z","comments":true,"path":"2019/04/11/Hexo-使用靜態生成器，建立blog(1_3)本地端/","link":"","permalink":"http://yoursite.com/2019/04/11/Hexo-使用靜態生成器，建立blog(1_3)本地端/","excerpt":"","text":"系列文章 Hexo-使用靜態生成器，建立blog(1/3)本地端 Hexo-使用靜態生成器，建立blog(2/3)推上github Hexo-使用靜態生成器，建立blog(3/3)變更主題環境安裝 先確認電腦已經安裝下列軟體 Node.js(補充：檢查電腦是否已經安裝Node.js，可以在terminal中輸入node -v) Git Mac需要先關閉系統完整保護(SIP) (當在Mac上嘗試開啟一些第三方軟體的時候，可能會受到SIP的限制而無法正常使用。) 先查看SIP開啟/關閉狀態在terminal中輸入csrutil status 如果看到「System Integrity Protection status: enabled」代表SIP開啟 如果看到「System Integrity Protection status: disabled」，代表 SIP是關閉的。 在Mac上關閉SIP step1. 重新啟動Mac開機鍵時，同時按Command+R鍵 step2. 出現彈出視窗後，在螢幕左上方的「工具程式」選單中點按「終端機」。 step3. 啟動「終端機」視窗後，在「終端機(terminal)」中輸入csrutil disable step4. 關閉「終端機」視窗，並重新開機。 補充： 待整個回合(下載Hexo完畢)結束之後，記得修改SIP狀態為開啟，重複上述動作，在「終端機(terminal)」中輸入csrutil enable。 正式開始下載Hexo開始透過npm安裝Hexo，在terminal中輸入安裝指令： 1$ npm install hexo-cli -g 初始化資料夾使用指令建立資料夾，在建立的同時給予命名，並自動初始化資料夾內的檔案結構(示範：以’blog’作為資料夾名稱)，請依序執行下方指令 123$ hexo init &lt;folder name&gt;$ cd &lt;folder name&gt;$ npm install 建立完成後，專案資料夾會有下列檔案： 在本地端開啟blog網頁完成上述流程後，在terminal輸入啟用本地端伺服器的指令 1$ hexo server 本地端伺服器已經啟用 即可在瀏覽器中檢視blog畫面(http://localhost:4000) 新增文章在blog中在blog資料夾的內層中找到_posts資料夾，並將.md檔案拖曳至於其中","categories":[],"tags":[]},{"title":"使用Hexo，建立blog(上)新增文章","slug":"使用Hexo，建立blog(上)新增文章","date":"2019-04-08T01:48:12.000Z","updated":"2019-04-08T11:26:48.111Z","comments":true,"path":"2019/04/08/使用Hexo，建立blog(上)新增文章/","link":"","permalink":"http://yoursite.com/2019/04/08/使用Hexo，建立blog(上)新增文章/","excerpt":"","text":"使用Hexo，建立blog(上)新增文章若要更換主題，可以參考下一篇文章使用Hexo，建立blog(下)自定義主題 環境安裝 先確認電腦已經安裝下列軟體 Node.js(補充：檢查電腦是否已經安裝Node.js，可以在terminal中輸入node -v) Git Mac需要先關閉系統完整保護(SIP) (當在Mac上嘗試開啟一些第三方軟體的時候，可能會受到SIP的限制而無法正常使用。) 先查看SIP開啟/關閉狀態在terminal中輸入csrutil status 如果看到「System Integrity Protection status: enabled」代表SIP開啟 如果看到「System Integrity Protection status: disabled」，代表 SIP是關閉的。 在Mac上關閉SIP step1. 重新啟動Mac開機鍵時，同時按Command+R鍵 step2. 出現彈出視窗後，在螢幕左上方的「工具程式」選單中點按「終端機」。 step3. 啟動「終端機」視窗後，在「終端機(terminal)」中輸入csrutil disable step4. 關閉「終端機」視窗，並重新開機。 補充： 待整個回合(下載Hexo完畢)結束之後，記得修改SIP狀態為開啟，重複上述動作，在「終端機(terminal)」中輸入csrutil enable。 正式開始下載Hexo開始透過npm安裝Hexo，在terminal中輸入安裝指令： 1$ npm install hexo-cli -g 初始化資料夾使用指令建立資料夾，在建立的同時給予命名，並自動初始化資料夾內的檔案結構(示範：以’blog’作為資料夾名稱)，請依序執行下方指令 123$ hexo init &lt;folder name&gt;$ cd &lt;folder name&gt;$ npm install 建立完成後，專案資料夾會有下列檔案： 在本地端開啟blog網頁完成上述流程後，在terminal輸入啟用本地端伺服器的指令 1$ hexo server 本地端伺服器已經啟用 即可在瀏覽器中檢視blog畫面(http://localhost:4000) 新增文章在blog中在blog資料夾的內層中找到_posts資料夾，並將.md檔案拖曳至於其中","categories":[],"tags":[]},{"title":"使用Hexo，建立blog(下)自定義主題","slug":"使用Hexo，建立blog(下)自定義主題","date":"2019-04-08T01:32:28.000Z","updated":"2019-04-08T11:26:37.200Z","comments":true,"path":"2019/04/08/使用Hexo，建立blog(下)自定義主題/","link":"","permalink":"http://yoursite.com/2019/04/08/使用Hexo，建立blog(下)自定義主題/","excerpt":"","text":"使用Hexo，建立blog(下)自定義主題接續上一篇文章使用Hexo，建立blog(上)新增文章 push上github 先在github新增一個repository，命名邏輯為 12[github account].github.io例：leahlin912.github.io 複製該repository的網址(例：`git@github.com:leahlin912/leahlin912.github.io.git`) 用vscode(或其他編譯器)打開_config.yml檔案，並修改# Deployment的部分 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: git@github.com:leahlin912/leahlin912.github.io.git branch: master 安裝git 1$ npm install hexo-deployer-git --save 輸入指令，將網站佈署到伺服器上 1$ hexo deploy -g 設定repository的主題在github的該repository頁面，進入「setting」往下滑，點按「change theme」 在瀏覽器中查看網址，成功！https://leahlin912.github.io/ 若有檔案更新，則重複輸入指令 1hexo deploy -g 更換主題 選擇要套用的主題[Themes](https://hexo.io/themes/index.html) 點進該主題的github頁面 在README.md中，依照install指令複製起來，並在terminal中進入blog資料夾中執行指令完畢 用vscode開啟blog資料夾，並進入_config.yml檔案中，修改主題theme(參考readme中開發者定義的theme名稱) 因為檔案有更新，所以需要在terminal輸入指令 1hexo deploy -g","categories":[],"tags":[]},{"title":"JS-使用API串接公開第三方資源","slug":"JS-使用API串接公開第三方資源","date":"2019-04-08T01:27:02.000Z","updated":"2019-04-09T09:24:12.105Z","comments":true,"path":"2019/04/08/JS-使用API串接公開第三方資源/","link":"","permalink":"http://yoursite.com/2019/04/08/JS-使用API串接公開第三方資源/","excerpt":"","text":"何為API?API(Application Program Interface)意即應用程式的接口，用於定義軟體與軟體之間銜接所需的溝通方法。換句話說，API是讓軟體與軟體互相串接溝通橋樑。 網站可以使用Web APIs 銜接第三方軟體，獲得第三方端點(endpoint)中含有JSON格式的資料。 Web APIs透過HTTP協議方法，向第三方的公開URL端點發出需求。 開始串接一個API 閱讀API文件：Studio Ghibli API documentation 取得API endpoint：在API文件中，滑到films部分，右側會看到GET /films，其中的URL就是API endpoint，點進這個URL會看到一個陣列中包含多個物件，並以JSON格式呈現 使用HTTP請求獲取資料： 在.js檔案中，創造一個「XMLHttpRequest」物件，並指派給request變數。 使用open()函式連接，必要的參數包含「請求方法(‘GET’)」及「API端點的URL」 請求完畢後，我們就有權限進使用onload()函式，進到資料中 最後，send()正式送出請求12345678910111213// Create a request variable and assign a new XMLHttpRequest object to it.var request = new XMLHttpRequest()// Open a new connection, using the GET request on the URL endpointrequest.open('GET', 'https://ghibliapi.herokuapp.com/films')request.onload = function () &#123; // Begin accessing JSON data here &#125;&#125;// Send requestrequest.send() 處理HTTP回傳資料： 回傳值為JSON格式，必須先使用用JSON.parse()將JSON轉換為javascript物件 接下來就可以對資料做處理了。例：這裡的資料為陣列，所以下方用forEach()一一讀取陣列中的物件，並且印出每個物件的title 1234567// Begin accessing JSON data herevar data = JSON.parse(this.response)data.forEach(movie =&gt; &#123; // Log each movie's title console.log(movie.title)&#125;) 處理錯誤error：每次HTTP發出請求，就會回傳status code，常見的錯誤為404(Not found)，成功為200(OK)。判斷request.status，如果成功就執行印出資料，否則就印出error 12345678910// Begin accessing JSON data herevar data = JSON.parse(this.response)if (request.status &gt;= 200 &amp;&amp; request.status &lt; 400) &#123; data.forEach(movie =&gt; &#123; console.log(movie.title) &#125;)&#125; else &#123; console.log('error')&#125; 接續，在頁面上顯示API資料 index.html中有一個div容器，設為id=’root’ 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;script src=&quot;scripts.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 在script.js取得root元素 1const app = document.getElementById('root') 在網頁左上放一個logo 1const logo = document.createElement('img') 新增一個div標籤元素，並且用class定義其css樣式 12const container = document.createElement('div')container.setAttribute('class', 'container') 將新增的元素放到網頁上 12app.appendChild(logo)app.appendChild(container) 繼續在container中填充回傳值資料 123456789101112131415161718192021data.forEach(movie =&gt; &#123; // Create a div with a card class const card = document.createElement('div') card.setAttribute('class', 'card') // Create an h1 and set the text content to the film's title const h1 = document.createElement('h1') h1.textContent = movie.title // Create a p and set the text content to the film's description const p = document.createElement('p') movie.description = movie.description.substring(0, 300) // Limit to 300 chars p.textContent = `$&#123;movie.description&#125;...` // End with an ellipses // Append the cards to the container element container.appendChild(card) // Each card will contain an h1 and a p card.appendChild(h1) card.appendChild(p)&#125;) 成果 github完整程式碼 網頁呈現 參考來源 How to Connect to an API with JavaScript","categories":[],"tags":[]},{"title":"使用github page顯示靜態網頁","slug":"使用github page顯示靜態網頁","date":"2019-04-07T23:29:12.000Z","updated":"2019-04-08T11:26:13.043Z","comments":true,"path":"2019/04/08/使用github page顯示靜態網頁/","link":"","permalink":"http://yoursite.com/2019/04/08/使用github page顯示靜態網頁/","excerpt":"","text":"使用github page顯示靜態網頁設定github綁定金鑰 在本地端新增ssh資料夾 取得公鑰、私鑰，將公鑰貼上github 新增ssh完成 repository推上GitHub 在github 新增 repository git commit git remote add origin git@github.com:leahlin912/111.git git push -u origin master repository推上GitHub Page 建立新的branch: git branch gh-pages 推上github: git push origin gh-pages 需要注意的是首頁要命名為index.html 到[github name].github.io/[repository name]網址查看，你的網頁已經展示在這個網址。 補充說明 切換分支：git checkout &lt;branch name&gt;(切換分支的同時，新增分支git checkout -b &lt;branch name&gt;) 合併分支：git merge &lt;another branch name&gt; 更新到伺服器端：git push 補充-第一次更新到伺服器：git push -u origin master(設定預設的remote為origin ; 設定預設的branch為master)","categories":[],"tags":[]},{"title":"申請API憑證-以Youtube Data API為例","slug":"申請API憑證-以Youtube Data API為例","date":"2019-04-07T03:21:04.000Z","updated":"2019-04-08T11:27:34.273Z","comments":true,"path":"2019/04/07/申請API憑證-以Youtube Data API為例/","link":"","permalink":"http://yoursite.com/2019/04/07/申請API憑證-以Youtube Data API為例/","excerpt":"","text":"申請API憑證-以Youtube Data API為例流程概念 申請憑證 將key加入到專案中 申請API Key 使用google帳號，進入Google Cloud Platform(GCP) 從左上漢堡標籤，進入「API和服務&gt;資訊主頁」 點按「啟用API」按鈕 進到到API函式庫頁面，選擇要使用的API(也可以透過搜尋bar找到該API) 選擇啟用該API 頁面中提示要先「建立憑證」 依照專案需求，填寫表格 依照個人需求、必要，限制金鑰 應用程式限制：若無限制，任何人皆可在任何裝置上使用這組API金鑰；若有限制，則會進行審核，資料符合的使用者才可使用 API限制：可限制該API僅可用來獲取哪些服務Google服務，避免因使用其他服務導致流量超過配額，或被其他人用來獲取其他服務 勾選起該憑證 將Key複製到自己的專案中 將Key加入至專案中","categories":[],"tags":[]},{"title":"API金鑰的使用時機(未完)","slug":"API金鑰的使用時機(未完)","date":"2019-04-07T02:19:40.000Z","updated":"2019-04-08T11:15:26.414Z","comments":true,"path":"2019/04/07/API金鑰的使用時機(未完)/","link":"","permalink":"http://yoursite.com/2019/04/07/API金鑰的使用時機(未完)/","excerpt":"","text":"API金鑰的使用時機(未完)API金鑰 VS. 使用者憑證tokenGoogle Cloud Endpoints 能夠處理 API 金鑰與驗證機制，『API 金鑰用於專案，驗證則是用於使用者』 API 金鑰：用於識別呼叫的專案 (即應用程式或網站)，以便讓呼叫任務對應至正確的API 使用者驗證token：用於辨識使用者，即使用應用程式或網站的使用者 API金鑰API金鑰提供功能 專案識別：辨識發出API呼叫的應用程式與專案 專案授權：檢查該應用程式是否已獲得呼叫API的存取權，並且確認應用程式是否已經在專案中開啟API 使用者憑證token使用token驗證機制有兩大目的 使用者驗證：安全地驗證進行呼叫的使用者是否符合其宣稱的身分 使用者授權：檢查使用者是否擁有權限發出要求","categories":[],"tags":[]},{"title":"Bootstrap-使用Lightbox影像燈箱","slug":"Bootstrap-使用Lightbox影像燈箱","date":"2019-04-04T11:35:46.000Z","updated":"2019-04-17T08:33:36.718Z","comments":true,"path":"2019/04/04/Bootstrap-使用Lightbox影像燈箱/","link":"","permalink":"http://yoursite.com/2019/04/04/Bootstrap-使用Lightbox影像燈箱/","excerpt":"","text":"bootstrap-使用Lightbox影像燈箱什麼是Lightbox？ 網路上有多種他人設計好的燈箱插件，通常都是響應式jQuery燈箱函式庫，用來快速建立及設計漂亮的彈出式影像燈箱，優化網頁中photo gallery的展示效果。引入Lightbox 參考lightbox for bootstrap的指令，首先將cdn複製到專案中 CSS放在&lt;head&gt;中1&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/ekko-lightbox/5.3.0/ekko-lightbox.css&quot; /&gt; JS放在&lt;body&gt;結束前1&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/ekko-lightbox/5.3.0/ekko-lightbox.min.js&quot;&gt;&lt;/script&gt; 概念主要功能是點選其中一張照片，該張照片會以燈箱方式展開 結構分為兩層 外層&lt;a&gt;定義燈箱展示的照片，以及展示後的大小 內層&lt;img&gt;定義原始照片 在外層&lt;a&gt;使用bootstrap自定義的data-toggle設定啟用lightbox功能;data-lightbox將多張照片群組起來，在左右切換照片時可以辨識為同一群組的照片 最後添加jquery程式碼，避免預設效果，而採用引入的lightbox效果展示實作12345678910111213141516171819202122 &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-4&quot;&gt; &lt;a href=&quot;https://mymodernmet.com/wp/wp-content/uploads/2017/12/free-images-national-gallery-of-art-2.jpg&quot; data-toggle=&quot;lightbox&quot; data-gallery=&quot;img-gallery&quot; data-height=&quot;560&quot; data-width=&quot;560&quot;&gt; &lt;img src=&quot;https://mymodernmet.com/wp/wp-content/uploads/2017/12/free-images-national-gallery-of-art-2.jpg&quot; alt=&quot;&quot; class=&quot;img-fluid&quot;&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;col-4&quot;&gt; &lt;a href=&quot;https://mymodernmet.com/wp/wp-content/uploads/2017/12/free-images-national-gallery-of-art-3.jpg&quot; data-toggle=&quot;lightbox&quot; data-gallery=&quot;img-gallery&quot; data-height=&quot;560&quot; data-width=&quot;560&quot;&gt; &lt;img src=&quot;https://mymodernmet.com/wp/wp-content/uploads/2017/12/free-images-national-gallery-of-art-3.jpg&quot; alt=&quot;&quot; class=&quot;img-fluid&quot;&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;col-4&quot;&gt; &lt;a href=&quot;https://mymodernmet.com/wp/wp-content/uploads/2017/12/free-images-national-gallery-of-art-7.jpg&quot; data-toggle=&quot;lightbox&quot; data-gallery=&quot;img-gallery&quot; data-height=&quot;560&quot; data-width=&quot;560&quot;&gt; &lt;img src=&quot;https://mymodernmet.com/wp/wp-content/uploads/2017/12/free-images-national-gallery-of-art-7.jpg&quot; alt=&quot;&quot; class=&quot;img-fluid&quot;&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 1234$(document).on(&apos;click&apos;, &apos;[data-toggle=&quot;lightbox&quot;]&apos;, function(event) &#123; event.preventDefault(); $(this).ekkoLightbox();&#125;); 成果My Project-MoMA Museum-Collection page","categories":[],"tags":[]},{"title":"Bootstrap-使用輪播幻燈片Carousal","slug":"Bootstrap-使用輪播幻燈片Carousal","date":"2019-04-04T11:35:36.000Z","updated":"2019-04-08T11:16:26.855Z","comments":true,"path":"2019/04/04/Bootstrap-使用輪播幻燈片Carousal/","link":"","permalink":"http://yoursite.com/2019/04/04/Bootstrap-使用輪播幻燈片Carousal/","excerpt":"","text":"Bootstrap-使用輪播幻燈片Carousal元件結構carousal由三個小元件組成，controllers跟indicators 可以選擇性的增加 sliders controls indicators sliders 套用的class分為三層 carousal carousal-inner carousal-item .carousal為一個外層容器，在這一層添加data-ride=&quot;carousel&quot;讓輪播器自動播放。 .carousal-inner主要是讓空間寬度為全版width: 100%; .carousal-item代表一個slide的，裡面可以置放所有文字、圖片內容。在該層添加active代表輪播一開始的畫面12345678910111213&lt;div id=&quot;carouselExample&quot; class=&quot;carousel slide&quot; data-ride=&quot;carousel&quot;&gt; &lt;div class=&quot;carousel-inner&quot;&gt; &lt;div class=&quot;carousel-item active&quot;&gt; &lt;img class=&quot;d-block w-100&quot; src=&quot;img/bg1.jpg&quot; alt=&quot;First slide&quot;&gt; &lt;/div&gt; &lt;div class=&quot;carousel-item&quot;&gt; &lt;img class=&quot;d-block w-100&quot; src=&quot;img/bg2.jpg&quot; alt=&quot;Second slide&quot;&gt; &lt;/div&gt; &lt;div class=&quot;carousel-item&quot;&gt; &lt;img class=&quot;d-block w-100&quot; src=&quot;img/bg3.jpg&quot; alt=&quot;Third slide&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; controls 程式碼位置，包在carousal中 左按鈕，套用的class分為兩層 &lt;a&gt;標籤中，套用carousel-control-prev &lt;span&gt;標籤中，套用carousel-control-prev-icon 右按鈕，套用的class分為兩層 &lt;a&gt;標籤中，套用carousel-control-prev &lt;span&gt;標籤中，套用carousel-control-next-icon 在&lt;a&gt;層主要是定義按鈕的作用目的位置 href放上作用caroudal的id(也就是外層carousal的id) data-slide=&quot;prev&quot;是bootstrap自定義的屬性，用來轉換上一個或下一個項目 role＝”bottom”用來幫助殘障人士，可以借助閱讀器判斷該元件為按鈕 在&lt;span&gt;層主要就比較純粹定義按鈕的樣式 每個&lt;a&gt;中包含兩個&lt;span&gt;，一個是給一般使用者看的，另外一個是給身障人士可以透過screen reader讀取辨識的 aria-hidden=true&quot; 可以讓朗讀軟體讀不到此元件。相反的，sr-only 這個 class 是只有使用朗讀程式才可以讀取到的 1234567891011121314&lt;!-- &lt;div id=&quot;carouselExample&quot; class=&quot;carousel slide&quot; data-ride=&quot;carousel&quot;&gt; --&gt;&lt;!-- 位置放在carousal中 --&gt; &lt;a class=&quot;carousel-control-prev&quot; href=&quot;#carouselExample&quot; role=&quot;button&quot; data-slide=&quot;prev&quot;&gt; &lt;span class=&quot;carousel-control-prev-icon&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; &lt;span class=&quot;sr-only&quot;&gt;Previous&lt;/span&gt; &lt;/a&gt; &lt;a class=&quot;carousel-control-next&quot; href=&quot;#carouselExample&quot; role=&quot;button&quot; data-slide=&quot;next&quot;&gt; &lt;span class=&quot;carousel-control-next-icon&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; &lt;span class=&quot;sr-only&quot;&gt;Next&lt;/span&gt; &lt;/a&gt; &lt;!-- &lt;/div&gt; --&gt; indicators 程式碼位置，包在carousal中 使用&lt;ol&gt;及&lt;li&gt;列表結構 &lt;ol&gt;標籤中，套用carousel-indicators 每一個&lt;li&gt;標籤，就搭配到一個slide，若為預設可視的slide，class則添加active 12345678910&lt;!-- &lt;div id=&quot;carouselExample&quot; class=&quot;carousel slide&quot; data-ride=&quot;carousel&quot;&gt; --&gt;&lt;!-- 位置放在carousal中 --&gt;&lt;ol class=&quot;carousel-indicators&quot;&gt; &lt;li data-target=&quot;#carouselExample&quot; data-slide-to=&quot;0&quot; class=&quot;active&quot;&gt;&lt;/li&gt; &lt;li data-target=&quot;#carouselExample&quot; data-slide-to=&quot;1&quot;&gt;&lt;/li&gt; &lt;li data-target=&quot;#carouselExample&quot; data-slide-to=&quot;2&quot;&gt;&lt;/li&gt;&lt;/ol&gt; &lt;!-- &lt;/div&gt; --&gt; ==Use data attributes to easily control the position of the carousel. data-slide accepts the keywords prev or next, which alters the slide position relative to its current position. Alternatively, use data-slide-to to pass a raw slide index to the carousel data-slide-to=”2”, which shifts the slide position to a particular index beginning with 0.== 補：改變每一張slide停留的時間Bootstrap 預設每張幻燈片停留時間為5000毫秒(5秒)，可以用interval改變停留時間(單位為毫秒)。123$(&apos;.carousel&apos;).carousel(&#123; interval: 1000&#125;) 補：滑鼠滑入slide，不暫停輪播Bootstrap 預設當滑鼠滑入slide時，輪播會暫停，可以修改為pause:false。123$(&apos;.carousel&apos;).carousel(&#123; pause: false&#125;) 參考bootstrap部分原始碼 .carousel-inner .carousel-item .carousel-item .actice .carousel-control-prev .carousel-control-next .carousel-control-prev-icon .carousel-control-next-icon .carousel-indicators 成果My Project-LonelyPlanet-Home page-Header","categories":[],"tags":[]},{"title":"建立boiler樣板(下)-引入Font Awesome","slug":"建立boiler樣板(下)-引入Font Awesome","date":"2019-04-04T10:15:42.000Z","updated":"2019-04-08T11:27:31.199Z","comments":true,"path":"2019/04/04/建立boiler樣板(下)-引入Font Awesome/","link":"","permalink":"http://yoursite.com/2019/04/04/建立boiler樣板(下)-引入Font Awesome/","excerpt":"","text":"建立boiler樣板(下)-引入Font Awesome什麼是Font Awesome？ 用於網頁中加入icon的圖示庫，原理是把圖示icon都製作成文字的字型(fonts)，再透過CSS的去呼叫icon顯示出來。 相較於載入一張圖片，loading的負擔較低 可以透過指令放大縮小，不會造成像素失真的問題引入fontawesome 進入fontawesome的「start」頁面 將cdn複製貼上到&lt;head&gt;中 &lt;link rel=&quot;stylesheet&quot; href=&quot;https://use.fontawesome.com/releases/v5.8.1/css/all.css&quot; integrity=&quot;sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf&quot; crossorigin=&quot;anonymous&quot;&gt; 即可開始使用","categories":[],"tags":[]},{"title":"建立boiler樣板(上)-引入Bootstrap","slug":"建立boiler樣板(上)-引入Bootstrap","date":"2019-04-04T10:15:30.000Z","updated":"2019-04-08T11:27:40.526Z","comments":true,"path":"2019/04/04/建立boiler樣板(上)-引入Bootstrap/","link":"","permalink":"http://yoursite.com/2019/04/04/建立boiler樣板(上)-引入Bootstrap/","excerpt":"","text":"建立boiler樣板(上)-引入Bootstrap創建資料夾結構 先新增一個資料夾 再用vscode開啟該資料夾，並建立起資料夾結構12345boiler|_index.html|_img|_css |_style.css 將index.html與style.css檔做連結 引入bootstrapCSS 進入bootstrap網站「Get Start」頁面，將CSS stylesheet連結放在&lt;head&gt;的中，放置於所有stylesheet的最上方 1&lt;link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css\" integrity=\"sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T\" crossorigin=\"anonymous\"&gt; JS 進入bootstrap網站「Get Start」頁面，將JS的plugin 放在&lt;/body&gt;結束前12&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js\" integrity=\"sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js\" integrity=\"sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; jQuery 進入jQuery頁面，將最新版本的minified複製放在&lt;/body&gt;結束前 1234&lt;script src=\"http://code.jquery.com/jquery-3.3.1.min.js\" integrity=\"sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;","categories":[],"tags":[]},{"title":"Font Awesome-使用免費icon","slug":"Font Awesome-使用免費icon","date":"2019-04-04T10:13:54.000Z","updated":"2019-04-08T11:22:03.676Z","comments":true,"path":"2019/04/04/Font Awesome-使用免費icon/","link":"","permalink":"http://yoursite.com/2019/04/04/Font Awesome-使用免費icon/","excerpt":"","text":"Font Awesome-使用免費icon引入Font Awesome 參考文章：建立boiler樣板-(下)引入Font Awesome使用icon 在fontawesome的gaooery找到適合的icon 將&lt;i&gt;整段複製到要使用的html檔中 調整為不同尺寸(optional) 調整為不同顏色(optional) 實作1234567891011&lt;i class=&quot;fas fa-eye&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fas fa-eye-slash&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fas fa-thumbs-up fa-3x&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fas fa-thumbs-down fa-3x&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fab fa-gratipay fa-3x&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fas fa-comment fa-3x&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fab fa-youtube fa-5x&quot; style=&quot;color:#FF0000&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fab fa-line fa-5x&quot; style=&quot;color:#00c300&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fab fa-facebook-square fa-5x&quot; style=&quot;color:#3b5998&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fab fa-facebook-messenger fa-5x&quot; style=&quot;color:#0884F9&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fab fa-instagram fa-5x&quot; style=&quot;color:#BB2C8A&quot;&gt;&lt;/i&gt;","categories":[],"tags":[]},{"title":"Slick-快速打造一個carousel","slug":"Slick-快速打造一個carousel","date":"2019-04-04T09:18:10.000Z","updated":"2019-04-08T11:26:06.644Z","comments":true,"path":"2019/04/04/Slick-快速打造一個carousel/","link":"","permalink":"http://yoursite.com/2019/04/04/Slick-快速打造一個carousel/","excerpt":"","text":"Slick-快速打造一個carouselSlick是什麼？提供多種輪播樣式，以多組圖片輪播切換的套件，可應用於更多張圖片的展示。附上原始碼，複製貼上，即可使用現成的sliders樣式。 操作流程 引入slick cdn CSS搜尋slick cdn，找到slick-carousel cdn資源，將slick.css及slick-theme.css主題樣式複製到&lt;head&gt;中12&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/slick-carousel/1.9.0/slick.css&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/slick-carousel/1.9.0/slick-theme.css&quot; /&gt; JS再將slick.js複製到&lt;/body&gt;結束前且jquery後1&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/slick-carousel/1.9.0/slick.js&quot;&gt;&lt;/script&gt; 先在html建立好carousel的內容結構，並在外層給予一個class作為標記12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;div class=&quot;slider&quot;&gt; &lt;div&gt;slide 1&lt;/div&gt; &lt;div&gt;slide 2&lt;/div&gt; &lt;div&gt;slide 3&lt;/div&gt; &lt;div&gt;slide 4&lt;/div&gt; &lt;div&gt;slide 5&lt;/div&gt;&lt;/div&gt;``` 4. 進入[slick](http://kenwheeler.github.io/slick/)，選擇sliders樣式，複製下方的語法到`&lt;body&gt;&lt;script&gt;`中![](https://i.imgur.com/3VT5R1U.png)### optional控制元素* **arrows**: (boolean值)是否顯示左右箭頭功能* **dots**:(boolean值)是否顯示下方小圓點功能* **autoplay**：(boolean值)是否自動播放* **autoplaySpeed**:(毫秒值)自動播放的速度* **slidesToShow**:(數量值)一次主要顯現幾個slides* **slidesToScroll**:(數量值)每次滑動幾張slides* **fade**:(boolean值)是否採用淡出/淡入效果* **infinite**：(boolean值)滑到最後一張，是否繼續從回到一開始同向循環(4&gt;1&gt;2&gt;3&gt;...)，或是逆轉向循環(4&gt;3&gt;2&gt;...)* **centerMode**:(boolean值)是否同時顯現前後兩張slide的部分內容* **centerPadding**:(px值)搭配`centerMode:true`使用，表示前後兩張slide要顯現多少範圍* **responsive**:(陣列)針對不同尺寸做額外設定 * **breakpoint**:(螢幕尺寸) * **settings**:(&#123;物件&#125;)包含各種設定### 實作```htmlmixed= &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;slider&quot;&gt; &lt;div class=&quot;slide-1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;slide-2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;slide-3&quot;&gt;&lt;/div&gt; &lt;div class=&quot;slide-4&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; &lt;script&gt; $(&apos;.slider&apos;).slick(&#123; centerMode:true, centerPadding: &apos;100px&apos;, slidesToShow: 1, slidesToScroll: 1, autoplaySpeed: 2000, dots: true, arrows: true, &#125;); &lt;/script&gt; 成果My Project-LonelyPlanet-About page","categories":[],"tags":[]},{"title":"CSS-常見display屬性的值","slug":"CSS-常見display屬性的值","date":"2019-04-04T01:15:38.000Z","updated":"2019-04-08T11:20:09.613Z","comments":true,"path":"2019/04/04/CSS-常見display屬性的值/","link":"","permalink":"http://yoursite.com/2019/04/04/CSS-常見display屬性的值/","excerpt":"","text":"CSS-常見display屬性的值display: none display設為none這個東西就不見了，不佔空間。 補充：visibility:hidden是隱形看不見，不過還是有佔空間。 display: inline display : inline 的元素連在一起會在同一行，「不會換行」。 要讓 display : inline 元素水平置中的方式是在此元素的父元素加上 text-align : center。 &lt;a&gt;、&lt;span&gt;、&lt;b&gt;、&lt;i&gt;、&lt;iframe&gt;、&lt;img&gt;這幾個 HTML 元素預設的 display 屬性是 inline 可以針對左右做縮排(margin-left 、 margin-right 、 padding-left 、 padding-right「有效」) 上下縮排會失效，且寬高為內容本身寬高，無法自定義寬高。 (margin-top 、 margin-bottom 、 padding-top 、 padding-bottom 、 width 、 height 、 background-image 皆「無效」) display: block 不論前後元素為何，display:block 元素會直接「換行」開始。 &lt;div&gt;、&lt;p&gt;、&lt;h1&gt;、&lt;h2&gt;、&lt;iframe&gt;、&lt;img&gt;這幾個 HTML 元素預設的 display 屬性是 block 可以自定義寬高或縮排(margin 、 padding 、 width 、 height 、 background-image 皆「有效」) display: inline-block 內部元素水平排列，而且不需要額外設定clear，也不會讓接著的元素疊上來。 可以理解為：外面是inline，裡面是block。所以元素「不會換行」，但是又可以設定元素的padding-top 、 padding-bottom 、 width 、 height 、 background-image 。","categories":[],"tags":[]},{"title":"Bootstrap-排版Grid system","slug":"Bootstrap-排版Grid system","date":"2019-04-03T22:11:56.000Z","updated":"2019-04-08T11:18:36.154Z","comments":true,"path":"2019/04/04/Bootstrap-排版Grid system/","link":"","permalink":"http://yoursite.com/2019/04/04/Bootstrap-排版Grid system/","excerpt":"","text":"Bootstrap-排版Grid system概念 Bootstrap的排版是使用css flexbox 結構上要分為兩層： 外層為row： 內層為一到多個col- row容器就是一個flexbox Bootstrap的概念是將row容器中，一行分成12等分 col-後面接的數字，就是在一行中，佔有幾個「1/12的空間」。例：col-3就代表佔了3/12的寬度空間 針對不同尺寸螢幕，可以定義各種尺寸的佔有空間。例：col-lg-3, col-sm-6會在lg size時佔有3/12，而在sm size時佔有6/12 如果一行中有兩欄，其加總空間未滿12/12，可以用offset製造空欄的效果。12345&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-lg-3 col-sm-4&quot;&gt;col-lg-3 col-sm-4&lt;/div&gt; &lt;div class=&quot;col-lg-5 col-sm-4&quot;&gt;col-lg-5 col-sm-4&lt;/div&gt; &lt;div class=&quot;col-lg-2 col-lg-offset col-sm-4&quot;&gt;col-lg-2 col-lg-offset col-sm-4&lt;/div&gt; &lt;/div&gt; 實作 Large時，一排四個 Medium時，一排兩個 Extra small時，一排一個12345678&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-lg-3 col-md-6&quot;&gt; &lt;div class=&quot;col-lg-3 col-md-6&quot;&gt; &lt;div class=&quot;col-lg-3 col-md-6&quot;&gt; &lt;div class=&quot;col-lg-3 col-md-6&quot;&gt; &lt;div class=&quot;col-lg-3 col-md-6&quot;&gt; &lt;div class=&quot;col-lg-3 col-md-6&quot;&gt;&lt;/div&gt; 成果My Project-LonelyPlanet-Author section","categories":[],"tags":[]},{"title":"Bootstrap-展開Collapse & Accordion","slug":"Bootstrap-展開Collapse & Accordion","date":"2019-04-03T03:26:30.000Z","updated":"2019-04-08T11:16:35.565Z","comments":true,"path":"2019/04/03/Bootstrap-展開Collapse & Accordion/","link":"","permalink":"http://yoursite.com/2019/04/03/Bootstrap-展開Collapse & Accordion/","excerpt":"","text":"Bootstrap-展開Collapse &amp; Accordion概念 給予一個button 在collapse-content(事件作用目標物)上面給予一個id 在button標籤中，用bootstrap自訂屬性data-toggle定義觸發事件，以及與data-target定義作用的目標物 Collapse實作 預設值為關閉collapse狀態，若要預設為展開開狀態，可以添加show12345678&lt;div class=&quot;card&quot;&gt; &lt;button data-toggle=&quot;collapse&quot; data-target=&quot;#collapse1&quot;&gt; Button 1 &lt;/button&gt; &lt;div id=&quot;collapse1&quot; class=&quot;collapse&quot; Collapse-content-1 &lt;/div&gt;&lt;/div&gt; Accordion12345678910111213141516171819202122232425262728293031323334353637&lt;div id=&quot;accordion&quot;&gt; &lt;div class=&quot;card&quot;&gt; &lt;div class=&quot;card-header&quot;&gt; &lt;div href=&apos;#collapse1&apos; data-toggle=&quot;collapse&quot; data-parent=&quot;#accordion&quot;&gt; Button 1 &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;collapse1&quot; class=&quot;collapse show&quot;&gt; &lt;div class=&quot;card-body&quot;&gt; Collapse-content-1 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;card&quot;&gt; &lt;div class=&quot;card-header&quot;&gt; &lt;div href=&apos;#collapse1&apos; data-toggle=&quot;collapse&quot; data-parent=&quot;#accordion&quot;&gt; Button 2 &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;collapse2&quot; class=&quot;collapse&quot;&gt; &lt;div class=&quot;card-body&quot;&gt; Collapse-content-2 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;card&quot;&gt; &lt;div class=&quot;card-header&quot;&gt; &lt;div href=&apos;#collapse3&apos; data-toggle=&quot;collapse&quot; data-parent=&quot;#accordion&quot;&gt; Button 3 &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;collapse1&quot; class=&quot;collapse&quot;&gt; &lt;div class=&quot;card-body&quot;&gt; Collapse-content-3 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 成果My Project-LonelyPlanet-Mission section","categories":[],"tags":[]},{"title":"CSS-用hover選擇器增加滑鼠互動效果","slug":"CSS-用hover選擇器增加滑鼠互動效果","date":"2019-04-03T02:52:02.000Z","updated":"2019-04-08T11:22:09.159Z","comments":true,"path":"2019/04/03/CSS-用hover選擇器增加滑鼠互動效果/","link":"","permalink":"http://yoursite.com/2019/04/03/CSS-用hover選擇器增加滑鼠互動效果/","excerpt":"","text":"CSS-用hover選擇器增加滑鼠互動效果原理 先設定元件的初始樣式 再用css選擇器，添加:hover，並定義滑鼠移過的樣式 實作12345678.card&#123; color: #6C757D ; background-color: #ffffff;&#125;.card:hover&#123; color: #fff; background-color: #f2ac34;&#125; 成果My Project-LonelyPlanet-Author section 補充 hover經常被用在&lt;a&gt;標籤上 123a:hover&#123; background-color:yellow;&#125; 其他a標籤的連結效果 1234a:link &#123;color:blue;&#125;a:visited &#123;color:blue;&#125;a:hover &#123;color:red;&#125;a:active &#123;color:yellow;&#125;","categories":[],"tags":[]},{"title":"Html-一頁式網頁使用href滑頁","slug":"Html-一頁式網頁使用href滑頁","date":"2019-04-03T02:20:16.000Z","updated":"2019-04-08T11:24:43.044Z","comments":true,"path":"2019/04/03/Html-一頁式網頁使用href滑頁/","link":"","permalink":"http://yoursite.com/2019/04/03/Html-一頁式網頁使用href滑頁/","excerpt":"","text":"Html-一頁式網頁使用href滑頁原理 在每個區塊div設定id，讓 在menu的項目中設定每個項目的href目的位置為區塊div的id 用jquery增加scroller效果 實作 menu中的item使用&lt;a&gt;標籤，並將href設定為目標section的#id1234567891011&lt;ul class=&quot;navbar-nav&quot;&gt; &lt;li&gt; &lt;a href=&quot;#section1&quot;&gt;item 1&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#section2&quot;&gt;item 2&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#section3&quot; &gt;item 3&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; 123&lt;div id=&quot;section1&quot;&gt;&lt;/div&gt;&lt;div id=&quot;section2&quot;&gt;&lt;/div&gt;&lt;div id=&quot;section3&quot;&gt;&lt;/div&gt; 在body標籤中新增id 1&lt;body data-spy=&quot;scroll&quot; data-target=&quot;#main-nav&quot; id=&quot;home&quot;&gt; 用jQuery初始化scrollspy 1$(&apos;body&apos;).scrollspy(&#123; target:&apos;#mail-nav&apos;&#125;); 添加Smooth Scrolling 所有在#main-nav中的&lt;a&gt;被click，就會執行函式1234567891011121314151617$(&apos;#main-nav a&apos;).on(&apos;click&apos;,function(event)&#123;&lt;!--check for a hash value --&gt; if(this.hash !==&quot;&quot;)&#123; &lt;!-- prevent default behavior --&gt; event.preventDefault(); &lt;!-- Store hash --&gt; const hash = this.hash; $(&apos;html,body&apos;).animate(&#123; scrollTop: $(hash).offset().top &#125;, 800, function()&#123;&lt;!-- Add hush to URL after scroll --&gt; window.location.hash = hash; &#125;) &#125;&#125;) 成果My Project-LonelyPlanet","categories":[],"tags":[]},{"title":"Bootstrap-自定義重新設定Sass","slug":"Bootstrap-自定義重新設定Sass","date":"2019-04-03T01:39:56.000Z","updated":"2019-04-08T11:18:18.990Z","comments":true,"path":"2019/04/03/Bootstrap-自定義重新設定Sass/","link":"","permalink":"http://yoursite.com/2019/04/03/Bootstrap-自定義重新設定Sass/","excerpt":"","text":"Bootstrap-自定義重新設定Sass用koala設定 在專案資料夾中新增scss資料夾，以及style.scss檔案 進入Bootstrap-download，下載Source files 下載解壓縮後，將所有下載的scss資料夾中的所有檔案複製到自己專案的scss資料夾中 下載koala 用koala打開專案資料夾，取消不必被compile的項目 將bootstrap.scss重新輸出路徑到專案的css資料夾中，並且再回到koala執行Compile。Compile之後，就可以看到bootstrap.css出現在專案中 style.scss也重複上述動作，輸出路徑可以覆蓋原先css中的style.css檔案，一樣再執行Compile 用vscode打開專案，將舊的「bootstrap.css」與「style.css」刪除 在index.html中，重新設定bootstrap的引入設定，指定為專案中的bootstrap.css 在scss檔案中即可修改設定","categories":[],"tags":[]},{"title":"Bootstrap-自適應navbar","slug":"Bootstrap-自適應navbar","date":"2019-04-02T23:53:46.000Z","updated":"2019-04-08T11:18:28.069Z","comments":true,"path":"2019/04/03/Bootstrap-自適應navbar/","link":"","permalink":"http://yoursite.com/2019/04/03/Bootstrap-自適應navbar/","excerpt":"","text":"Bootstrap-自適應navbar概念 透過navbar-expand定義在何種尺寸，menu項目的呈現會改為「漢堡折疊」樣式效果 使用bootstrap自定義的data-toggle及data-target，決定按鈕點下之後，menu的div要以collapse方式展開實作 首先class套用navbar，預設讓它是一個dispaly:flex的彈性盒子，且內部item會水平置中對齊(可以參考bootstrap的原始碼查看css設定) navbar-expand-sm則是決定當螢幕尺寸小於sm時，會改為以「折疊漢堡」顯示menu項目;若從頭到尾都希望以「折疊漢堡」顯示，則不要在class使用任何navbar-expand 如果希望navbar不會受瀏覽頁面捲動而消失，會一直顯示在最上方，則在class加上fixed-top button就是畫面中的「漢堡折疊」，需套用navbar-toggler類。基本上就會被navbar-expand-sm的定義影響在什麼螢幕尺寸顯示，什麼尺寸隱藏(可以參考bootstrap的原始碼查看css設定) data-toggle是bootstrap自訂的屬性data-toggle=&quot;collapse&quot;，意思是當點擊它按鈕時，會觸發了”collapse”事件 data-target也是bootstrap自訂的屬性，當”collapse”事件觸發，它的目標是#navbarCollapse，所以下面的#navbarCollapse這個div就會展開。 #navbarCollapse這個div的class需套用collapse、navbar-collapse，基本上也就是會被navbar-expand-sm的定義影響在什麼螢幕尺寸顯示，什麼尺寸隱藏。 123456789101112131415161718192021222324&lt;nav id=&quot;main-nav&quot; class=&quot;navbar navbar-expand-sm navbar-dark fixed-top&quot; style=&quot;background-color:#24243c;&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;a href=&quot;index.html&quot; class=&quot;navbar-brand&quot;&gt;LonelyPlanet&lt;/a&gt; &lt;button class=&quot;navbar-toggler&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#navbarCollapse&quot;&gt; &lt;span class=&quot;navbar-toggler-icon&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;div id=&quot;navbarCollapse&quot; class=&quot;collapse navbar-collapse&quot; &gt; &lt;ul class=&quot;navbar-nav ml-auto&quot;&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a href=&quot;#home-section&quot; class=&quot;nav-link&quot;&gt;Home&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a href=&quot;#explore-head-section&quot; class=&quot;nav-link&quot;&gt;Explore&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a href=&quot;#author-head-section&quot; class=&quot;nav-link&quot;&gt;Author&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a href=&quot;#mission-head-section&quot; class=&quot;nav-link&quot;&gt;Mission&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/nav&gt; 參考bootstrap部分原始碼 navbar navbar-expand-sm narvar-collapse narvar-toggler 成果My Project-LonelyPlanet-Menu","categories":[],"tags":[]},{"title":"CSS-文字向左右對齊，並垂直置中","slug":"CSS-文字向左右對齊，並垂直置中","date":"2019-04-02T08:50:02.000Z","updated":"2019-04-08T11:20:16.338Z","comments":true,"path":"2019/04/02/CSS-文字向左右對齊，並垂直置中/","link":"","permalink":"http://yoursite.com/2019/04/02/CSS-文字向左右對齊，並垂直置中/","excerpt":"","text":"CSS-文字向左右對齊，並垂直置中目標效果 方法一 將外層容器定義為flex容器，且其中的items向容器中間對齊 定義外層容器中的item與item之間保持相同的空間距離 實作方法一12345678&lt;div class=&quot;header&quot;&gt; &lt;div class=&quot;left&quot;&gt; 我是左邊文字 &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; 我是右邊文字內容 &lt;/div&gt;&lt;/div&gt; 12345.header&#123; display: inline-flex; align-items: center; justify-content: space-between;&#125; 補充：當定義元素為彈性容器，而它的子元素們就會變成彈性項目。 flex 值會讓彈性容器變成塊級元素（block-level element） inline-flex 則會讓彈性容器成為單一的行內元素（atomic inline-level element）。 方法二 定義外層容器為彈性容器 定義內層item的寬度佔比為1:1填滿整個容器 內層item的文字各自靠左及靠右實作方法二123456789101112.header&#123; display: flex; align-items: center;&#125;.left&#123; flex: 1; text-align: left;&#125;.right&#123; flex: 1; text-align: right;&#125; 成果My Project-Profile-Projects page","categories":[],"tags":[]},{"title":"CSS-由左到右、由右到左，利用direction-reserve排版","slug":"CSS-由左到右、由右到左，利用direction-reserve排版","date":"2019-04-02T08:49:50.000Z","updated":"2019-04-08T11:21:40.768Z","comments":true,"path":"2019/04/02/CSS-由左到右、由右到左，利用direction-reserve排版/","link":"","permalink":"http://yoursite.com/2019/04/02/CSS-由左到右、由右到左，利用direction-reserve排版/","excerpt":"","text":"CSS-由左到右、由右到左，利用direction-reserve排版 概念 定義外層容器為一個靈活盒子 使用flex-direction定義「由右到左」、「由左到右」的兩種排版類別 兩種排版交互使用實作 定義外層容器display: flex flex-direction:row:row方向預設值為「由左到右」 flex-direction:row-reverse:方向反轉則為「由右到左」1234567891011121314&lt;div class=&quot;pieces-group&quot;&gt; &lt;div class=&quot;piece content-right&quot;&gt; &lt;div class=&quot;piece-photo&quot;&gt;&lt;/div&gt; &lt;div class=&quot;piece-content&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;piece content-left&quot;&gt; &lt;div class=&quot;piece-photo&quot;&gt;&lt;/div&gt; &lt;div class=&quot;piece-content&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;piece content-right&quot;&gt; &lt;div class=&quot;piece-photo&quot;&gt;&lt;/div&gt; &lt;div class=&quot;piece-content&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123456789.piece&#123; display: flex;&#125;.content-right&#123; flex-direction:row;&#125;.content-left&#123; flex-direction:row-reverse;&#125; 定義小螢幕尺寸時，容器內的items方向為column「由上到下」12345@media screen and (max-width: 994px)&#123; #projects-section .piece&#123; flex-direction:column; &#125;&#125; 成果My Project-Profile-Education page","categories":[],"tags":[]},{"title":"CSS-使用Flexbox，垂直置中float元素","slug":"CSS-使用Flexbox，垂直置中float元素","date":"2019-04-02T06:13:10.000Z","updated":"2019-04-08T11:17:50.146Z","comments":true,"path":"2019/04/02/CSS-使用Flexbox，垂直置中float元素/","link":"","permalink":"http://yoursite.com/2019/04/02/CSS-使用Flexbox，垂直置中float元素/","excerpt":"","text":"CSS-使用Flexbox，垂直置中float元素目標效果讓兩個浮動元素，可以垂直對齊 原始情況放置兩個浮動元素，它們各自都向上靠其所在的容器12&lt;div class=&quot;box1&quot;&gt;box1&lt;/div&gt;&lt;div class=&quot;box2&quot;&gt;box2&lt;/div&gt; 123456789101112131415.margin&#123; margin-top:50px;&#125;.box1&#123; width:200px; background: #F0780D; height:100px; float:left;&#125;.box2&#123; width:300px; background: #F0C7B2; height:50px; float:right;&#125; 作法在外層容器中，使用display: flex，並且置中12345.container&#123; margin-top:50px; display: flex; align-items: center;&#125; 垂直對齊vertical-align: middle無效在css官方文件中說明：“vertical-align屬性，僅能使用於inline 或 table-cell box”，所以flaot元素無法使用此方法 1234&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;box1&quot;&gt;box1&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;box2&lt;/div&gt;&lt;/div&gt; 123.container&#123; vertical-align: middle;&#125;","categories":[],"tags":[]},{"title":"CSS-刻出一個timeline","slug":"CSS-刻出一個timeline","date":"2019-04-02T03:57:24.000Z","updated":"2019-04-08T11:19:37.938Z","comments":true,"path":"2019/04/02/CSS-刻出一個timeline/","link":"","permalink":"http://yoursite.com/2019/04/02/CSS-刻出一個timeline/","excerpt":"","text":"CSS-刻出一個timeline概念 設定一個最外層div空間 直線：利用偽元素(Pseudo Element)」::after的繼承特性，會繼承原本元素的屬性，畫出一個與空間一樣高的元素。定義該偽元素的邊框，製作出直線的效果。並且運用絕對定位，讓直線可以定位在中間。 時間文字：在卡片前後各自放上時間開始、結束時間的div空間 時間圓圈：利用偽元素::before繪製出，以「時間文字」座位定位參考點，使用絕對定位讓兩這位置呈現水平對齊。 卡片：最後再針對自己的喜好定義卡片的樣式 若要製作出左右交叉的效果，再使用class分類針對左右交叉的卡片各自做定位定義 最後在針對小螢幕，使用＠medis定義位置、樣式 實現 html佈局：參考要呈現畫面的效果，由上到下規劃好div空間 123456789101112&lt;div class=&quot;timeline-section&quot;&gt; &lt;div class=&quot;container left&quot;&gt; &lt;div class=&quot;time&quot;&gt; &lt;span&gt;2019 MAR&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;card&quot;&gt; &lt;/div&gt; &lt;div class=&quot;time&quot;&gt; &lt;span&gt;2019 FEB&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; timeline-section因為最外層的timeline-section空間，將被用來作偽元素timeline的定位基準點，所以切記要定義position屬性 1234.timeline-section&#123; position: relative; background-color: #EDEEF0;&#125; timeline 使用偽元素::after，製作出一個timeline元素 其定位方式為絕對定位position: absolute，才可以製作出元素重疊的效果(畫面中呈現，timeline::after是重疊在timeline-section上方) 使用top、left、bottom、right定位 使用height: 100%，是強制它的高度跟一樣高 定義border，繪製出線條 因為我們運用這個偽元素只是要用邊框製造出線條，其中並不會放置內容物，所以content屬性定義為空 若想製作出實心效果，定義width為0;相反地，如果想要有空心效果，可以定義為其他數值，也可以定義background-color填充中間的色彩1234567891011.timeline::after&#123; position: absolute; top:0; height: 100%; left:50%; border:3px solid #56332e; content:''; width: 0px; background-color: #56332e; margin-left: -3px;&#125; time因為time會被內層元素用來做定位，所以切記要定義position屬性 12345678910.time&#123; position: relative; width: 120px; font-weight: bolder; &#125;.time span,&#123; color: #56332e; position: absolute; top:-10px;&#125; 時間圓圈 使用偽元素::before，製作出一個元素 其定位方式為絕對定位position: absolute，才可以製作出元素重疊的效果 為了確保出現在最上層，可以定義z軸 定義該空間的寬高 繪製該空間邊框border、圓角border-radius 因為我們運用這個偽元素只是要用邊框製造出線條，其中並不會放置內容物，所以content屬性定義為空12345678910.time span:before&#123; position: absolute; z-index: 1; width: 25px; height: 25px; border: 4px solid #56332e; border-radius: 50%; background-color: white; content:'';&#125; card依個人喜好，定義好卡片的樣式 1234567.card&#123; padding:20px 5px; background-color: #fff; border: none; color: #56332e; box-shadow: 0px 1px 15px rgba(86, 51, 46, 0.6);&#125; 左右交叉 額外在html中給予right、left類別 利用css選擇器，針對左右的卡片的內容物，給予不同的定義12345678910111213141516171819202122&lt;div class=&quot;timeline-section&quot;&gt; &lt;div class=&quot;container left&quot;&gt; &lt;div class=&quot;time&quot;&gt; &lt;span&gt;2019 MAR&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;card&quot;&gt; &lt;/div&gt; &lt;div class=&quot;time&quot;&gt; &lt;span&gt;2019 FEB&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;container right&quot;&gt; &lt;div class=&quot;time&quot;&gt; &lt;span&gt;2019 MAR&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;card&quot;&gt; &lt;/div&gt; &lt;div class=&quot;time&quot;&gt; &lt;span&gt;2019 FEB&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011121314.left .content&#123; padding-right:15px; left:0;&#125;.left .time&#123; left:50%;&#125;.left .time span:before&#123; text-align: left; left: -30px;&#125;.left .time span&#123; left:18px;&#125; 12345678910111213141516.right .content&#123; padding-left:15px; left:50%;&#125;.right .time&#123; left: 50%;&#125;.right .time span:before&#123; text-align: right; left: 80px;&#125;.right .time span &#123; left:-92px;&#125; 針對小螢幕做調整如果螢幕尺寸低於380px，就套用以下設定 註：如果針對「(max-width: 576px)」有額外定義，程式碼需寫在上方，數字越大，要先寫123456789101112131415161718192021222324252627282930313233343536373839@media screen and (max-width: 380px)&#123; .timeline::after&#123; left:60px; &#125; #timeline-section .container&#123; padding-left: 10px; &#125; #timeline-section .left .content, #timeline-section .right .content&#123; width: 70%; left:25%; text-align: left; &#125; #timeline-section .left .time, #timeline-section .right .time&#123; left:30px; right: 0; width: 10px; text-align: right; line-height: 15px; font-size: 12px; &#125; #timeline-section .left .time span, #timeline-section .right .time span &#123; left:-30px; &#125; #timeline-section .right .time span:before,#timeline-section .left .time span:before&#123; text-align: right; left: 40px; &#125; #timeline-section .right .time span:before, #timeline-section .left .time span:before&#123; content:''; position: absolute; width: 20px; height: 20px; background-color: white; border: 3px solid #2B6073; border-radius: 50%; z-index: 1; &#125;&#125; 成果My Project-Profile-Programing section","categories":[],"tags":[]},{"title":"CSS-圖片邊框","slug":"CSS-圖片邊框","date":"2019-04-02T01:00:40.000Z","updated":"2019-04-08T11:19:56.252Z","comments":true,"path":"2019/04/02/CSS-圖片邊框/","link":"","permalink":"http://yoursite.com/2019/04/02/CSS-圖片邊框/","excerpt":"","text":"CSS-圖片邊框概念分為兩層div空間 先定義下方piece空間的邊框角度 再定義上方piece-photo空間的邊框角度 最後定義上方piece-photo的背景，用background-imgage屬性引入圖片 實作外層：定義外層div空間的寬高、原角邊框等樣式設定內層： 先定義「內層空間的寬高」、原角邊框 background-image引入圖片之後，要定義「被引入圖片的寬高」、定位等設定 補充：更多圖片屬性設定參考 html&amp;CSS-插入(背景)圖片的作法-從css選擇器中定義背景123&lt;div class=&quot;piece&quot;&gt; &lt;div class=&quot;piece-photo&quot;&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516.piece&#123; width: 300px; background-color:white; border-radius: 0.25rem; &#125;.piece-photo&#123; background-size: 300px; border-top-left-radius: 0.25rem; border-top-right-radius: 0.25rem; background-image: url(\"../img/meal1.jpg\"); background-position: 50% 50%; background-attachment: scroll; width: 300px; height: 200px;&#125; 成果My Project-Profile-Education page","categories":[],"tags":[]},{"title":"CSS-設置背景overlay","slug":"CSS-設置背景overlay","date":"2019-04-02T00:59:32.000Z","updated":"2019-04-08T11:21:55.354Z","comments":true,"path":"2019/04/02/CSS-設置背景overlay/","link":"","permalink":"http://yoursite.com/2019/04/02/CSS-設置背景overlay/","excerpt":"","text":"CSS-設置背景overlay概念將「下方圖片」、「上方覆蓋色塊」分為兩層(兩個div) 外層的背景為一張圖片 內層的背景為透明色彩 註：外層div會先畫，因此在畫面會呈現在下方;相反的，內層div會後畫，在畫面中會呈現蓋在上方 實作最外層div的背景使用一張圖片(background-image屬性)，內層div的背景使用rgba的透明色彩123&lt;div cless=&quot;section&quot;&gt; &lt;div class=&quot;white-overlay&quot;&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011.section&#123; background-image: url(\"../img/education-bg.jpg\"); background-repeat: no-repeat ; background-size: cover; background-attachment: fixed; min-height: 1200px;&#125;.white-overlay&#123; background-color: rgba(255, 255, 255, 0.3); min-height: 1200px;&#125; 成果My Project-Profile-Notes page","categories":[],"tags":[]},{"title":"CSS-置中(align-items＆justify-content)","slug":"CSS-置中(align-items＆justify-content)","date":"2019-04-02T00:10:56.000Z","updated":"2019-04-08T11:21:49.298Z","comments":true,"path":"2019/04/02/CSS-置中(align-items＆justify-content)/","link":"","permalink":"http://yoursite.com/2019/04/02/CSS-置中(align-items＆justify-content)/","excerpt":"","text":"CSS-置中(align-items＆justify-content)用flex完成內容垂直置中 flex屬性解釋連結：在容器中分配並行空間(flex) 參考置中作法 display屬性為flex 透過align-items屬性，控制垂直定位 透過justify-content，控制水平定位12345.box&#123; display:flex; align-items: center; justify-content: center;&#125;","categories":[],"tags":[]},{"title":"CSS-在容器中分配並行空間(flex)","slug":"CSS-在容器中分配並行空間(flex)","date":"2019-03-28T04:46:52.000Z","updated":"2019-04-08T11:20:03.068Z","comments":true,"path":"2019/03/28/CSS-在容器中分配並行空間(flex)/","link":"","permalink":"http://yoursite.com/2019/03/28/CSS-在容器中分配並行空間(flex)/","excerpt":"","text":"CSS-在容器中分配並行空間(flex)使用時機希望容器之內的物件可以並行接續排列，並且每個物件都有固定比例占據該容器 CSS語法 外層容器的display屬性為flex 123.container&#123; display: flex;&#125; 在內層物件中，各自定義佔據的寬度或剩餘空間的分配比例 當 ==外層容器的空間足夠== 的情況： box1有設定width，會佔據固定寬度300px box2有設定width，會佔據固定寬度200px box3、box4沒有設定固定寬度，僅設定flex比例，則會依比例分配剩餘的空間 為了避免 ==外層容器空間不足== ，可以min-width輔助定義最小的寬度 box2因為沒有設定min-width，所以被擠壓到完全沒有空間 定義是否自動換行(flex-wrap) 定義「不換行」（flex-wrap預設值即為no-wrap，可省略不寫），可能會壓縮內層物件的寬度 1234.container&#123; display: flex; flex-wrap: no-wrap;&#125; 定義「自動換行」 1234.container&#123; display: flex; flex-wrap: wrap;&#125; 定義「換行後反轉」 12345.container&#123; display: flex; flex-direction: row; flex-wrap: wrap-reverse;&#125; 定義排序方向(flex-direction) 定義排序方向為「左到右」（flex-direction預設值即為row，可省略不寫） 1234.container&#123; display: flex; flex-direction: row; &#125; 定義排序方向為「右到左」 1234.container&#123; display: flex; flex-direction: row; &#125; 定義排序方向為「上到下」 1234.container&#123; display: flex; flex-direction: column;&#125; 定義排序方向為「下到上」 1234.container&#123; display: flex; flex-direction: column-reverse;&#125;","categories":[],"tags":[]},{"title":"html-建立第一個Hello world網頁","slug":"html-建立第一個Hello world網頁","date":"2019-03-28T00:07:18.000Z","updated":"2019-04-08T11:24:24.188Z","comments":true,"path":"2019/03/28/html-建立第一個Hello world網頁/","link":"","permalink":"http://yoursite.com/2019/03/28/html-建立第一個Hello world網頁/","excerpt":"","text":"html-建立第一個Hello world網頁使用工具 Mac電腦(ios系統) VScode編譯器步驟 開啟電腦內建的「文字編譯」，新增一個檔案 暫時先命名為index，並且設定為「純文字格式」 輸入內容「Hello world!」，並儲存 更改檔案副檔名「.html」 直接點選開檔案，或拖曳到瀏覽器打開檔案，即可看到網頁成功顯示","categories":[],"tags":[]},{"title":"Git基本指令","slug":"Git基本指令","date":"2019-03-27T23:58:30.000Z","updated":"2019-04-08T11:21:21.305Z","comments":true,"path":"2019/03/28/Git基本指令/","link":"","permalink":"http://yoursite.com/2019/03/28/Git基本指令/","excerpt":"","text":"Git基本指令終端機環境系統指令不同的作業系統，指令也會不太一樣。|Windows| MacOs | 說明 ||——–| ——– | ——–|| cd | cd | 切換目錄 || cd | cd| 切換目前所在位置 || dir | ls| 列出目前檔案列表 ||mkdir| mkdir | 建立新的目錄||無| touch | 建立檔案||copy| cp | 複製檔案||move| mv | 移動檔案||del| rm | 刪除檔案||cls| clear | 清除畫面上的內容| 目錄切換及顯示123456789101112131415//切換到/tmp目錄(絕對路徑)$ cd/tmp//切換到my_project目錄(絕對路徑)$ cd my_project//切換到上一層目錄(相對路徑)$ cd ..//切換到使用者的home目錄中的project裡的namecards目錄// \"~\"這個符號代表home目錄$ cd ~/project/namecards//顯示目前所在的目錄$ pwd 檔案列表ls指令可列出在目前目錄所有的檔案及目錄，後面接的 -al 參數，a 是指連小數點開頭的檔案（例如.gitignore）也會顯示，l 則是完整檔案的權限、擁有者以及建立、修改時間12345//列出目前所在目錄的所有檔案及目錄$ ls//列出目前所在目錄的所有檔案及目錄，包含副檔名及檔案權限等資訊$ls -al 目錄切換及顯示開啟終端機(terminal)，並試著操作以下指令，從建立一個全新的目錄開始。12345$ cd /tmp //切換至 /tmp 目錄$ mkdir git-practice //建立 git-practice 目錄$ cd git-practice //切換至 git-practice 目錄$ git init //初始化這個目錄，讓 Git 對這個目錄開始進行版控Initialized empty Git repository in /Users/leah/git-practice/.git/ :::info小數點開頭的目錄或檔案名稱（例如 .git），在一些作業系統中預設是隱藏的，需要開啟檢視隱藏檔之類的設定才看得到。::: :::infoShift+Command+ .就可以顯示出隱藏的檔案::: 把檔案交給Git控管先查詢目前目錄的狀態，下面產生的訊息意思是「現在沒東西可以提交（nothing to commit）」。1234567//查詢現在這個目錄的狀態$ git status On branch masterNo commits yetnothing to commit (create/copy files and use \"git add\" to track) 接下來， 建立一個檔案(也可以用一般的文字編輯器或檔案管理員來完成)12//在這個目錄裡透過系統指令建立一個內容為 “hello, git”$echo \"Hello,git\" &gt; welcome.html 檢查目錄，確實多了一個welcome.html檔案 並且，再次檢查目前目錄的狀態 welcome.html 檔案目前的狀態是 Untracked files，意思是這個檔案尚未被加到 Git 版控系統裡，還沒開始正式被 Git「追蹤」，它只是剛剛才加入這個目錄而已。1234567891011$ git statusOn branch masterNo commits yetUntracked files: (use \"git add &lt;file&gt;...\" to include in what will be committed) welcome.htmlnothing added to commit but untracked files present (use \"git add\" to track) 把 welcome.html 這個檔案交給 Git，讓 Git 開始「追蹤」它12//新增檔案讓git追蹤$ git add welcome.html 最後再檢查一次狀態123456789$ git statusOn branch masterNo commits yetChanges to be committed: (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) new file: welcome.html","categories":[],"tags":[]},{"title":"html-插入圖片路徑<img>","slug":"html-插入圖片路徑","date":"2019-03-27T23:51:58.000Z","updated":"2019-04-08T11:24:15.954Z","comments":true,"path":"2019/03/28/html-插入圖片路徑/","link":"","permalink":"http://yoursite.com/2019/03/28/html-插入圖片路徑/","excerpt":"","text":"html-插入圖片路徑&lt;img&gt;在html中的圖片標籤為img，而其一的屬性src則要放入圖片檔案的位置，位置分為兩種 絕對路徑：放上圖片的url位置 相對路徑：相較於目前檔案的位置，找到圖片檔案的儲存位置1&lt;img src=&quot;&quot; alt=&quot;&quot;&gt; 方法一：絕對路徑 取得圖片的url位置：在圖片上方，點右鍵選取「複製圖片位址」 將url貼在src屬性中，並儲存 重新整理瀏覽器，網頁成功顯示出圖片 方法二：相對路徑 在專案中，先建立「img」資料夾，並在其中放入圖片檔案 在src屬性中，輸入圖片檔案的相對位置，並儲存 重新整理瀏覽器，網頁成功顯示出圖片","categories":[],"tags":[]},{"title":"Sketch to CSS","slug":"Sketch to CSS","date":"2019-03-27T23:47:32.000Z","updated":"2019-04-08T11:26:00.833Z","comments":true,"path":"2019/03/28/Sketch to CSS/","link":"","permalink":"http://yoursite.com/2019/03/28/Sketch to CSS/","excerpt":"","text":"Sketch to CSS學習來源 youtube影片：從 Sketch 設計到 CSS 切版 codepen案例：0913 demo 使用工具 Sketch：UI 設計軟體(補充youtube影片：六角學院 - Sketch 介紹) Codepen：線上編譯器 編譯器初始化設定(Pen Settings)step1.CSS設定為SCSS step2.載入icon服務可以手動直接將下方CDN貼到基本設定欄位中。或是透過畫面中內建的搜尋功能，搜尋：Font-Awesome，CDN將自動被加入欄位中。1https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css step3.設定完成(Save&amp;Close)正式開始切版切版呈現目標 背景色設定step1.(SCSS語法)將顏色命名為一個變數12$bg-color1: #FCF4ED;$bg-color2: #F0C7B2; step2.設計漸層背景 12345body&#123; height:100vh;/*body設定為裝置高度的100%*/ background-image:linear-gradient(175deg,$bg-color1,$bg-color1 50%,$bg-color2 50%) /*角度175度,開始色,開始色比例,結束色比例*/&#125; 中間卡片基本設定step1.先在html中給他一個命名，名為card1&lt;div class=&quot;card&quot;&gt;&lt;/div&gt; step2.在css中定義card的基本樣式123456.card&#123; background-color:#fff; padding:15px; height:60vh; width:600px;&#125; step3.加入：box-sizing屬性 ==當你設定一個元素樣式為 box-sizing: border-box;，這個元素的內距和邊框將不會增加元素本身的寬度。==123.card&#123; box-sizing:border-box;&#125; 或者可以用*{}，代表對所有元素統一做設定123*&#123; box-sizing:border-box;;&#125; step4.為card添加陰影1$card-box-shadow: 0 4px 30px #979797; 123.card&#123; box-shadow:$card-box-shadow;&#125; step5.如何讓card置中整個畫面呢？在body中加入對齊的設定！12345body&#123; display:flex;/*彈性布局*/ justify-content:center;/*//水平置中*/ align-items:center;/*垂直置中*/&#125; 卡片內圖片step1.先在html中給予一個畫面空間1234&lt;div class=&quot;card&quot;&gt; &lt;div class=&quot;brand-bg&quot;&gt;&lt;/div&gt;&lt;!--新增這個div作為圖片空間 --&gt; &lt;h1&gt;About JENDES&lt;/h1&gt;&lt;/div&gt; step2.先將父元素card定位123.card&#123; position:relative;&#125; step3.再將子元素brand-bg(遮色片)定位12345678.brand-bg&#123; position:absolute;/*相較於父元素的定位方式 */ left:0; top:0; bottom:0; width:445px; &#125; step4.載入圖片url，並相較於遮色片做定位12345.brand-bg&#123; background-image:url(https://images.unsplash.com/photo-1550939810-cb345b2f4ad7?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=2632&amp;q=80); background-size:527px 633px;/*載入圖片的尺寸 */ background-position:-41px -10px;/*相較於遮色片的定位 */&#125; step5.遮色片作梯形切割1234.brand-bg&#123; clip-path:polygon(0 0, 339.05px 0,445px 100%,0% 100%); /*四個點的位置依序是 左上,右上,右下,左下*/&#125; 卡片內文字step1.先在html中給文字一個區塊畫面12345678910111213141516171819202122&lt;div class=&quot;card&quot;&gt; &lt;div class=&quot;brand-bg&quot;&gt;&lt;/div&gt; &lt;div class=&quot;card-block&quot;&gt; &lt;div class=&quot;card-header&quot;&gt; &lt;h1&gt;About JENDES&lt;/h1&gt; &lt;/div&gt; &lt;div class=&quot;card-body&quot;&gt; &lt;p&gt;粉橘色，一個溫柔又有個性的顏色。 &lt;br/&gt;柔和色相的背後蘊含著明亮活潑的橘彩，卻同時調入了冷靜灰階。 &lt;br/&gt;有如生活中的我們，一人扮演著多種角色，每個角色充滿著層次、彈性，無法輕易僅以黑白雙色定義。 &lt;/p&gt; &lt;p&gt;讓每道顏色都能在這找到適合的穿著，舒服展現每一個自己。 &lt;br/&gt;由裡到外，穿出自信自在。 &lt;/p&gt; &lt;p&gt;When style shines from inside, no one can define you. &lt;br/&gt;You are just who you are. &lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;card-footer&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;btn&quot;&gt;＋電子報訂閱&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; ==p標籤代表文字段落== ==br標籤代表斷行== step2.定位文字區塊相較於card的位置 1234567891011.card-block&#123; width:318px; /*設定右方文字在左方圖層上面 */ position:relative; x-index:3; /*設定裡面的物件排列為flex*/ /* flex預設是由左至右，可以調整flex-direction:column，改為由上到下== */ display:flex; flex-direction:column;&#125; ==flex跟position是可以一起使用的，兩個沒有關係;float跟display也沒有關係;flex裡面可以再有flex== step3.設定card-footer定位在區塊的最下方1234.card-footer&#123; /*使用auto會自動將空間用空白補滿*/ margin-top:auto;&#125; step4.設定btn樣式 123456789101112$btn-color:#D8D8D8;.btn&#123; background-color:$btn-color; color:#000000; width:292px; padding-top:0.5rem; padding-bottom:0.5rem; display:block;/*設定區塊元素 */ text-decoration:none; text-align:center;&#125; ==display:block - 區塊元素，元素會以區塊方式呈現。一個區塊元素會讓其內容從新的一行開始顯示，並盡可能的撐滿容器。== ==display:inline - 行內元素，所有文字或圖片均不換行，也就是全部都會是同一行的意思。== step5.設定btn的動態hover樣式變化123456.btn&#123; background-color:$btn-color; &amp;:hover,&amp;:focus&#123; background-color:darken($btn-color,15%); &#125;&#125; step6.設定內文字體123456789101112131415161718h1&#123; font-size:32px; font-weight:bolder; &#125;.card-header&#123; color:#AD5E36; font-family:cursive; font-weight:bold;&#125;p&#123; font-size:16px; margin-top:16px; line-height: 20px;&#125;.card-body&#123; font-family:\"STXihei\",\"FangSong\",cursive; color:#6D7278;&#125; 參考資料：CSS 常用中文字型 (Traditional Chinese font family) step7.加上簽名圖片12345678.sign-image&#123; margin-left:203px; margin-top:16px; width:115px; height:39px; background-image:url(https://www.jendesstudio.com/front/assets/images/jenwu.png); background-size:115px 39px; &#125; 結果呈現 codepen編譯檔 github打包檔","categories":[],"tags":[]},{"title":"html-常見標籤(tag)與屬性(未完)","slug":"html-常見標籤(tag)與屬性","date":"2019-03-27T23:30:56.000Z","updated":"2019-04-08T11:24:36.880Z","comments":true,"path":"2019/03/28/html-常見標籤(tag)與屬性/","link":"","permalink":"http://yoursite.com/2019/03/28/html-常見標籤(tag)與屬性/","excerpt":"","text":"html-常見標籤(tag)與屬性(未完)###","categories":[],"tags":[]},{"title":"CSS-Box-sizing屬性","slug":"CSS-Box-sizing屬性","date":"2019-03-27T22:50:10.000Z","updated":"2019-04-08T11:18:09.672Z","comments":true,"path":"2019/03/28/CSS-Box-sizing屬性/","link":"","permalink":"http://yoursite.com/2019/03/28/CSS-Box-sizing屬性/","excerpt":"","text":"CSS-Box-sizing屬性使用情境在預設的情況box-sizing: content-box，padding的寬高，會被計算到元素的長寬中;如果希望元素的內距(padding)和外框(margin)不會增加元素本身的寬高，則可以使用box-sizing: content-box before瀏覽器預設值，box-sizing屬性，其值為content-box ==content-box：元素的實際寬高會再加上padding 和 border== 定義box1的寬為300px，高為50px，可是右方用瀏覽器查看元素時，發現尺寸變成330*80，是因為預設的情況，瀏覽將padding與border也算進元素中 after定義所有元素的box-sizing屬性，其值為border-box 123*&#123; box-sizing: border-box;&#125; ==border-box：元素的實際寬高不受padding 和 border影響== padding不會被增加到元素中，而border則算在元素之內，所以元素實際寬高仍保持為300*50","categories":[],"tags":[]},{"title":"JS-提升(Hoisting)","slug":"JS-提升(Hoisting)","date":"2019-03-27T22:49:40.000Z","updated":"2019-04-08T11:25:55.105Z","comments":true,"path":"2019/03/28/JS-提升(Hoisting)/","link":"","permalink":"http://yoursite.com/2019/03/28/JS-提升(Hoisting)/","excerpt":"","text":"JS-提升(Hoisting)javascript的執行環境分為兩階段，在執行程式碼(exection)之前，會經歷創建階段(creation)，在創建階段中會將函式及變數先設置在記憶體中，而這個動作稱作「提升(hoisting)」。 函式提升在執行任何程式碼前，JavaScript 會把「函式宣告初始化」放進記憶體裡面，意思是函式{}的內容都會在創建階段放在記憶體中。 變數提升在創建階段，電腦的記憶體為a空出記憶體，可是他還不知道他的值為何，會先給予一個undefine的值，等到執行階段賦值時，才會將a的值放進記憶體中。也因此下方案例，印出a並不會出錯，只是它的值為undefine。123456console.log(a);b();var num = 6; //只要 num 有被宣告，就不會有錯誤function b()&#123; console.log('b');&#125;","categories":[],"tags":[]},{"title":"JS-函式特性(Functions)","slug":"JS-函式特性(Functions)","date":"2019-03-27T22:46:26.000Z","updated":"2019-04-08T11:25:49.301Z","comments":true,"path":"2019/03/28/JS-函式特性(Functions)/","link":"","permalink":"http://yoursite.com/2019/03/28/JS-函式特性(Functions)/","excerpt":"","text":"JS-函式特性(Functions)學習來源:(Eloquent JavaScript電子書) 提升(Hoisting)javascript的執行環境分為兩階段，在執行程式碼(exection)之前，會經歷創建階段(creation)，在創建階段中會將函式及變數先設置在記憶體中，而這個動作稱作「提升(hoisting)」。 函式提升在執行任何程式碼前，JavaScript 會把「函式宣告初始化」放進記憶體裡面，意思是函式{}的內容都會在創建階段放在記憶體中。 變數提升在創建階段，電腦的記憶體為a空出記憶體，可是他還不知道他的值為何，會先給予一個undefine的值，等到執行階段賦值時，才會將a的值放進記憶體中。也因此下方案例，印出a並不會出錯，只是它的值為undefine。123456console.log(a);b();var num = 6; //只要 num 有被宣告，就不會有錯誤function b()&#123; console.log('b');&#125; 陳述式與表達式 表達式 (expression)，程式碼「會」產生(回傳)出一個值 12345var a=3; //瀏覽器console回傳3，這代表這段程式碼是Expression10+5;//瀏覽器console回傳15，它也是Expressiona === 3;//回傳true(成立)，它也是Expression 陳述式 (statement)，程式碼「不會」回傳出一個值 if()的()，需要放入一個表達式a===3，但if()本身不會有回傳值，也無法將它賦值火指向變數，因此它是一個陳述式 123if(a===3)&#123; console.log('good');&#125; 函式陳述式 (function statement) 程式碼本身不會執行，又稱做函式宣告，在創建階段就先把函式設定進記憶體，等待被呼叫 123funtion doIt()&#123; console.log('finished');&#125; 所以即使先程式碼撰寫先後順序是先呼叫do()再定義funtion do()並不會出錯;因為電腦實際運作的順序是 step0.創建階段先將`funtion do()`設定進記憶體 step1.讓所有程式碼開始執行，此時呼叫`do()`不會出錯 12345doIt();//step1.程式碼執行呼叫funtion doIt()&#123;//step0.創建階段已經被設定進記憶體 console.log('finished');&#125; 函式表達式 (function expression)當程式碼執行到=運算子右邊的程式碼，才建立這個函式物件，將其指向變數do 123var doIt = function()&#123; console.log('finish');&#125; 在創建階段，會先將var do宣告在記憶體中，但沒有定義其值，因此程式碼在執行到do()時會出錯;電腦實際運作的順序是step0.在記憶體中開一個洞命名dostep1.讓程式碼開始執行，由上往下先執行do()，因為do()本身尚未被定義assign值，所以出錯step2.執行到 = function(){}才將此匿名函式assign給do1234doIt();var doIt = function()&#123; console.log('finish');&#125; 全域與區域only functions created new scopes 全域 (global)宣告在function()之外為全域變數，可以在全域被呼叫，所以在function()內、外呼叫x都不會出錯 123456var x = 'x';myF();function myF()&#123; console.log(\"in:\"+x);//in:x&#125;console.log(\"out:\"+x);//out:x 區域 (local)區域變數只能作用在function()區域中，出了function()則無法被呼叫 123456789myF();function myF()&#123; let y = 'y'; var z = 'z'; console.log(\"in:\"+y);//in:y console.log(\"in:\"+z);//in:z&#125;console.log(\"out:\"+y);//undefineconsole.log(\"out:\"+z);//undefine 若在區域中，重新定義assign給全域變數，則該全域變數的值會改變1234567var x = 'x1';myF();function myF()&#123; x = 'x2'; console.log(\"in:\"+x);//\"in:x2\"&#125;console.log(\"out:\"+x);//\"in:x2\" 若在區域中，新增一個同名的變數，則其與外部的全域變數為兩個不相干的變數12345678console.clear();var x = 'x1';myF();function myF()&#123; let x = 'x2' console.log(\"in:\"+x);//\"in:x2\"&#125;console.log(\"out:\"+x);//\"in:x1\" 區域內的變數，不得與function()中的傳入參數的命名相同1234function myF(x)&#123; let x = 'x2'//x已經被宣告過了 console.log(\"in:\"+x);&#125; 引數(argument)與參數(parameter) 引數：用於呼叫函式的傳入「值」 參數：在函式中用來接引數所宣告的「變數」 1234plus(1,2,5);// 1,2,5為引數function plus(a,b,c)&#123; //a,b,c為參數 console.log(arguments)&#125; 參數預設值（Default Parameters） 直接在參數中建立預設值123456var plus = function(a=4,b=5)&#123; return a*b;&#125;console.log(plus(2,3));//6console.log(plus(2,));//10console.log(plus());//20 閉包(Closure)呼叫函式內的函式，將記憶體封存在內層1234567function initial(newMoney)&#123; var money = newMoney || 100 return function(price)&#123;// 這裡是一個閉包 money = money - price;//變數money封存於此記憶體內 return money; &#125;&#125;; 執行結果：p1與p2兩個變數分別創造兩個函式，因此也創造個別的兩個閉包，而閉包內的money值會分別存於各自的記憶體內 若直接執行initial()，其回傳值是一個函式，因此會獲得該匿名函式 遞迴(Recursion)在函式中呼叫自身同名函式，呼叫者(外層函式)會被先放入堆疊記憶體中，等到被呼叫者(內層函式)被執行完之後，再從堆疊記憶體中取出之前被放入的函式繼續執行。==堆疊(stack) 是「先進後出」的資料結構== ，也因此，最先被呼叫的函式，會最後被取出執行。12345678function fun(num)&#123; if(num===0)&#123; return 1; &#125;else&#123; return num*fun(num-1) &#125;&#125;fun(3);//6 執行解讀順序，12345673*fun(2); 2*fun(1); 1*fun(0); 1; 1*1; 2*1;3*2;","categories":[],"tags":[]},{"title":"CSS-position定位：absolute＆relative＆fixed","slug":"CSS-position定位：absolute＆relative＆fixed","date":"2019-03-27T22:38:54.000Z","updated":"2019-04-08T11:17:59.987Z","comments":true,"path":"2019/03/28/CSS-position定位：absolute＆relative＆fixed/","link":"","permalink":"http://yoursite.com/2019/03/28/CSS-position定位：absolute＆relative＆fixed/","excerpt":"","text":"CSS-position定位：absolute＆relative＆fixed使用時機當畫面中的元素需要重疊時，建議可以使用position屬性作定位 預設值(static) 在不設定position屬性的情況，瀏覽器的預設值為static 123.box&#123; position:static; &#125; 該元素「不會被特別定位」在頁面上特定位置，而是照著瀏覽器預設的配置自動排版在頁面上 相對定位(relative) css語法 position的值為relative 若’ 沒有 ‘設置其他top、right、bottom、left屬性，則其顯現的位置跟static一樣，會依照瀏覽器預設的配置自動排版在頁面上 若’ 有 ‘設置top、right、bottom、left屬性 ，該元素會「相對地」調整其原本該出現的所在位置123.box&#123; position:relative;&#125; 絕對定位(absolute) css語法 position的值為absolute top、bottom、left、right交互搭配使用，數值可以為負值或百分比 1234567.box&#123; position:absolute; top:0; bottom:0; left:0; right:0;&#125; ==若其外層容器沒有「可以被定位的元素(static以外的元素)」，那麼這個子元素的定位就是相對於該網頁（也就是 元素），作上、下、左、右位置的絕對定位（即使外層有包一個父元素，例：container）== ==Q: 如何以父元素作為定位空間?== ==A: 定義父元素的position== 123.container&#123; position:relative;&#125; ==內層absolute的子元素則會被外層父元素受限，並在父元素的空間作絕對定位== 固定定位(fixed) css語法 position的值為fixed 使用 top、right、bottom、left屬性來定位，可以為負值。12345.inner&#123; position:fixed; right: 0px; bottom: -100px;&#125; 該元素會相對於瀏覽器視窗來定位，即便瀏覽頁面捲動，它還是會固定在相同的位置。 補充：上下疊層(z-index) 在未設置z-index屬性的情況之下，疊層會按照程式碼由上而下畫圖，box1畫完才畫box2，所以box2疊在box1之上 若想要自定義疊層前後，則透過z-index屬性，==「數字越大=越後畫=疊在越上層 」==","categories":[],"tags":[]},{"title":"html&CSS-插入(背景)圖片的作法","slug":"html&CSS-插入(背景)圖片的作法","date":"2019-03-27T03:28:58.000Z","updated":"2019-04-08T11:23:38.956Z","comments":true,"path":"2019/03/27/html&CSS-插入(背景)圖片的作法/","link":"","permalink":"http://yoursite.com/2019/03/27/html&CSS-插入(背景)圖片的作法/","excerpt":"","text":"html&amp;CSS-插入(背景)圖片的作法方法一：使用html的img標籤 html-插入圖片路徑：絕對路徑 or 相對路徑 圖片寬高 直接給予匯入圖片的寬高值，有變形的風險 分別相較於父元素寬高的百分比 ==如果使用百分比的width，而沒有給予height，瀏覽器會固定將圖片寬高比例，避免變形的風險== 用css加上邊框樣式 方法二：從css選擇器中定義背景 先在html中提供一個空間 123&lt;body&gt; &lt;div class=&quot;box1&quot;&gt;box1&lt;/div&gt;&lt;/body&gt; 開始透過css選擇器，定義該空間的樣式(為了顯示整個空間，所以先趁一個底色) 1background-color: antiquewhite; ==定義該空間的寬高(注意：不等同於照片的寬高！)== 12width:1000px;height:600px; 定義要匯入的圖片 1background-image: url(\"https://images.unsplash.com/photo-1553451193-d4d44c036555?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1352&amp;q=80\"); ==定義匯入圖片的長寬== 1background-size:500px 333px; 設定背景圖片不要重複顯示 1background-repeat: no-repeat; 定義圖片會不會跟著瀏覽器跑動可以將背景圖視為下層，透過background-attachment屬性的定義，可以定義下層的背景圖是否要跟著上層的瀏覽的畫面連動位移 background-attachment:scroll不論上層的瀏覽頁面如何捲動，其下方的背景圖會牢牢地跟著上下滑動，所以可視的圖片內容都一樣，不會改變 background-attachment:fixed下層的背景圖片會固定在某個位置，當上層的瀏覽頁面捲動，所視畫面會隨位置的不同而看到不同的圖片內容。甚至，當下層的背景圖片不夠長，即看不到圖片了 定義圖片的位置background-position 屬性是用來指定背景圖案的位置。語法： 兩個字：第一個字為 [top,center,bottom] 中三選一，而第二個字由 [left,center,right] 中三選一。 兩個百分比：第一個百分比為 x軸的百分比，第二個為 y軸的百分比。 兩個數目：第一個數目為 x軸的位置，第二個數目為 y軸的位置。","categories":[],"tags":[]},{"title":"html&CSS-在html環境中插入css檔案","slug":"html&CSS-在html環境中插入css檔案","date":"2019-03-27T01:27:50.000Z","updated":"2019-04-08T11:23:47.404Z","comments":true,"path":"2019/03/27/html&CSS-在html環境中插入css檔案/","link":"","permalink":"http://yoursite.com/2019/03/27/html&CSS-在html環境中插入css檔案/","excerpt":"","text":"html&amp;CSS-在html環境中插入css檔案先建議一個專案 專案本身為一個資料夾，先為其命名，例:test-project 其中有一個index.html檔案 另外新增一個css資料夾，且其中有一個style.css檔案 引入css檔案 先開啟index.html檔案 在head中，加入link標籤，並且指向style.css檔案的位置 成功引入之後，便可以在style.css進行編輯，透過css選擇器定義樣式，去影響index.html的內容css選擇器(簡易示範) 在style.css定義h1、p的顏色樣式，並存檔 再次刷新瀏覽頁面，可以看到h1、p的樣式確實被改變了","categories":[],"tags":[]},{"title":"html-建立html環境","slug":"html-建立html環境","date":"2019-03-26T23:19:58.000Z","updated":"2019-04-08T11:24:31.099Z","comments":true,"path":"2019/03/27/html-建立html環境/","link":"","permalink":"http://yoursite.com/2019/03/27/html-建立html環境/","excerpt":"","text":"html-建立html環境基本環境架構 定義網頁的格式因為html的時代悠久，有許多不同的html版本格式，因此若使用html5格式，需在第一行新增一行定義 1&lt;!DOCTYPE html&gt; 所有撰寫內容，都先用html包起來，裡面有裡面有兩個標籤： head、body 12345678&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; head:放置網頁的相關資訊，例：網頁名稱、支援中文編碼模式、載入的css版本、載入的JS版本12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;My first web&lt;/title&gt;//網頁名稱 &lt;meta charset=&quot;UTF-8&quot;&gt;//支援中文編碼模式 &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 該網頁的頁籤變更為「My first web」 body:所有關於html的程式碼(網頁內容)，都放在body中1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;My first web&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;標題&lt;/h1&gt; &lt;p&gt;這是文字內容...這是文字內容...這是文字內容...這是文字內容...&lt;/p&gt; &lt;a href=&quot;https://www.google.com/&quot;&gt;連結&lt;/a&gt; &lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[]},{"title":"CSS-浮動定位(float)、清除浮動(clear)","slug":"CSS-浮動定位(float)、清除浮動(clear)","date":"2019-03-25T23:18:34.000Z","updated":"2019-04-08T11:20:23.164Z","comments":true,"path":"2019/03/26/CSS-浮動定位(float)、清除浮動(clear)/","link":"","permalink":"http://yoursite.com/2019/03/26/CSS-浮動定位(float)、清除浮動(clear)/","excerpt":"","text":"CSS-浮動定位(float)、清除浮動(clear)浮動定位(float)float使用時機&lt;div&gt;本身是區塊元素(block)，即使元素本身長度短於頁面行寬，仍會自動換行 12&lt;div class=&quot;box1&quot;&gt;box1&lt;/div&gt;&lt;div class=&quot;box2&quot;&gt;box2&lt;/div&gt; 12345678910.box1&#123; width:200px; background: #F0C7B2; height:50px;&#125;.box2&#123; width:200px; background: #F0780D; height:50px;&#125; 若希望&lt;div&gt;元素可以並行排列，則需要使用float屬性 123456.box1&#123; float:left;&#125;.box2&#123; float:left;&#125; css語法解釋1float: 浮動方向; 浮動方向可以用的值有 left（靠左浮動） right（靠右浮動） none（預設值，也就是不浮動） inherit（繼承自父層的屬性） 123456789101112.box1&#123; width:200px; background: #F0C7B2; height:50px; float:left;&#125;.box2&#123; width:200px; background: #F0780D; height:50px; float:right;&#125; 換行狀況即使使用float定位，當排列元素的累積寬度已經超過頁面行寬，就會自動換行 123456789101112.box1&#123; width:200px; background: #F0C7B2; height:50px; float:left;&#125;.box2&#123; width:800px; background: #F0780D; height:50px; float:left;&#125; 清除浮動(clear)使用時機當前面的元素為浮動元素，後續的區塊元素會從父階層容器開始的地方堆疊起123&lt;div class=&quot;box1&quot;&gt;box1&lt;/div&gt;&lt;div class=&quot;box2&quot;&gt;box2&lt;/div&gt;&lt;div class=&quot;box3&quot;&gt;box3&lt;/div&gt; 1234567891011121314151617.box1&#123; width:200px; background: #F0780D; height:50px; float:left;&#125;.box2&#123; width:300px; background: #AEB6B8; height:50px; float:left;&#125;.box3&#123; width:100%; background: #F0C7B2; height:100px;&#125; 當後面的元素不想要有float的浮動效果時，為了避免重疊狀況，必須在最後一個浮動元素後方，增加一個元素，並使用clear屬性1234&lt;div class=&quot;box1&quot;&gt;box1&lt;/div&gt;&lt;div class=&quot;box2&quot;&gt;box2&lt;/div&gt;&lt;div class=&quot;clearFloat&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box3&quot;&gt;box3&lt;/div&gt; 123.clearFloat&#123; clear:both;&#125;","categories":[],"tags":[]},{"title":"CSS-區塊元素(block)與行內元素(inline)","slug":"CSS-區塊元素(block)與行內元素(inline)","date":"2019-03-25T22:43:08.000Z","updated":"2019-04-08T11:19:46.322Z","comments":true,"path":"2019/03/26/CSS-區塊元素(block)與行內元素(inline)/","link":"","permalink":"http://yoursite.com/2019/03/26/CSS-區塊元素(block)與行內元素(inline)/","excerpt":"","text":"CSS-區塊元素(block)與行內元素(inline)區塊元素(block) 在新的一行開始 若沒有定義該元素長寬，則會100%佔滿所在空間 例：&lt;div&gt;會佔滿整個區塊(整行) css語法：display:block; 12345&lt;div class=&quot;block-section&quot;&gt; &lt;h1&gt;title&lt;/h1&gt; &lt;small&gt;small subtitle&lt;/small&gt; &lt;p&gt;here is the content&lt;/p&gt;&lt;/div&gt; 123456789.block-section h1&#123; display:block;&#125;.block-section small&#123; display:block;&#125;.block-section p&#123; display:block;&#125; 行內元素(inline) 不一定會在新的一行開始 該元素佔有的空間為其內容本身(文字或圖片)之長寬 無法重新自定義長寬 可能其他元素並排(視空間寬度而定) 例：&lt;span&gt;會接續前方元素，不會換行 css語法：display:inline;12345&lt;div class=&quot;inline-section&quot;&gt; &lt;h1&gt;title&lt;/h1&gt; &lt;small&gt;small subtitle&lt;/small&gt; &lt;p&gt;here is the content&lt;/p&gt;&lt;/div&gt; 123456789.inline-section h1&#123; display:inline;&#125;.inline-section small&#123; display:inline;&#125;.inline-section p&#123; display:inline;&#125;","categories":[],"tags":[]}]}