{"meta":{"title":"Leah's Blog","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"Vue-單一元件檔(Single-file components)","slug":"Vue-單一元件檔(Single-file components)","date":"2019-06-12T08:27:13.452Z","updated":"2019-06-12T08:28:27.555Z","comments":true,"path":"2019/06/12/Vue-單一元件檔(Single-file components)/","link":"","permalink":"http://yoursite.com/2019/06/12/Vue-單一元件檔(Single-file components)/","excerpt":"","text":"優缺點在許多 Vue 專案中，可以先定義一個「全域組件」Vue.component，接著再創建一個「Vue 實體」new Vue({el:&#39;#app&#39;})，並且將全域組件指定到頁面中的一個容器元素中。 這種方式卻僅適合中小型的專案，但是當專案更於複雜，會出現一些缺點： 全域定義問題(Global definitions)：每個組件(component)的命名不能重複。 字串模板問題(String templates)：在元件中的template屬性只能用字串，當使用編譯器(例：vscode)撰寫內容時，無法有效地以文字顏色區分、辨別內容 CSS 不支援問題(No CSS support)：在元件中只能提供 HTML 及 JavaScript，無法支援 CSS 預處理問題(No build step)：元件預設中只能使用 HTML 及 ES5，不能使用預處理工具，例：Babel 「單一元件檔(Single-file component)」就可以解決上述問題，它同時包含 HTML、JavaScript 及 CSS，一個.vue檔案就代表一個組件，且支援使用 Webpack 或 Browserify 等打包建置工具。 檔案樣板結構.vue檔案的基本內容結構： 12345678910111213&lt;template&gt; &lt;div&gt; &lt;!--HTML內容 --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; // JAvaScript內容&lt;/script&gt;&lt;style&gt; /*CSS內容 */&lt;/style&gt; 若不喜歡 HTML、JavaScript 與 CSS 三者合一，也可以改為將 JavaScript 及 CSS 分離成獨立的檔案再載入的寫法： 123456&lt;!-- my-component.vue --&gt;&lt;template&gt; &lt;div&gt;This will be pre-compiled&lt;/div&gt;&lt;/template&gt;&lt;script src=&quot;./my-component.js&quot;&gt;&lt;/script&gt;&lt;style src=&quot;./my-component.css&quot;&gt;&lt;/style&gt; templete 區塊&lt;template&gt;樣板裡的內容會被編譯為元件中 templete屬性的值，樣板中只能有一個根元素，也就是說所有內容要包在一個&lt;div&gt;&lt;/div&gt;中。 預設使用 HTML，但可以使用 lang 屬性指定為其他樣板系統，例： 1&lt;template lang=&apos;jade&apos;&gt;...&lt;/template&gt; script 區塊這個區塊中只能有一個，且最終必須匯出一個 Vue 物件。 預設為 JavaScript，要使用其他 JS 套件可以使用 require()。如果有安裝 babel-loader 在支援 ES2015 的環境中，則可以使用 import 及 export 語法。例： 12345import Vue from 'vue';import loadingFunc from '../Loading';export default &#123; &lt;!--component content --&gt;&#125;; 這裡記得 from 的部份，如果使用的是 node_modules 也就是由 npm / yarn 安裝的套件，直接寫套件的名稱；而如果是自己的 JavaScript 檔，則要在檔名前加上 ./。 style 區塊一個.vue檔案可以有零到多個&lt;style&gt;，且可以是全域或區域的&lt;style&gt;區塊。 &lt;style&gt;的預設為全域的，如果想要限制為區域作用(只在該組件中有效)，可以加上scoped屬性： 1&lt;style scoped&gt;...&lt;/style&gt; 預設為 CSS，也可以更換為 SCSS： 1&lt;style lang=&quot;sass&quot;&gt;...&lt;/style&gt; 簡易範例12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;p&gt;&#123;&#123; greeting &#125;&#125; World!&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;module.exports = &#123; data: function () &#123; return &#123; greeting: &apos;Hello&apos; &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;p &#123; font-size: 2em; text-align: center;&#125;&lt;/style&gt; 撰寫.vue 檔案先確定專案的結構，根目錄會有一個index.html作為執行 Vue 的入口;接著在 src 資料架，主要的程式碼都會放在這裡;main.js是程式的進入點，也可以透過 webpack.config.js 設定檔修改、自定義配置;myApp.vue則是這裡的重點，最終會匯出一個 vue 組件。 12345678project根目錄|_index.html|_src |_main.js |_component |_myApp.vue|_build |_webpack.config.js index.html放置在根目錄底下的index.html： 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;hello&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;!-- built files will be auto injected --&gt; &lt;/body&gt;&lt;/html&gt; 第 8 行，這是 Vue 的進入點。 這個檔案中只有最基本的 HTML 內容，沒有 CSS、JavaScript，第 9 行，建置後的檔案會自動引入。 myApp.vuecomponent 資料夾下方放置所有的 vue 組件，示範一個myApp.vue組件： 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div&gt; &lt;h1&gt;Hello&lt;/h1&gt; &lt;p class=\"hello\"&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; msg: '這是一個 Vue 組件檔！' &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;h1 &#123; color: green;&#125;.hello &#123; font-size: 1.5em; color: blue;&#125;&lt;/style&gt; main.jsmyApp.vue組件建立好之後，接著就可以引入到main.js。main.js。是程式的進入點，也可以透過 webpack.config.js 設定檔修改、自定義配置。 基礎的內容： 123456import Vue from 'vue';new Vue(&#123; el: '#app', template: '&lt;h1&gt;Hello Vue&lt;/h1&gt;',&#125;); 如果要引入myApp.vue組件，則要添加一些內容，如下： 12345678910import Vue from 'vue';import MyApp from './myApp';import MyApp2 from './myApp2';/* eslint-disable no-new */new Vue(&#123; el: '#app', components: &#123; myApp, myApp2 &#125;, template: '&lt;div&gt;&lt;myApp&gt;&lt;/myApp&gt;&lt;myApp2&gt;&lt;/myApp2&gt;&lt;/div&gt;',&#125;); 第 1 行import，&#39;vue&#39;是使用 node_modules 由 npm / yarn 安裝的套件，所以可以直接寫套件的名稱。 第 2 行import，&#39;./MyApp&#39;是自己的 JavaScript 檔，則要在檔名前加上 ./。 第 8 行，為 vue 實例添加components屬性，其值為引入組件，如有多個組件則用逗號分隔。 第 9 行，這樣就可以將 templete 樣板中改寫為&lt;myApp&gt;&lt;/myApp&gt;，立即使用引入的組件，但切記只能有一個&lt;div&gt;根元素，所以所有內容都要包在其中。 組件加在組件中除了上述將所有組件都引入到 main.js 中的做法，也可以把 myApp2 組件加在 myApp1 組件中： 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;h1&gt;Hello&lt;/h1&gt; &lt;p class=\"hello\"&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt; &lt;myApp2&gt;&lt;/myApp2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import myApp2 from './myApp2'export default &#123; data () &#123; return &#123; msg: '這是一個 Vue 組件檔(myApp1)！' &#125; &#125;, components: &#123; myApp2 &#125;&#125;&lt;/script&gt; 在第 10 行中，將 myApp 組件檔import進來 接著在第 18 行，將 myApp 組件 assign 到 component 屬性中 最後，在第 5 行，就可以在&lt;template&gt;中使用了 組件命名及使用不論 vue 組件的命名方式為何，在 html 中使用時，一律為 kebab-case (不分大小寫，一律轉為「小寫並加上 dash 線」) 假設 vue 組件為MyApp，在 HTML 呼叫使用時，需轉換為&lt;my-app&gt;&lt;/my-app&gt; 12345// 三種命名方式my-first-component //kebab-casemyFirstComponent //camelCaseMyFirstComponent //PascalCase 參考資料 How to create a Vue.js app using Single-File Components, without the CLI. 單一元件檔(Single-file components)","categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://yoursite.com/categories/Vue-js/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://yoursite.com/tags/Vue-js/"},{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Webpack-引入模組運用","slug":"Webpack-引入模組運用","date":"2019-06-12T02:42:47.852Z","updated":"2019-06-12T02:50:09.871Z","comments":true,"path":"2019/06/12/Webpack-引入模組運用/","link":"","permalink":"http://yoursite.com/2019/06/12/Webpack-引入模組運用/","excerpt":"","text":"環境建置1. 首先在專案中加入 npm 1npm init or 加上-y可以快速建立，略過中間自定義中間自定義的項目輸入 1npm init -y 完畢之後，會看到多了一個 package.json 檔案，並產生一些基本的內容 2. 安裝「開發環境」套件(視需求安裝) 1npm install webpack webpack-cli babel-loader babel-core css-loader vue-loader vue-template-compiler -D 指令後方加上-D 是--save-dev的縮寫，表示會將安裝的套件記載在 package.json 中的 devDependencies webpack:轉換並打包程式碼 webpack-cli:用以執行 Webpack 命令 babel-loader:將 ES6 語法轉換為 ES5 @babel/core &amp; @babel/preset-enccczzzssaddxxxccbbb: css-loader: vue-loader:將 vue 檔案轉換為 JavsSript vue-template-compiler:將 vue 檔案轉換為 JavsSript 3. 安裝「生產環境」套件，例：vue(視需求安裝) 1npm install vue -P 指令後方加上-P 是預設值可以不加，表示會將安裝的套件記載在 package.json 中的 dependencies or 在指令後方加上-S 1npm install vue -S 指令後方加上-S 是--save的縮寫，表示會將安裝的套件記載在 package.json 中的 dependencies vue: JS 前端框架 Webpack 概念說明 首先定義一個入口 js 檔案，而讓其他所有的 js 檔案都通過這個入口檔案，去執行底下的腳本。 而 Webpack 的執行入口也就是這個入口檔案，通過打包之後，最終會產生出 bundle 後的檔案。 最後，在 html中 script 讀取的檔案，則是打包後的檔案。 專案結構建置創建一個 src 資料夾，代表其中的文件為 sourse 來源，在其中有一個主要的 index.js 檔案（命名不限，通常是 main.js 或 index.js)，另外，有個 components 資料夾，裡面放著各種可以重複被利用的模組、函式 js 檔案。 123456src|_index.js|_components |_add.js |_minus.js |_ ...其他模組.js 完整的專案結構應該會長得像下方這張圖： 流程說明接下來會依序修改幾個檔案： index.html index.js add.js webpack.config.js package.json index.html在&lt;/body&gt;前引入打包後的 js 檔案，路徑參考實際專案中的資料夾結構 1&lt;script type=&quot;text/javascript&quot; src=&quot;./dist/index.bundle.js&quot;&gt;&lt;/script&gt; index.js寫入一些內容，其中 import 是 ES6 語法，透過 import 將其他 component 引入使用 12import add from './components/add';console.log(add(1, 2)); add.js透過 export 導出函式內容 123export default function(a, b) &#123; return a + b;&#125; webpack.config.js（Webpack 配置重點） 首先要有一個入口檔案，在第 2 行的 entry 屬性中，定義入口檔案的路徑 第 3 行是打包後的轉出文件，在 filename 中定義轉出後的檔案名稱 第 6 行，watch 屬性是定義是否實時自動偵聽，可以省去每次修改都重新手動打包的手續 第 7 行，是定義打包出來的內容是否要壓縮 12345678910module.exports = &#123; entry: './src/index.js', output: &#123; filename: 'index.bundle.js', &#125;, watch: true, optimization: &#123; minimize: false, &#125;,&#125;; 上述案例，執行 Webpack 打包，會自動新增一個 dist 資料夾，並將編譯後的檔案存於其中。 webpack.config.js-自定義轉出路徑若想自定義轉出路徑，可以新增 path，改寫如下： 第 6 行的意思， __dirname:在當前的資料夾 resolve:搜尋 build:名稱為 build 的資料夾 第 7 行的意思， filename:打包後的檔案命名為’index.bundle.js’, 12345678910111213var path = require('path'); // &lt;---- 引入pathmodule.exports = &#123; entry: './src/index.js', output: &#123; path: path.resolve(__dirname, 'build'), // &lt;---- 自定義資料夾路徑 filename: 'index.bundle.js', &#125;, watch: true, optimization: &#123; minimize: false, &#125;,&#125;; webpack.config.js-打包多個入口檔案 第 4 行的入口，改為物件寫法，多個”key/value” pairs， 第 10 行，轉出檔案的命名以原檔案的命名[name]去做自動命名，方便辨識 12345678910111213141516var path = require('path');module.exports = &#123; entry: &#123; index: './src/index.js', index2: './src/index2.js', &#125;, output: &#123; path: path.resolve(__dirname, 'build'), // &lt;---- 自定義資料夾路徑 filename: '[name].bundle.js', &#125;, watch: true, optimization: &#123; minimize: false, &#125;,&#125;; package.json在 script 屬性中新增 build 及 dev，並且定義指令訊息內容 12345&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;build&quot;: &quot;webpack --mode production&quot;, &quot;dev&quot;: &quot;webpack --mode development&quot; &#125;, 執行指令1npm run build 或是 1node_modules/.bin/webpack 執行結果 參考資料 使用 Webpack 來編譯 Vue.js Single File Components (.vue) 老黑 vue2+webpack+es6 技术入门教程（3） 老黑 vue2+webpack+es6 技术入门教程（5）配置文件 How to create a Vue.js app using Single-File Components, without the CLI.","categories":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/categories/Webpack/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/tags/Webpack/"}]},{"title":"JavaScript-嚴格模式\"use strict\"","slug":"JavaScript-嚴格模式_use strict_","date":"2019-06-12T02:42:38.768Z","updated":"2019-06-12T02:49:47.317Z","comments":true,"path":"2019/06/12/JavaScript-嚴格模式_use strict_/","link":"","permalink":"http://yoursite.com/2019/06/12/JavaScript-嚴格模式_use strict_/","excerpt":"","text":"在 JavaScript 中有許多鬆散的寫法，雖然因此讓 JS 的彈性受到讚賞，卻也導致 debug 的困難度。 &quot;use strict&quot; 是新加入的標準，目的在於讓「開發具備更穩定的 JS」更容易，當開發者使用不穩定的語法時，即會跳出警告，讓開發者避免這些寫法。 使用 strict mode (嚴格模式) 這個功能，會強迫開發者在開發過程中更為謹慎，用以限制鬆散的 JavaScript 寫法，相比之下也比較不會出錯。 優點與缺點優點： 撰寫出更為嚴謹的 JS 可以避免不可預知的意外狀況，特別是合作開發時，在 debug 他人撰寫的程式碼會更為簡易。 缺點： 嚴謹模式限制 JS 的彈性 若專案中使用很多第三方撰寫的 plugin 套件，可能因為嚴格模式而無法運作，會需要修改很多程式 建議及解套方法：嚴格模式除了可以寫在全域，也可以用在 function 中，如此一來就不會全域都嚴謹模式，避免影響既有的程式碼或 plugin 套件。 使用方式全域&quot;use strict&quot;直接寫在 JS 全域位置的最上方： 123456'use strict'; //使用 strict mode (嚴格模式)function testFun() &#123; var value = 123; return value;&#125; 區域&quot;use strict&quot;寫在函式的開頭位置： 123456function testFun() &#123; 'use strict'; //使用 strict mode (嚴格模式) var value = 123; return value;&#125; 如果不是寫在函式的開頭位置，則無效。 12345function testFun() &#123; var value = 123; ('use strict'); //嚴格模式無效&#125; 使用嚴格模式的受限 變數未宣告直接賦值 物件中有重複的屬性名稱 刪除已經宣告的錯誤 不能使用 ‘with’ 語法 argument, eval 不能作為變數名稱 保留字不得作為變數名稱，例：implements, interface, let, package, private, protected, static, yield 瀏覽器支援 Chrome13 之後都有支援 IE10,11 有支援 FF4 有支援 Safari5.1 之後有支援","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"CSS-Reset","slug":"CSS-Reset","date":"2019-06-12T02:42:10.358Z","updated":"2019-06-12T02:49:29.061Z","comments":true,"path":"2019/06/12/CSS-Reset/","link":"","permalink":"http://yoursite.com/2019/06/12/CSS-Reset/","excerpt":"","text":"在每一個瀏覽器，都會有瀏覽器自帶的 CSS 樣式檔案，用以呈現各個瀏覽器特有的預設外觀。雖然有預設樣式的好處是，當開發者沒有特別定義樣式時，至少會有基礎的排版、樣式效果；可是壞處是，當開發者自定義樣式時，經常會因此而出現不可預期的狀況。所以通常在做網頁切版時，都會用 CSS Reset，將瀏覽器預設的樣式通通歸零，包含行距離、字距、margin、padding⋯ 等。 Reset 版本最普遍常用的 CSS-Reset 為 Eric Meyer 版本 ，下方也以此版本說明。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129/* http://meyerweb.com/eric/tools/css/reset/ v2.0 | 20110126 License: none (public domain)*/html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,embed,figure,figcaption,footer,header,hgroup,menu,nav,output,ruby,section,summary,time,mark,audio,video &#123; margin: 0; padding: 0; border: 0; font-size: 100%; font: inherit; vertical-align: baseline;&#125;/* HTML5 display-role reset for older browsers */article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section &#123; display: block;&#125;body &#123; line-height: 1;&#125;ol,ul &#123; list-style: none;&#125;blockquote,q &#123; quotes: none;&#125;blockquote:before,blockquote:after,q:before,q:after &#123; content: ''; content: none;&#125;table &#123; border-collapse: collapse; border-spacing: 0;&#125; 可以看到內容即為將很多樣式都歸零，如此一來，不論使用者的瀏覽器版本，在 CSS Reset 之後，都是統一無樣式的版本。而開發過程中，也不會因為 各個瀏覽器各自的預設值，而影響到開發者重新自定義的樣式，進而發生不可預知的狀況。 如何 Reset？將 Eric Meyer 版本 寫好的程式碼內容，全部複製一份到個人專案中的一個 CSS 檔案中，可以命名為 reset.css 接著在專案中的每個 html 都引入 reset.css ，這樣就可以確定每個頁面在一開始的樣式都被歸零。 重點提醒！一定要在一開始就引入 CSS Reset，避免 CSS Reset 反而蓋掉開發者自行定義的樣式。 資料來源金魚都能懂網頁設計入門 : CSS Reset 小事之 CSS Reset 與 CSS normalize","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"JavaScript-BOM與DOM","slug":"JavaScript-BOM與DOM","date":"2019-06-12T02:41:03.679Z","updated":"2019-06-12T02:48:58.585Z","comments":true,"path":"2019/06/12/JavaScript-BOM與DOM/","link":"","permalink":"http://yoursite.com/2019/06/12/JavaScript-BOM與DOM/","excerpt":"","text":"檔案物件模型（Document Object Model, DOM）是瀏覽器的執行規範，提供了結構化的標準方法，將網頁的程式碼及其他程式語言結合起來。開發人員即可以通過文件中物件的屬性、方法和事件來掌控、操縱和建立動態的網頁元素。 DOM(Document Object Model)每個 DOM 的基礎建置在一個(D)文件上（也就是以 document 作為根基），而由 document 中的每個(O)物件作為出一個個節點，最後由這一個個節點，組成為一個 DOM Tree。 D：（文件）瀏覽器當前載入的 document O：（物件）將 document 中的所有元素視為物件，可以調用其屬性、方法 M：（模型）所有的物件在該結構中都是節點，這些眾多節點組成一個樹狀結構 將 HTML 分解為 DOM: DOM 節點有: 元素節點：上圖中&lt;html&gt;、&lt;body&gt;、&lt;p&gt;標籤皆是元素節點。 文本節點:向用户展示的内容，如&lt;li&gt;...&lt;/li&gt;中的 JavaScript、DOM、CSS 等文本。 屬性節點:標籤中的屬性，如&lt;a&gt;標籤中的連結屬性href=&quot;http://www.baidu.com&quot;。 查找節點的方法 方法 說明 getElementById() 獲取特定 ID 元素的節點 getElementsByTagName() 獲取相同元素的節點列表 getElementsByName 獲取相同名稱的節點列表 getAttribute() 獲得特定元素節點屬性的值 setAttribute() 設置特定元素節點屬性的值 removeAttribute() 移除特定元素節點的属性 節點的屬性 屬性 說明 nodeName 返回一个字串，其内容是節點的名字 nodeType 返回一个整數，這個數值代表给定節點的類型 nodeValue 返回給定節點的當前值 tagName 獲取元素節點的標籤名 innerHTML 獲取元素節點的内容 DOM 操作用 DOM API 可以輕鬆地删除、添加和替換節點。| DOM 操作 |说明 || ————- |:————-:||creatElement(element) |創建一个新的元素節點||creatTextNode() |創建一个包含給定文本的新文本節點||appendChild() |指定節點的最後一個節點列表後添加一个新的子節點||insertBefore() |將一個給定節點节点插入到一个給定元素節點的給定子節點的前面||removeChild() |从一个给定元素中删除子节点||replaceChild() |把一个给定父元素里的一个子节点替换为另外一个节点| BOM瀏覽器物件模型（Browser Object Model,BOM）是瀏覽器提供的附加對象，用於處理 document 以外的所有内容，主要處理瀏覽器窗口和框架，不过通常瀏覽器特定的 JavaScript 也會被看作 BOM 的一部分。 區別：BOM 描述了與瀏覽器進行交互的方法和接口，DOM 描述了處理網頁内容的方法和接口。 window 物件包含属性：document、navigator、frames、history、location、screen document 根節點包含子節點：forms、location、anchors、images、links 參考資料JavaScript 学习总结（三）BOM 和 DOM 详解知乎-BOM 和 DOM","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"WebSocket-簡易APP應用","slug":"WebSocket-簡易APP應用","date":"2019-06-12T02:40:53.017Z","updated":"2019-06-12T02:48:20.647Z","comments":true,"path":"2019/06/12/WebSocket-簡易APP應用/","link":"","permalink":"http://yoursite.com/2019/06/12/WebSocket-簡易APP應用/","excerpt":"","text":"完整 Demo:參考github 程式碼 安裝 nodemon持續監視程式碼，一旦我們做了修改並儲存，nodemon 就會自動重新啟動 Node.js 程式，這樣刷新瀏覽器就能看到變更。 1npm install -g nodemon 安裝完畢之後，輸入指令，就會啟用「自動偵聽並重啟」的功能： 1nodemon index.js nodemon 啟動之後，以可以看到提示字元，如果想要人工手動重啟，也可以輸入rs指令。 前端頁面功能12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485//建立一個WebSocket實體，建立完成自動連線到servervar sock = new WebSocket('ws://localhost:5001');//定義完成連線時的回呼函式sock.onopen = function(event) &#123; setTimeout(function() &#123; document.getElementById('status').setAttribute('class', 'status_connected'); document.getElementById('status').innerHTML = '&lt;b&gt;Connected&lt;/b&gt;'; &#125;, 3000); //設定按鈕監控click事件 document.querySelector('button').onclick = function() &#123; var date = new Date(); var data = &#123; user: document.getElementById('user').value, msg: document.getElementById('inputBox').value, time: date.getTime(), &#125;; //傳送訊之前要先將物件轉為JSON格式 sock.send(JSON.stringify(data)); document.getElementById('inputBox').value = ''; &#125;; //定義收到訊息時的回呼函式 sock.onmessage = function(event) &#123; console.log(event.data); //將JSON格式先轉為物件 var newEvent = JSON.parse(event.data); //判斷資料並分類做處理 switch (newEvent.type) &#123; case 'request': var time = new Date(newEvent.time).toLocaleTimeString(); var logArea = document.getElementById('chatArea'); var newArea = document.createElement('div'); newArea.innerHTML = \"&lt;div id='logArea'&gt;&lt;div class='card'&gt;\" + '&lt;p&gt;' + newEvent.user + ':&lt;b&gt;' + newEvent.msg + '&lt;/b&gt;&lt;small&gt;' + time + '&lt;/small&gt;&lt;/p&gt;&lt;/br&gt;&lt;/div&gt;&lt;/div&gt;'; logArea.appendChild(newArea); break; case 'response': var time = new Date(newEvent.time).toLocaleTimeString(); var resArea = document.getElementById('chatArea'); var newArea = document.createElement('div'); newArea.innerHTML = \"&lt;div id='resArea'&gt;&lt;div class='card'&gt;\" + '&lt;p&gt;' + newEvent.user + ':&lt;b&gt;' + newEvent.msg + '&lt;/b&gt;&lt;small&gt;' + time + '&lt;/small&gt;&lt;/p&gt;&lt;/br&gt;&lt;/div&gt;&lt;/div&gt;'; resArea.appendChild(newArea); break; case 'notify': var time = new Date(newEvent.time).toLocaleTimeString(); var resArea = document.getElementById('chatArea'); var newArea = document.createElement('div'); newArea.innerHTML = \"&lt;div id='resArea'&gt;&lt;div class='card'&gt;\" + '&lt;p&gt;' + newEvent.user + ':&lt;b&gt;' + newEvent.msg + '&lt;/b&gt;&lt;small&gt;' + time + '&lt;/small&gt;&lt;/p&gt;&lt;/br&gt;&lt;/div&gt;&lt;/div&gt;'; resArea.appendChild(newArea); break; default: break; &#125; &#125;;&#125;; 1234567891011121314151617181920&lt;div&gt; &lt;div id=&apos;status&apos; class=&quot;status_disconnected&quot;&gt;&lt;b style=&quot;color: white&quot;&gt;Disconected&lt;/b&gt;&lt;/div&gt; &lt;div id=&apos;content&apos;&gt; &lt;span&gt;User:&lt;/span&gt; &lt;select id=&apos;user&apos;&gt; &lt;option&gt;Amy&lt;/option&gt; &lt;option&gt;Bora&lt;/option&gt; &lt;option&gt;Cherry&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;br/&gt; &lt;div&gt; &lt;textarea id=&apos;inputBox&apos; type=&apos;text&apos; placeholder=&quot;Input message here&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;button&gt;Send&lt;/button&gt; &lt;div id=&apos;chatArea&apos;&gt; &lt;!-- 在這裡面處理appendChild() --&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930#chatArea &#123; border-top: 3px solid white; /* margin-top:10px; */ background-color: #f1f1f1; position: relative; width: 100%; margin: 0 auto;&#125;#logArea &#123; position: relative; width: 50%; left: 0; border-right: 3px solid white;&#125;#resArea &#123; position: relative; width: 50%; left: 50%; border-left: 3px solid white;&#125;.card &#123; position: relative; width: 100%; display: flex; align-items: center; justify-content: center;&#125; 後端處理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//建立server實體var webSocketServer = require('ws').Server;var wss = new webSocketServer(&#123; port: 5001 &#125;);//設計一個計數器，計算當前連線數量var count = 0;//定義每當一個連線建立的執行動作wss.on('connection', function(ws) &#123; var user = ''; count++; console.log('Curent clients:' + count); console.log('[Server] connected!'); //當某個建立連線的ws發送出message，會執行的動作 ws.on('message', function(data) &#123; //將JSON格式先轉為物件 var newData = JSON.parse(data); console.log(`[Server] received $&#123;data&#125;`); user = newData.user; //將訊息同步傳給「所有」的用戶端瀏覽器，達成訊息同步 wss.clients.forEach((client) =&gt; &#123; //判斷用戶端是否為發出訊息的自己，而做不同的處理 if (client == ws) &#123; newData.type = 'request'; &#125; else &#123; newData.type = 'response'; &#125; client.send(JSON.stringify(newData), (err) =&gt; &#123; if (err) &#123; console.log(`[Server] error: $&#123;err&#125;`); &#125; &#125;); &#125;); &#125;); //當某個用戶端斷線，所執行的動作 ws.on('close', function() &#123; count--; console.log('[Server] Lost a client.'); console.log('Online clients:' + count); var date = new Date(); newData = &#123; type: 'notify', user: user, msg: '[Left chat room]', time: date.getTime(), &#125;; //將斷線訊息同步給所有其他用戶 wss.clients.forEach((client) =&gt; &#123; if (client != ws) &#123; client.send(JSON.stringify(newData), (err) =&gt; &#123; if (err) &#123; console.log(`[Server] error: $&#123;err&#125;`); &#125; &#125;); &#125; &#125;); &#125;);&#125;);","categories":[{"name":"WebSocket","slug":"WebSocket","permalink":"http://yoursite.com/categories/WebSocket/"}],"tags":[{"name":"WebSocket","slug":"WebSocket","permalink":"http://yoursite.com/tags/WebSocket/"}]},{"title":"WebSocket-簡易server端實作","slug":"WebSocket-簡易server端實作","date":"2019-06-12T02:40:41.700Z","updated":"2019-06-12T02:48:41.878Z","comments":true,"path":"2019/06/12/WebSocket-簡易server端實作/","link":"","permalink":"http://yoursite.com/2019/06/12/WebSocket-簡易server端實作/","excerpt":"","text":"server 端環境建置首先，創立一個簡易的 WebSocket 資料夾專案，裡面有一個 index.js 檔案，以及一個 server 資料夾 123WebSocket|--index.html|--server（forder） 啟用 terminal，進入 WebSocket 專案資料夾中做初始化設定： 1npm init 接著，系統執行過程中，會被要求輸入幾個欄位(可以直接按 enter 略過到下一個欄位) package name: 你這個 Project 要叫什麼名字 version: 你決定這個 Project 現在該是第幾版 description: Project 基本介紹 entry point: 進入點，如果要跑你的 Project 應該要執行哪個檔案 test command: git repository: keywords: author: 作者(自己) license: 你這個 Project 是採用什麼授權的 結束後，可以看到 server 這個資料夾底下，自動產生了一個 Package.json 接著，在 server 資料夾中，手動新增 index.js 檔案 12345WebSocket|--index.html|--server（forder） |-package.json |-index.js 資料架構建置完，接著要在其中安裝 WebSocket: 1npm install ws 安裝完畢後，專案結構中會多出幾個檔案及資料夾，package-lock.json 中紀錄安裝套件相容的版本。 到目前為止，基本的環境建置完成。 建置後端 server這裡示範模擬 server，以本機端 5001 埠，作為配置 server 的接口。在資料夾中的 index.js 檔案中，寫入以下程式碼： 12345678910//導入WebSocket模組var WebSocket = require('ws');//引用Server類var WebSocketServer = WebSocket.Server;//建立實體(實例化)var wss = new WebSocketServer(&#123; port: 5001,&#125;); 也可以將上述三行程式碼，簡易化為下述兩行寫法 1234var WebSocketServer = require('ws').Server;var wss = new WebSocketServer(&#123; port: 5001,&#125;); 啟用 Server「control + ` 」快捷鍵開啟 vscode 中的終端機。在終端機可以先確認當前位置，用下述指令進入 server 資料夾中： 1cd server 在 server 中，輸入下述指令，啟用 server： 1node index.js 這樣的狀態就代表 server 正在運轉啟用中 為了確認 server 為啟動狀態，可以由前端測試是否可以連接上後端。在專案中的 index.html 檔案代表前端(用戶端)，在其中輸入指令，透過 server 端的 port:5001 接口，讓前端與後端建立連結： 12345678910var sock = new WebSocket('ws://localhost:5001');sock.onopen = function(event) &#123; //當為連結狀態，執行下述動作 console.log('Connected successfully!'); //製造ㄧ秒時間差，再傳送訊息給server setTimeout(function() &#123; sock.send('Hey there'); &#125;, 1000);&#125;; 啟用瀏覽器 locolhost:，查看開發工具 network，可以看到順利連結上 server，並執行從瀏覽器傳送訊息給 server 端。 server 端偵聽事件首先建立 WebSocket 的 server 實體， 1234567891011121314//先引用Server類//再new出實體，並asign給wss變數var WebSocketServer = require('ws').Server;var wss = new WebSocketServer(&#123; port: 5001 &#125;);//當偵聽到連結建立時，執行動作wss.on('connection', function(ws) &#123; console.log('Connected!'); //當偵測收到訊息時，執行動作 ws.on('message', function(message) &#123; console.log('Receieve:' + message); &#125;);&#125;); 用 vsCode 打開 terminal 查看 sever 端的 log 訊息，可以檢查看到確實有執行動作。 Server 端回傳訊息給前端1234567891011121314151617wss.on('connection', function(ws) &#123; console.log('Connected!'); //當偵測收到訊息時，執行動作 ws.on('message', function(message) &#123; console.log('Receieve:' + message); if (message == 'Hello') &#123; //從server回送訊息給前端 ws.send('Hey there from the server'); console.log('1'); &#125; else &#123; ws.send('what did you say?'); console.log('2'); &#125; &#125;);&#125;); 從瀏覽器的開發工具 NetWork&gt;WS 可以檢查到前、後端訊息傳遞的狀況。","categories":[{"name":"WebSocket","slug":"WebSocket","permalink":"http://yoursite.com/categories/WebSocket/"}],"tags":[{"name":"WebSocket","slug":"WebSocket","permalink":"http://yoursite.com/tags/WebSocket/"}]},{"title":"WebSocket-基礎介紹與實體物件","slug":"WebSocket-基礎介紹與實體物件","date":"2019-06-12T02:40:35.391Z","updated":"2019-06-12T02:47:36.952Z","comments":true,"path":"2019/06/12/WebSocket-基礎介紹與實體物件/","link":"","permalink":"http://yoursite.com/2019/06/12/WebSocket-基礎介紹與實體物件/","excerpt":"","text":"WebSocket 介紹What is WebSocket?WebSocket 是一種通訊協定(protocal)，可在單個 TCP 連接上進行全雙工通訊。在 WebSocket API 中，瀏覽器和伺服器只需要完成一次交握，兩者之間就可以建立永續性的連接，並進行雙向資料傳輸。 HTTP vs. WebSocket最普遍常見的 protocal 是 HTTP，不過 HTTP 有個缺陷：溝通只能由客戶端(browser)發起，無法做到由服務端(server)主動向客戶端發送訊息。效率低，必須不停地發送請求確認連結。 WebSocket 與 HTTP 最大的不同是，WebSocket 是一個持續的雙向連線，不需要重新連線，不需要重新傳送 request，反應更即時。 HTTP 是單向請求，必須由 browser 先發出一個 request，server 端才會回傳一個 response WebSocket 則是完成一次”握手”驗證之後，即可執行雙邊的訊息傳送，或是由 server 端主動回傳訊息 Why WebSocket?當我們需要客戶端 browser 需要與 server 端保持即時、持續的雙向溝通。例：Chat apps、Real time data analytics、Social media WebSocket 實體的方法與屬性建立一個 WebSocket 物件首先必須建立一個 WebSocket 物件，才能讓瀏覽器、伺服器以 WebSocket 協定進行通訊，物件一但被建立，就會自動與伺服器連線。 WebSocket 的建構子，有兩個參數: urlURL 的協議類型必須是 ws:// （非加密連線）或是 wss:// （加密連線） protocols，選擇性參數一個字串，或是字串組成的陣列，因此一個 Server 可以實作多個 WebSocket 子協定。 12345678//僅傳入連線用的URLnew WebSocket('URL');//指定伺服器使用某個sub protocolnew WebSocket('URL', 'prorocol');//指定伺服器執行多個sub protocolsnew WebSocket('URL', 'protocols[]'); 下方簡單建立了一個新的 WebSocket，連到位於 http://echo.websocket.org 的伺服器。 1var MySocket = new WebSocket('ws://echo.websocket.org'); 將這段程式碼貼到瀏覽器的 console 中，執行完，查看 Network&gt;WS，已經連上 echo.websocket.org 伺服器。 且再查看 Headers 中，可以看到狀態「101 Web Socket Protocol Handshake」 WebSOcket 的其他屬性及方法，參考這裡。 查詢 WebSocket 狀態WebSocket 物件中的 readyState 屬性是表示目前狀態，有四種值，分別代表不同的狀態。 WebSocket.CONNECTING:值為 0，表示正在連接中 WebSocket.OPEN:值為 1，表示已連結成功，可以進行通訊 WebSocket.CLOSING:值為 2，表示正在關閉 WebSocket.CLOSED:值為 3，表示為關閉狀態 可以透過狀態判斷，來做一些事，以下舉例： 1234567891011121314151617switch (MySocket.readyStatus) &#123; case WebSocket.CONNECTING: //do something break; case WebSocket.OPEN: //do something break; case WebSocket.CLOSING: //do something break; case WebSocket.CLOSED: //do something break; default: //this would never happen break;&#125; WebSocket.onopenWebSocket 物件中的onopen屬性，可以用於定義當連結成功後的回調函式，也就是當 WebSocket 完成連結時，會執行函式中的動作。 123mySocket.onopen = function(event) &#123; //do something&#125;; 若要指定多個回調函式，可以用addEventListener方法。 123mySocket.addEventListener('open', function(event) &#123; //do something&#125;); WebSocket.oncloseWebSocket 物件中的onopen屬性，可以用於定義當關閉連結後的回調函式，也就是當 WebSocket 關閉連結時，會執行函式中的動作。 1234mySocket.onclose = function(event) &#123; //do something //dandle close event&#125;; 若要指定多個回調函式，可以用addEventListener方法。 123mySocket.addEventListener('close', function(event) &#123; //handle close event&#125;); WebSocket.onmessageWebSocket 物件中的onmessage屬性，用於定義收到 server 傳來資料後的回調函式，也就是當偵聽到 sever 傳來訊息的事件，會執行函式中的動作。 1234mySocket.onmessage = function(event) &#123; var data = event.data; //do something for data&#125;; 若要指定多個回調函式，可以用addEventListener方法。 1234mySocket.addEventListener('message', function(event) &#123; var data = event.data; //do something for data&#125;); WebSocket.onerrorWebSocket 物件中的onerror屬性，用於定義報錯時的回調函式，也就是當偵聽到錯誤事件，會執行函式中的動作。 123mySocket.onerror = function(event) &#123; //handle error event&#125;; 若要指定多個回調函式，可以用addEventListener方法。 123mySocket.addEventListener('error', function(event) &#123; //handle error event&#125;); 傳資料給伺服器WebSocket 的send()方法，用於向伺服器傳送訊息。 1mySocket.send('message to server'); 可以傳送的格式，包含字串、Blob、ArrayBuffer。 若要傳送複雜的資料給伺服器，可以用 JSON 格式傳送物件，以下以聊天程式應用舉例： 123456789101112131415161718192021222324var time = new Date();//創建WebSocket實體var mySocket = new WebSocket('wss://echo.websocket.org');//當WebSocket狀態為連線時，執行的動作mySocket.onopen = function() &#123; var msg = &#123; type: 'message', text: document.getElementById('text').textContent, id: 'clientID', data: time.getTime(), &#125;; //先將資料轉為JSON格式，再傳資料給server mySocket.send(JSON.stringify(msg));&#125;;//當瀏覽器從伺服器接收到訊息，偵聽事件被傳入onmessage並觸發函式執行mySocket.onmessage = function() &#123; setTimeout(function() &#123; document.getElementById('text').innerHTML = '&lt;b&gt;Message already sent.&lt;/b&gt;'; &#125;, 5000);&#125;; 參考codepen 執行結果 從伺服器接收訊息12345678910111213141516171819202122232425262728293031mySocket.onmessage = function(event) &#123; setTimeout(function() &#123; document.getElementById('text').innerHTML = '&lt;b&gt;Message already sent.&lt;/b&gt;'; &#125;, 1000); console.log(event); var f = document.getElementById('chatbox'); var text = ''; var msg = JSON.parse(event.data); var time = new Date(msg.date); var timeStr = time.toLocaleTimeString(); //僅示範switch判斷，此案例會接到的為'message' switch (msg.type) &#123; case 'id': clientID = msg.id; setUserName(); break; case 'message': text = '使用者 &lt;em&gt;' + msg.id + '&lt;/em&gt; :&lt;b&gt;' + msg.text + '&lt;br&gt;&lt;/b&gt;' + '&lt;small&gt;登入於 ' + timeStr + '&lt;/small&gt;&lt;br&gt;'; break; default: break; &#125; if (text.length) &#123; setTimeout(function() &#123; document.getElementById('chatbox').innerHTML = text; &#125;, 2000); &#125;&#125;; 參考codepen 執行結果 關閉連線WebSocket 的close()方法，用於結束 WebSocket 連線。 1mySocket.close(); 關閉連線後，再次查看連線狀態為 3，代表狀態為 CLOSED 關閉的狀態。 參考資料 MDN web doc - 製作 WebSocket 客戶端應用程式 WebSocket 教程 - 阮一峰 WebSocket Tutorials - codedamn","categories":[{"name":"WebSocket","slug":"WebSocket","permalink":"http://yoursite.com/categories/WebSocket/"}],"tags":[{"name":"WebSocket","slug":"WebSocket","permalink":"http://yoursite.com/tags/WebSocket/"}]},{"title":"JavaScript-獲取當前時間","slug":"JavaScript-獲取當前時間","date":"2019-06-12T02:40:26.837Z","updated":"2019-06-12T02:47:04.227Z","comments":true,"path":"2019/06/12/JavaScript-獲取當前時間/","link":"","permalink":"http://yoursite.com/2019/06/12/JavaScript-獲取當前時間/","excerpt":"","text":"Date 物件是基於世界標準時間（UTC） 1970 年 1 月 1 日開始的毫秒數值來儲存時間。 Date 建構子語法透過建構子創建 Date 實體物件，建構子有下述四種： 12345678910111213//預設為「當前時間」的物件new Date();//傳入「某時間」距離標準時間「毫秒數」new Date(value);//表示時間日期的字串。//這個字串應該要能被 Date.parse()方法解析//格式因瀏覽器而不同，強烈不建議使用解析字串的方式建立 Date 物件。new Date(dateString);//不需要全部參數皆傳入，部分參數為選用new Date(year, month, day, hour, minutes, seconds, milliseconds); year：表示年份的整數。當數值落在 0 到 99 之間，表示 1900 到 1999 之間的年份。參考下面的範例. month：表示月份的整數。由 0 開始（一月）到 11 （十二月）。 day：選用。表示月份中第幾天的整數值。 hour：選用。表示小時數的整數值。 minute：選用。表示分鐘數的整數值。 second：選用。表示秒數的整數值。 millisecond：選用。表示毫秒數的整數值。 創建 Date 實體12345//先創建一個Date實體var time = new Date();//試著印出實體查看console.log(time); //Wed May 22 2019 10:42:52 GMT+0800 (台北標準時間) Getter下方示範幾個常用的 getter，更多請參考這裡 1234567891011121314//先創建一個Date實體var time = new Date();//獲取當前時間(取得的值為一個毫秒数值)var theTime = time.getTime(); //1558492972644var timeDetails = &#123; year: time.getFullYear(), month: time.getMonth() + 1, date: time.getDate(), hour: time.getHours(), minute: time.getMinutes(), second: time.getSeconds(),&#125;; Conversion getter下方示範將 Date 物件轉換為可閱讀的字串型式，並回傳 Date 的部分資訊 123time.toLocaleString(); //2019/5/22 上午10:42:52time.toLocaleDateString(); //2019/5/22time.toLocaleTimeString(); //上午10:42:52 更多 Date 參考：MDN web doc-Date","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JavaScript-參數(argument)與其餘參數(spread)","slug":"JavaScript-參數(argument)與其餘參數(spread)","date":"2019-05-18T14:12:28.773Z","updated":"2019-05-18T14:13:41.946Z","comments":true,"path":"2019/05/18/JavaScript-參數(argument)與其餘參數(spread)/","link":"","permalink":"http://yoursite.com/2019/05/18/JavaScript-參數(argument)與其餘參數(spread)/","excerpt":"","text":"函式執行時的參數變數重新複習一下，當函式被呼叫執行時，會創建一個新的執行環境，而在創建階段的同時，JavaScript引擎會設定幾個東西： 「變數環境」用來包住變數 給範圍鍊(Scope Chain)的「外部參考環境」 特殊關鍵字「this」 另一個特殊關鍵字「arguments」 即使我沒有在函式中宣告過arguments這個變數，當我在執行環境中直接呼叫arguments這個關鍵字，會印出有傳入值的所有參數。1234function greet(firstName,lastName,language)&#123; console.log(arguments);&#125;greet('Amy','Lin','En'); 印出的東西會是由斜體中括號 [] 呈現，有點像陣列，可是不太一樣，我們稱作為array-like，只有部分陣列的功能。 預設參數為undefined在JavaScript中，可以呼叫函式卻不傳入任何參數。因為當函式被呼叫執行時，在創建階段就會先在記憶體空間設定好這些值為undefined，所以並不會出錯。1234567function greet(firstName, lastName, language)&#123; console.log(firstName); console.log(lastName); console.log(language);&#125;greet(); 當我執行印出函式中的參數時，因為未傳入、賦予值給參數，所以就會印出預設值為undefined。 由左到右傳入參數值JavaScript可以處理為傳入參數的函式，也可以處理只傳入部分參述的函式。12345678910function greet(firstName, lastName, language)&#123; console.log(firstName); console.log(lastName); console.log(language); console.log('--------------')&#125;greet('Amy');greet('Amy','Lin');greet('Amy','Lin','English') 也就是說，當我宣告一個函式時，函式中的參數有三個，而當我呼叫執行時，我可以選擇不傳入值，也可以選擇只傳入一個或兩個，當然也可以傳入三個，可是要記得，一定是由左至右傳入設定做處理。 ES6語法:預設參數當不確定每次函式被呼叫時，會傳入幾個參數，卻不希望未被設定的參數值為undefined，在ES6版本中，可以自定義為參數設定預設值。1234567function greet(firstName, lastName, language='English')&#123; console.log(firstName); console.log(lastName); console.log(language);&#125; greet(); 也就是當呼叫函式時，若沒有給予language這個參數的值，則會在函式中賦值’language’給該參數。 不過因為這種ES6語法只適用於部分瀏覽器，所以下述寫法，也可以達成相同的目的。123456789function greet(firstName, lastName, language)&#123; language = language||'English'; console.log(firstName); console.log(lastName); console.log(language);&#125;greet(); 當呼叫greet()卻沒有傳入language參數的值，執行到上述第三行程式碼時，則會判斷出language為undefined，所以賦予值為’English’。 下方獨立解析這行「自定義參數預設值」程式碼意思。1language = language||'English' 其中看到兩個運算子，分別是’=’以及’||’，因為’||’的優先權較高，所以會先執行這個部分，接著才去執行’=’。 首先，執行’||’左邊的程式碼，若language為undefined，會被強制轉型為falese，而繼續執行’||’右邊的程式碼，獲得’English’的這個值。 接著，執行’=’的動作，就會將’English’賦值給變數language。 其餘參數(spread parameter)其餘參數是arguments被傳入函式時，還沒有被指定變數名稱的引數。12345function greet(firstName, lastName, ...otherP)&#123; console.log(otherP);&#125;greet('Amy','Lin','female','English') 其餘參數的變數名稱可以自定義，範例中使用otherP代表其餘參數。所以剩餘沒有被直接寫出來的參數，就會被包進這個otherP陣列中。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JavaScript-「沒有」重載函式(function overloading)","slug":"JavaScript-「沒有」重載函式(function overloading)","date":"2019-05-18T14:12:23.932Z","updated":"2019-05-18T14:13:23.538Z","comments":true,"path":"2019/05/18/JavaScript-「沒有」重載函式(function overloading)/","link":"","permalink":"http://yoursite.com/2019/05/18/JavaScript-「沒有」重載函式(function overloading)/","excerpt":"","text":"首先，先了解其他程式語言有的重載函式(function overloading)特性，在C#、C++、Java中，都有重載函式的概念。 重載函式多個函式可以重複使用同一個函式的名稱，只要有不同數量的參數，就會被判斷為不同個函式。12345678910111213141516171819//這裡僅用JS的語法表示其他程式語言的重載函式，但在JS中，無法正常執行function greet()&#123; console.log('hi');&#125;function greet(name, age)&#123; console.log(name); console.log(age);&#125;function greet(height,weight,age)&#123; console.log(height); console.log(weight); console.log(age);&#125;//呼叫函式時，帶入不同數量的參數//就會自動判斷是呼叫哪一個函式greet();greet('Amy','20');greet('70','180','male'); JS「沒有」重載函式在JavaScript中，函式就是物件，一個變數名稱只能代表一個物件，若用同一個名稱宣告多個函式，後方宣告的函式內容就會覆蓋前方的，所以JavaScript沒有處理重載函式的功能。 通用模式處理在一般的狀況，若參數值得狀況很多樣，並且要讓函式判別遇到不同參數，需要做出不同的處理過程，可以針對傳入參數做判斷。1234567891011121314function greet(firstName, lastName, language)&#123; language = language||'English'; if(language === 'English')&#123; console.log('Hi!'+firstName+' '+lastName); &#125; if(language === 'Spanish')&#123; cosole.log('Hola!'+firstName+' '+lastName); &#125;&#125;greet('Amy','Lin','English');greet('John','Chen','Spanish'); 不過，為了簡化呼叫時的傳入資訊，可以改寫為下方常見的模式寫法。額外新增兩個函式，在其中去執行呼叫不同傳入參數的函式。 123456789101112131415161718192021function greet(firstName, lastName, language)&#123; language = language||'English'; if(language === 'English')&#123; console.log('Hi!'+firstName+' '+lastName); &#125; if(language === 'Spanish')&#123; cosole.log('Hola!'+firstName+' '+lastName); &#125;&#125;function greetEnglish(firstName, lastName)&#123; greet(firstName, lastName, 'English')&#125;function greetSpanish(firstName, lastName)&#123; greet(firstName, lastName, 'Spanish')&#125;greetEnglish('Amy','Lin');greetSpanish('John','Chen');","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JavaScript-陣列","slug":"JavaScript-陣列","date":"2019-05-13T10:07:47.397Z","updated":"2019-05-13T10:09:14.822Z","comments":true,"path":"2019/05/13/JavaScript-陣列/","link":"","permalink":"http://yoursite.com/2019/05/13/JavaScript-陣列/","excerpt":"","text":"宣告陣列12345//一般宣告語法var arr = new Array();//或使用陣列實體語法var arr = []; 1234567//在中括號中，用逗號分隔值var arr = ['a','b','c']//index從0開始，抓出陣列中的值arr[0];//aarr[1];//barr[2];//c JS的陣列特性在其他程式語言的陣列中，通常都能包含同一種型別的值。比如說，數字陣列、字串陣列、物件陣列。 可是在JavaScript中，因為「動態型別」的特性，陣列中可以混合各種不同型別的值，JavaScript會自動去判別每一個值得型別。12345678910111213141516var arr = [ 1, 'member', false, &#123; name:'Amy', age:'20' &#125;, function(name)&#123; var greeting = 'hi'; console.log(greeting + name) &#125;, 'newMember'];console.log(arr); 若要執行陣列中的函式，可以使用陣列的index，呼叫出陣列中的東西，包含陣列中函式、字串、物件…等。1arr[4](arr[3].name);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JavaScript-\"this\"關鍵字","slug":"JavaScript-_this_關鍵字","date":"2019-05-13T10:07:41.964Z","updated":"2019-05-13T10:10:02.142Z","comments":true,"path":"2019/05/13/JavaScript-_this_關鍵字/","link":"","permalink":"http://yoursite.com/2019/05/13/JavaScript-_this_關鍵字/","excerpt":"","text":"全域this在全域環境中取用this，會指向全域物件。1console.log(this); 而在瀏覽器中執行，瀏覽器的全域物件為window物件。 函式中的this每當一個函式被呼叫，會創造出一個新的執行環境，且同時會產生一個未曾宣告的”this變數”，然而，”this變數”的值指向哪個物件，會依據函式在何處被呼叫而決定。 下述例子中，先有一個函式，其中log出this。當使用a()呼叫執行，代表執行該函式的程式屬性(code)，也就是函式中的全部程式。1234function a()&#123; console.log(this);&#125;a(); 實行結果，在a函式中的this，同樣指向全域物件的Window。下述另一個案例，使用函式表示式來設定一個物件函式，再將之assign給變數b。1234var b = function()&#123; console.log(this);&#125;b(); 執行結果，在b函式中的this，同樣指向全域物件的Window。 函式中創建全域物件下述程式碼統整目前的案例，有三個執行環境被產生： 全域環境 呼叫函式a，產生的區域環境 呼叫函式b，產生的區域環境 在每個執行環境中，分別產生三個不同的this變數，可是三個this都指向同一個位址(同一個全域物件window)。123456789function a()&#123; console.log(this);&#125;var b = function()&#123; console.log(this);&#125;a();b(); 小結，在函式中呼叫this，會指向全域變數，而非函式本身。 在下述程式碼中，在a函式中的this代表全域物件Window，所以宣告this.newVar代表宣告一個全域變數。也因此，直接在全域log出變數newVar不會出錯，因為它確實在執行a函式時，就已經被宣告出來了。123456function a()&#123; console.log(this); this.newVar = 'hello';&#125;a();console.log(newVar); 執行結果，會將newVar印出值為’hello’，且若點開Window物件中，也可以看到確實有一個變數為newVar。 物件中的this宣告一個物件c，在其中有屬性name，也有方法log，接著用c.log()執行物件c中的方法log。1234567var c = &#123; name:'The c obj', log: function()&#123; console.log(this); &#125;&#125;c.log(); 執行結果，在物件c的方法log中的this，代表物件c。 小結，當函式是物件的方法時，在其中呼叫的this變數會指向該物件本身。換句話說，this變數會指向包含它的物件。 在物件方法中修改物件的屬性物件c的log方法中，因為this代表物件c本身，所以用this.name代表物件c的屬性，藉此更改其值。12345678var c = &#123; name:'The c obj', log: function()&#123; this.name = 'update c obj' console.log(this); &#125;&#125;c.log(); 執行結果，可以看到物件c的屬性name確實被修改了。 self宣告模式，解決JS的不完美在物件d的方法log中，宣告一個函式物件setName，在其中的this變數並不會指向物件d，而是指向全域物件。1234567891011121314var d = &#123; name: 'The d obj', log: function()&#123; this.name = 'update d obj'; console.log(this.name); var setName = function(newName)&#123; this.name = newName;//這裡的this會設置到全域物件window中 console.log(this.name); &#125; setName('update again!'); console.log(this.name); &#125;&#125; 許多人會認為這是JavaScript本身的bug，但是事實上他就是這麼運作，因此若要避免產生錯誤，業界有一套常用的模式來應付這種狀況。 通常會在物件方法的第一行，宣告一個新的變數self，並且讓this指派給他，因為物件的assign是call by reference，因此self會指向this同一個位置，確保兩者指向同一物件e。12345678910111213141516var e = &#123; name: 'The e obj', log: function()&#123; var self = this; self.name = 'update e obj'; console.log(self.name); var setName = function(newName)&#123; self.name = newName;//這裡的this會設置到全域物件window中 console.log(self.name); &#125; setName('update e again!'); console.log(self.name); &#125;&#125;e.log(); 當有了一個變數self，之後修改或呼叫，就直接用self以確保是指向物件e。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JavaScript-傳值與傳參考","slug":"JavaScript-傳值與傳參考","date":"2019-05-13T10:07:36.885Z","updated":"2019-05-13T10:10:18.112Z","comments":true,"path":"2019/05/13/JavaScript-傳值與傳參考/","link":"","permalink":"http://yoursite.com/2019/05/13/JavaScript-傳值與傳參考/","excerpt":"","text":"傳值(by value)首先宣告一個變數a，並且assign一個純值(primitive)給a，則在記憶體中會有以個0x001位置存有該值，等著被a參照。接著，宣告一個變數b，並且將a指派給b (b = a)，實際上的執行狀況，會將a參照到的記憶體位置中的值複製到一個新的記憶體位置0x002，再讓b可以參照到它。 以下方程式碼為例，當執行到第6行，若重新assign一個值給a，並不會影響到b的值，因為a跟b是指向不同的記憶體位置，兩者的值不會互相被影響。123456789//call by value(primitives)var a = 3;var b;b = a;a = 2;console.log(a);//2console.log(b);//3 傳參考(by reference)首先有一個變數a，將一個物件(包含函式)指派給該變數，則在記憶體中會有一個位置0x001存有該物件，並透過記憶體位置被a參照到。接著，宣告一個變數b，並且將a指派給b (b = a)，此時並不會得到一個新的物件以及新的記憶體位置，而是會讓b也參照到跟a同個物件所在記憶體中的位置，也就是同樣指向0x001。這也代表，如果a的值被改變，b的值也同樣會被改變，因為它們兩者指向的物件就是同一個物件。 以下方程式碼為例，當執行到第6行，執行mutate，改變a物件中的值，接著再分別印出a、b的值，會發現兩者的結果皆被改變為mutate後的值了。123456789// call by reference(all objects, including functions)var a = &#123; greeting:'hi'&#125;;var b;b = a;a.greeting = 'hello';console.log(a);//&#123; greeting:'hello'&#125;console.log(b);//&#123; greeting:'hello'&#125; 傳參考(用於參數）在第5行，b已經指向a同個物件的記憶體，而當第9行將b作為傳入參數作為函式中obj物件，在第7行被mutate之後，最終a跟b所印出的值皆相同，因為兩者皆是指向同個記憶體位置中的同個物件。123456789101112//call by reference (even as parameters)var a =&#123; greeting:'hi'&#125;;var b;b = a;function changeGreeting(obj)&#123; obj.greeting = 'hola';&#125;changeGreeting(b);console.log(a);//&#123; greeting:'hola'&#125;console.log(b);//&#123; greeting:'hola'&#125; 使用等號運算子，創建一個新的記憶體空間透過”=”運算子創建物件，藉由這個物件實體語法，因為不知道{ greeting:&#39;hola&#39;}是否已經存在於記憶體，所以會另外創建一個記憶體空間給新的物件。123456789//equals operator sets up a new memory space(new address)var a = &#123; greeting:'hi'&#125;;var b = a;a.greting = 'hello';a = &#123; greeting:'hola'&#125;;console.log(a);//&#123; greeting:'hola'&#125;console.log(b);//&#123; greeting:'hello'&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JavaScript-函數陳述式與函數表示式","slug":"JavaScript-函數陳述式與函數表示式","date":"2019-05-13T10:07:31.804Z","updated":"2019-05-13T10:09:33.784Z","comments":true,"path":"2019/05/13/JavaScript-函數陳述式與函數表示式/","link":"","permalink":"http://yoursite.com/2019/05/13/JavaScript-函數陳述式與函數表示式/","excerpt":"","text":"陳述式vs.表示式 陳述式(Statement)只是去做某件事。 表示式(Expression)是程式碼的單位，位，會形成一個值，但不一定要存於一個變數中。陳述式if本身只是一個陳述句，它會去做其他事，但是不會回傳任何值。而在if的()中的條件是表示式，因為他會回傳一個值，true或false。1234var a;if (a === 3) &#123;&#125; 表示式以下三行分別的程式碼，都是一個表示式，因為他們執行完之後，都會回傳一個值。1a = 3; 11 + 2;//3 1a = &#123;language:'english'&#125; 以下執行結果可證，程式碼會回傳一個值，這個值可以是數值、字串或物件，無論是什麼型態都可以。 函數陳述式當它被呼叫執行，它不會回傳值1234function greet()&#123; console.log('hi');&#125;greet(); 函數表示式先宣告一個變數，並將一個函式assigm給該變數。因為函式在JavaScript中是一個物件，所以當該函式被指派給anonymousGreet變數時，在記憶體中的，anonymousGreet變數就會指向函式物件1234var anonymousGreet = function()&#123; console.log('hi');&#125;anonymousGreet(); 在這個例子中，該函式中並沒有name，是一個匿名函式，不過因為被assign給變數，所以可以透過該變數名去參照它。 所以在下圖中特別被標記出的這段程式碼為函數表示式，當整段程式碼執行時，會叫出函式物件並作回傳。 函數表示式並不會被hositing1234567anonymousGreet();//Uncaught TypeError: undefined is not a function.var anonymousGreet = function()&#123; console.log();&#125;anonymousGreet();//hi 在程式碼的創建階段，會在記憶體中創建變數anonymousGreet，預設值為undefined。開始執行，第1行呼叫函式，卻發現anonymousGreet為undefined值，而非一個函式，因此就會被出錯。因此正確寫法，應該是要在執行完第3行，assign一個函式給變數之後，才能如第7行呼叫。 將函數表示式作為傳入參數在JavaScript中，函式為一級函式，也就是函式可以視為物件，因此也可以作為將函式表示式作為另外一個函式的傳入參數。123456function log(a)&#123; a();&#125;log(function()&#123; console.log('hi');&#125;)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JavaScript-函式就是物件","slug":"JavaScript-函式就是物件","date":"2019-05-13T10:07:26.114Z","updated":"2019-05-13T10:08:59.531Z","comments":true,"path":"2019/05/13/JavaScript-函式就是物件/","link":"","permalink":"http://yoursite.com/2019/05/13/JavaScript-函式就是物件/","excerpt":"","text":"一級函式(First class function)在JavaScript中，函式可以被視作一級值。一級函式(First class function)，指的是可以處理程式語言中對其他任何型別(物件、字串、布林值、純值)的方式來處理它；換句話說，我們也可以對一級函式做出任何其他型別能做得到的事，包含以下： 將函式賦值給一個變數 將函式當成傳入參數，成為另外一個函式的引數 函式可以作為回傳值(在一個函式中，回傳另一個函式) 函式是特殊型態的物件在JavaScript中的函式有物件的特色，是一種特殊型態的物件。 函式中可以附屬有純值(primitive)(用name/value pair表示) 函式中可以附屬有物件 函式中可以附屬有其他函式 另外，函式包含兩個特別的屬性，一個是名稱(name)，一個是執行的程式內容(code)。 在name的部分，函式可以是匿名的(anonymous)，也就是可以不一定要有name。 而code的部分，也就是我們撰寫的程式碼內容。換句話說，我們撰寫的程式碼並非函式，而只是函式這個特殊物件中的一個屬性而已。而這個屬性可以透過”()”方法被呼叫、執行。 程式碼說明首先宣告一個函式為greet，因為在JavaScript中的函式同等於物件，因此我們用”.”為greet創造language屬性的值。在其他程式語言中，這樣會出錯，但是在JavaScript中是可行的。12345678function greet()&#123; console.log('hi');&#125;greet.language = 'english';console.log(greet);console.log(greet.language); 執行印出結果 以下解釋整個創建、執行的過程。 首先在創建階段會在全域記憶體中先創建一個全域物件，他的名稱是greet。而他的程式屬性，包含所寫的程式碼內容。而用”()”呼叫，即可執行該函式。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JavaScript-JSON與物件實體","slug":"JavaScript-JSON與物件實體","date":"2019-05-08T11:47:13.888Z","updated":"2019-05-08T11:49:21.956Z","comments":true,"path":"2019/05/08/JavaScript-JSON與物件實體/","link":"","permalink":"http://yoursite.com/2019/05/08/JavaScript-JSON與物件實體/","excerpt":"","text":"JSON的發展JSON(JavaScript Object Notation)是被JavaScript物件實體語法(Object literal syntax)所啟發的。 多年前，網路資料的傳輸格式很多種，像是XML。透過tag標籤，伺服器會解析它的資訊，可是當要下載資料時，因為過多不必要的tag符號，導致資料便很龐大，佔據很多頻寬。12345//xml格式範例&lt;object&gt; &lt;firstname&gt;Mary&lt;/firstname&gt; &lt;isAProgrammer&gt;true&lt;/isAProgrammer&gt;&lt;/object&gt; 後來發現JavaScript物件實體語法(Object literal syntax)的格式更簡易。1234var object = &#123; firstName:'Mary', isAProgrammer:true&#125; 因此，發展出一串字串的JSON格式，現今普遍都是使用JSON格式傳輸資料。 JSON格式有一些規範，屬性命名一定要被包在引號””中1234&#123; \"firstName\":\"Mary\", \"isAProgrammer\":true&#125; 轉換JSON的方法在JavaScript中，有兩個內建的函式可以轉化JSON格式。 將物件轉化為JSON字串 1JSON.stringify(object) 將JSON字串轉化回物件 1234JSON.parse('&#123; \"firstName\":\"Mary\", \"isAProgrammer\":true&#125;'); 12345678console.log(JSON.stringify(object));var jsonValue = JSON.parse('&#123; \"firstName\":\"Mary\", \"isAProgrammer\":true&#125;');console.log(jsonValue); 上述程式碼會印出下方所示的結果，先是印出一個JSON字串，接著再印出一個物件","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JavaScript-物件","slug":"JavaScript-物件","date":"2019-05-08T11:47:06.522Z","updated":"2019-05-08T11:50:10.537Z","comments":true,"path":"2019/05/08/JavaScript-物件/","link":"","permalink":"http://yoursite.com/2019/05/08/JavaScript-物件/","excerpt":"","text":"創建物件宣告一個物件，有以下兩種寫法。當JavaScript解析到大括號”{}”時，會認為這是在創造一個物件，因此下述第二行寫法，等同於創建一個空的物件。12var psrson = new Object();var person =&#123;&#125;; 初始化物件在創建物件的同時，也可以在大括號”{}”中同時創建其中的屬性及方法。12345678var Tony = &#123; firstName:'Tony', lastName:'Alicea', address:&#123; country:'Taiwan', city:'Taipei' &#125;&#125; 123function greet(person)&#123; console.log(\"Hi\"+person.firstname);&#125; 1greet(Tony);//Hi Tony 呼叫函式時同時建立物件1234greet(&#123; firstName:'Mary', lastName:'Doe'&#125;);//Hi Mary","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JavaScript-偽命名空間","slug":"JavaScript-偽命名空間","date":"2019-05-08T11:46:59.489Z","updated":"2019-05-08T11:51:20.058Z","comments":true,"path":"2019/05/08/JavaScript-偽命名空間/","link":"","permalink":"http://yoursite.com/2019/05/08/JavaScript-偽命名空間/","excerpt":"","text":"命名空間為何？在現代程式語言中，「命名空間(Namespace)」是承裝變數與函式的一個容器，通常會將變數跟函式的名稱分別開來。可是，在JavaScript中，並沒有命名空間。1234var greet = 'Hello';var greet = 'Hola';console.log(greet);//Hola 偽裝命名空間在JavaScript中為了避免衝突，可以使用物件當作容器，偽裝成命名空間的作用。這樣子也可以避免在不同的框架中，若想給變數或函式取名字時，可以避免重複命名而被覆蓋的問題。1234var english = &#123;&#125;;var spanish = &#123;&#125;;english.greet = 'Hello';spanish.greet = 'Hola';","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JavaScript-創建、取用物件中的屬性","slug":"JavaScript-創建、取用物件中的屬性","date":"2019-05-08T11:46:49.691Z","updated":"2019-05-08T11:50:57.135Z","comments":true,"path":"2019/05/08/JavaScript-創建、取用物件中的屬性/","link":"","permalink":"http://yoursite.com/2019/05/08/JavaScript-創建、取用物件中的屬性/","excerpt":"","text":"12345678var person = new Object();person['firstName']='Tony';person['lastName']='Alicea';var firstNameProperty = 'firstName';console.log(person); 上述結果會印出person物件，如下圖所示 若要取出物件中特定屬性的值，可以使用”[]”運算子1console.log(person[firstNameProperty])//Tony 簡化程式碼的寫法，可以使用”.”運算子，會自動理解”.”後述的為屬性名稱，並將該屬性名稱傳入物件中做參照查找，取出它的值。1console.log(person.firstName);//Tony 也可以用”.”去設定值。下述程式碼，會先去address中查找country、city屬性，若找不到則會自動建立這個屬性，並且賦值給它。123person.address = new Object();persone.address.country = 'Taiwan'persone.address.city = 'Taipei' 若要取值，可以用”.”也可以用”[]”去取出屬性的值，兩種寫法做的事情都一樣。1234console.log(person.address.country);//Taiwanconsole.log(person.address.city);//Taipeiconsole.log(person['address']['country'];//Taiwanconsole.log(person['address']['city'];//Taipei","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JavaScript-函式中的預設值","slug":"JavaScript-函式中的預設值","date":"2019-05-08T11:46:38.932Z","updated":"2019-05-08T11:50:33.771Z","comments":true,"path":"2019/05/08/JavaScript-函式中的預設值/","link":"","permalink":"http://yoursite.com/2019/05/08/JavaScript-函式中的預設值/","excerpt":"","text":"在JavaScript的函式中，每當一個函式被呼叫，就會創建一個執行環境，在這個執行環境(execution context)被創造的同時，會同步先在記憶體中創建引數中的變數，預設值為undefined。如果在呼叫函示時沒有帶入參數，並不會出錯，因為會被當作引數為undefined值做帶入。12345function greet(name)&#123; console.log('Hello'+name)&#125;greet();//Hello undefined; 上方的例子，在程式執行時，新的執行環境建立，而在其中也會宣告出一個變數name，在變數倍賦值之前，預設值為undefined。 建立預設值當沒有參數傳入時，如果希望自訂預設值，可以使用||(or運算子)來完成預設值設定。 當變數name為undefined時就會是false，接著就會繼續讀取”||”右邊的字串，並回傳該字串的值assign變數name。1name = name||'&lt;default name here&gt;' 查看Operator precedence(運算子 先後順序)，因為”||”相較於”=”有更高的precedence，所以會先執行”||”，並且由左至右執行。 當”||”左邊是true的時候，若讀取到true，會直接回傳true；但若讀取到false，就會繼續判斷”||”右邊，當右邊是一個字串時，它會判斷是true，並回傳字串。 12345678function greet(name)&#123; name = name || '&lt;default name here&gt;' console.log('Hello'+name)&#125;greet(Tony);// Hello Tony;greet();// Hello &lt;default name here&gt;;greet(0);// Hello &lt;default name here&gt;; 但是這個寫法要注意，傳入參數的值不能為0，因為0會被當成false，所以會繼續執行判斷”||”右邊。 避免library重複，設定預設值假設在同一個檔案中，引入三個library，lib1跟lib2的變數名可能會重複，程式碼會依照library引入的順序，由上而下執行，若變數有重複，後者會覆蓋前者變數的值。 12345678//lib1.js中var libraryName = 'lib1';//lib2.js中var libraryName = 'lib2';//app.js中console.log(libraryName);//lib2 為了解決變數重複，在使用之前可以先檢查該變數是非已經從存在於全域執行環境中。1window.libraryName = window.libraryName || \"lib2\"; 上述程式碼，會先檢查”||”左邊的值，若已經有被定義賦值，則會被判斷為true，並將字串assign給window.libraryName；若尚未被賦值則會判斷為false，並將”||”右邊的字串回傳assign給window.libraryName。12345678//lib1.js中var libraryName = 'lib1';//lib2.js中window.libraryName = window.libraryName || \"lib2\";//app.js中console.log(libraryName);//lib1","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JavaScript-型別","slug":"JavaScript-型別","date":"2019-05-03T06:16:44.010Z","updated":"2019-05-03T06:22:45.842Z","comments":true,"path":"2019/05/03/JavaScript-型別/","link":"","permalink":"http://yoursite.com/2019/05/03/JavaScript-型別/","excerpt":"","text":"動態型別(Dynamic Typing)在JavaScript中，不需要宣告變數的型別，因為JavaScript是使用「動態型別」在處理變數。 僅需要宣告變數(type)，不需要告訴JavaScript變數的型別(type)，它會在執行程式時，自動判別變數的型別，而且一個變數在不同時候可能擁有不同型別。 JavaScript的六種純值(primitive)純值是一種資料型別，代表基本型別，只是一個值，而非物件。 undefinedJavaScript給所有變數的初始值，變數會一直處於undefined，直到程式碼執行到設定變數的值 null表示不存在，可以在程式宣告時，給與該變數的值為null，用以表示該變數沒有值。 boolean表示對或錯，用true或false表示值 Number(數值)在JavaScript中的數值皆為浮點數，不像其他程式語言還會細分整數或其他浮點數等，所以在JavaScript中也可以直接把他假裝為整數。 String(字串)由一連串字符所組成，可以單引號或雙引號表示 Symbal(符號)這是新的型別，被用在ES6中，尚未被全部的瀏覽器支援 強制型轉(Coercion)JavaScript引擎自動將1轉換為字串’1’，才繼續做相加運算，自動避免出錯12var a = 1 + '2';console.log(a);//12","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JavaScript-執行緒、同步與非同步","slug":"JavaScript-執行緒、同步與非同步","date":"2019-05-03T06:16:38.051Z","updated":"2019-05-03T06:22:41.044Z","comments":true,"path":"2019/05/03/JavaScript-執行緒、同步與非同步/","link":"","permalink":"http://yoursite.com/2019/05/03/JavaScript-執行緒、同步與非同步/","excerpt":"","text":"單執行緒(Single Threaded)在程式碼裡面都有很多指令，單執行緒代表一次只執行一個指令。 同步執行(Synchronous)對程式語言來說，是一次一個，而且照出現順序一行一行執行。 非同步執行(Asynchronous)在同一時間中，不只一個在執行。 JavaScript引擎JavaScript引擎本身並非獨立存在，比如說在瀏覽器中，JavaScript並非唯一的東西，還會有其他的引擎處理別的程式，像是rendering engine會顯示畫面到螢幕中，或是也有負責處理HTTP請求資料的。 JavaScript引擎外部可以跟其他的引擎相互溝通，而且可以是非同步處理，也就是說JavaScript引擎、rendering engine、HTTP請求，這三者可以同時都在進行處理、執行。 然而，JavaScript引擎本身，是單執行緒和同步執行的。也就是說，在JavaScript引擎裡面，程式碼是一行一行被解讀。 總結，JavaScript引擎本身是單執行緒、同步執行，而向外的溝通、請求可以是非同步執行。 事件佇列(Event Queue)前面提到，JavaScript引擎本身是同步執行，但是當JavaScript引擎接收到從外部來的一個需要處理事件時，在JavaScript引擎中會先被放到等待列，也就是先放進事件佇列(Event Queue)。 JavaScript引擎還是會先處理完執行堆處理完，直到b()結束、a()結束、全域結束都從執行堆中pop掉，當執行堆是空的時候，JavaScript才會注意到Event Queue。 首先處理click事件，看到該事件觸發執行clickHandler()，所以就在執行堆中創建一個執行環境給它。當該事件處理完畢，被pop掉之後，執行堆中又被淨空了，才再繼續處理下一個佇列事件。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JavaScript-範圍鏈(scope chain)","slug":"JavaScript-範圍鏈(scope chain)","date":"2019-05-03T06:16:31.852Z","updated":"2019-05-03T06:22:36.059Z","comments":true,"path":"2019/05/03/JavaScript-範圍鏈(scope chain)/","link":"","permalink":"http://yoursite.com/2019/05/03/JavaScript-範圍鏈(scope chain)/","excerpt":"","text":"外部環境參照每個執行環境都會有一個外部環境參照，用意是當使用變數時，JavaScript不只會在當前的執行環境中尋找變數，也會到外部環境參眾中尋找變數123456789function b()&#123; console.log(myVar);&#125;function a()&#123; var myVar = 2; b();&#125;var myVar = 1;a(); 範圍鍊當在目前執行環境找不到變數或函式時，JavaScript會往外部環境參照找，若沒有找到，則再外繼續往下一層的外部環境找，一直往範圍鍊下面找，直到最底層的全域環境中。 1234567891011121314function c()&#123; console.log(myVAr);//1&#125;function a()&#123; function b()&#123; console.log(myVAr);//2 &#125; var myVar = 2; b(); c();&#125;var myVar = 1;a(); 注意！在範圍鍊中，每個執行環境的外部環境參照與「執行堆的上下位置」沒有關係，而是取決於「程式碼中的物理位置」","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JavaScript-執行堆","slug":"JavaScript-執行堆","date":"2019-05-03T06:16:10.132Z","updated":"2019-05-03T06:22:43.525Z","comments":true,"path":"2019/05/03/JavaScript-執行堆/","link":"","permalink":"http://yoursite.com/2019/05/03/JavaScript-執行堆/","excerpt":"","text":"呼叫函數(Invocation)當我們說到invocation function或是 function invocation，代表是去執行這個函式。 在JavaScript中，使用小括號()做「呼叫函式(invocation)」的動作1234function a()&#123; //宣告、定義a函式內容&#125;;a();//呼叫a函式 執行堆(Execution Stack)每一次在JavaScript呼叫函式，就會創造出一個新的執行環境，並且堆疊放進執行堆中(後者在上)，這個執行環境中會有自己的記憶體空間，用以存取區域變數和函式，並獨立進行其中的區域創建與執行 1234567function b()&#123;&#125;function a()&#123; b();&#125;a(); 上方的實際運作，當在全域creation創建階段時 會在全域記憶體中創建a()與b()函式 接著在全域execution執行階段時 讀到第7行時會呼叫a()函式，此時就會創造一個新的執行環境，放到執行堆中 當進入a()函式中呼叫到b()函式時，則會暫停當前的執行，另外創建一個新的執行環境，放到執行堆中 當b()函式執行完畢之後，該執行環境就會從之星堆被拿掉(pop) 接著回到a()函式中，執行完畢後，該執行環境再被拿掉(pop) 最後回到全域繼續執行完畢 變數環境每當一個執行環境被創造時，他都會有獨立的記憶體空間，用以存取區域變數和函式。 變數環境指的是，創建變數的位置。12345678910111213function b()&#123; var myVar; console.log(myVar);//undefined&#125;function a()&#123; var myVar = 2; console.log(myVar);//2 b();&#125;var myVar =1;console.log(myVar);//1a();console.log(myVar);//1 上方的實際運作，當在全域creation創建階段時 會在全域記憶體中創建a()與b()函式，以及變數myVar初始值為undefined 接著在全域execution執行階段時 讀到第10行時，會在全域的記憶體中設定變數myVar的值為1 讀到第12行時會呼叫a()函式，此時就會創造一個新的執行環境，放到執行堆中。在其中的獨立記憶體，創建變數myVar，同樣先給預設值undefined，等到執行到第6行內容，才設定myVar的值為2 在a()函式中呼叫到b()函式時，則會暫停a()當前的執行，另外創建一個新的執行環境，放到執行堆中 在b()函式中，又再獨立的記憶體中創建變數myVar，同樣先給預設值undefined 當b()函式執行完畢之後，該執行環境就會從之星堆被拿掉(pop) 接著回到a()函式中，執行完畢後，該執行環境再被拿掉(pop) 最後回到全域繼續執行完畢","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JavaScript-undefined vs. not defined","slug":"JavaScript-undefined vs. not defined","date":"2019-05-03T06:15:59.303Z","updated":"2019-05-03T06:22:02.656Z","comments":true,"path":"2019/05/03/JavaScript-undefined vs. not defined/","link":"","permalink":"http://yoursite.com/2019/05/03/JavaScript-undefined vs. not defined/","excerpt":"","text":"undefined值undefined是JavaScript中一個特殊的值，用以表示這個變數僅被宣告出來，可是值尚未被設定。 實際的運作上，會在creation創建階段先在記憶體中宣告一個變數a，並且給予undefined值。而進入execution執行階段，因為在呼叫變數a之前，沒有定義a的值，所以印出來的值就是undefined值。 not defined錯誤如果變數完全沒有被宣告，在creation創建階段並沒有任何變數被宣告出來，進入execution執行階段，當要呼叫變數b時，因為記憶體中完全沒有b這個變數及值，就會出現not defined錯誤。 補充：最好不要宣告值為undefinedundefined通常都是在creation創建階段，系統給予變數的一個預設值。雖然也可以人工宣告變數為undefined，可是會導致日後degub的困難。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JavaScript-提升(Hoisting)","slug":"JavaScript-提升(Hoisting)","date":"2019-05-03T06:15:48.791Z","updated":"2019-05-03T06:22:38.358Z","comments":true,"path":"2019/05/03/JavaScript-提升(Hoisting)/","link":"","permalink":"http://yoursite.com/2019/05/03/JavaScript-提升(Hoisting)/","excerpt":"","text":"javascript的執行環境分為兩階段，會先經歷創建階段(creation)，之後才正式進入程式碼執行階段(exection)。 在創建階段中會將函式及變數先設置在記憶體中，而這個動作稱作「提升(hoisting)」，另外細分解釋函式提升及變數提升。 函式提升在執行任何程式碼前，JavaScript 會把「函式宣告初始化」放進記憶體裡面，意思是函式{}的內容都會在創建階段放在記憶體中。 變數提升在創建階段，電腦的記憶體為a空出記憶體，可是他還不知道他的值為何，會先給予一個undefine的值，等到執行階段賦值時，才會將a的值放進記憶體中。也因此下方案例，印出a並不會出錯，只是它的值為undefine。 程式實際執行程序 首先在creation創建階段，會做： 函式提升-在記憶體中創建函式b(){…} 變數提升-在記憶體中創建出變數a，並給予預設值undefined 接著開始進入exection執行階段，由上而下一行一行編譯讀取程式碼 印出b的值(將b函式內容印出來) 呼叫b() 印出a的值(此時的值仍為預設值undefined) 設定a的值為’I am a’ 印出a的值(此時的值為’I am a’) 12345678console.log(b); function b()&#123; console.log('called b.');&#125;b();console.log(a);var a = 'I am a';console.log(a); 完整執行結果如下","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JavaScript-全域環境與全域變數","slug":"JavaScript-全域環境與全域變數","date":"2019-05-03T06:15:25.970Z","updated":"2019-05-03T06:21:57.636Z","comments":true,"path":"2019/05/03/JavaScript-全域環境與全域變數/","link":"","permalink":"http://yoursite.com/2019/05/03/JavaScript-全域環境與全域變數/","excerpt":"","text":"不論何時執行JavaScript程式， 程式碼都是在執行環境（execution context）裡面建立和執行。 (執行環境：一個wrapper，把正在執行的程式碼包在執行環境裡面。) 然而相較於執行環境，另外有一個基礎執行環境(base execution context)，又稱做全域執行環境。 全域(Global)‘Global’ means ‘not inside a function’簡而言之，當程式碼或變數不再函式中，就是全域的。 全域環境在全域執行環境中，JavaScript會自動創造兩個東西： Global Object：全域物件 this：一個特殊的變數全域物件「全域物件」，可以在任何地方被取用。 this變數在沒有寫任何程式碼的情況之下，啟用window瀏覽器執行，這時候全域執行環境中會自動產生一個全域物件-window物件，以及this這個特殊變數。 而在瀏覽器的全域的情況之下，this即為window物件。 同一個瀏覽器，開啟另一個分頁，就會創建另外一個全域執行環境，也會獨立產生一個全域物件及this變數。 若用不同的瀏覽器、伺服器(例：firefox)，也會產生一個全域物件-firefox，而this變數則為這個全域物件-firefox。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JavaScript-name/value及物件概念","slug":"JavaScript-name_value及物件概念","date":"2019-05-03T06:15:12.242Z","updated":"2019-05-03T06:22:06.073Z","comments":true,"path":"2019/05/03/JavaScript-name_value及物件概念/","link":"","permalink":"http://yoursite.com/2019/05/03/JavaScript-name_value及物件概念/","excerpt":"","text":"name/value 組合在JavaScript中，要先知道「name/value」組合，在同個作用域中，name(名稱)不能被重複使用，同樣的name只能有一個，而每一個name(名稱)會對應到唯一的value(值)。 12//這是一個簡單的「name/value」組合address:'1 Main St.'; JavaScript物件JavaScript中的物件，是由「name/value」組合定義而成的。雖然說一個name會對應到唯一的value，可是這個value卻又可以是一到多個「name/value」組合而成的。 123456789//這個address物件的value是由多個「name/value」組合而成的address:&#123; street:'main', number:100, apartment:&#123; floor:3; number:301; &#125;&#125; 資料來源克服JS奇怪的部分","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JavaScript-語法解析器、執行環境、詞彙環境","slug":"JavaScript-語法解析器、執行環境、詞彙環境","date":"2019-05-03T06:14:58.100Z","updated":"2019-05-03T06:22:32.529Z","comments":true,"path":"2019/05/03/JavaScript-語法解析器、執行環境、詞彙環境/","link":"","permalink":"http://yoursite.com/2019/05/03/JavaScript-語法解析器、執行環境、詞彙環境/","excerpt":"","text":"語法解析器(syntax parser)包含直譯器、編譯器，會一個字一個字讀取並辨識程式碼是否有效，再將之轉換成為電腦可以解讀的指令 詞彙環境(lexical environment)程式碼在程式中實際的所在位置，對於某些程式語言非常重要，例：JavaScript。 因為當systax parser在解讀並轉換程式碼時， 會考量該變數、函式的lexical environment，而影響到它實際在記憶體中的位置或是跟其他變數、函式作用的關係。123function hello()&#123; var a = 'Hello';&#125; 上述程式碼為例，變數a的lexical environment就是hello()這個函式。 執行環境(execution context)一個程式碼中有多個lexical environment，因此execution context負責協助管理正在執行的程式，如同一個wrapper，包含我們撰寫的程式碼，以及syntax parser執行轉換的程式碼。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"Webpack-環境安裝與基礎運用","slug":"Webpack-安裝與基礎運用","date":"2019-04-23T12:03:41.032Z","updated":"2019-04-23T15:47:08.096Z","comments":true,"path":"2019/04/23/Webpack-安裝與基礎運用/","link":"","permalink":"http://yoursite.com/2019/04/23/Webpack-安裝與基礎運用/","excerpt":"","text":"開發環境Webpack是在Node.js環境下去執行的自動化工具，因此若要使用Webpack，首先電腦中必須安裝有Node.js開發環境 安裝Node.js，請參考文章：NVM-安裝及控管Node.js的版本 專案建立 先新增一個空的資料夾，並使用vsCode編譯器打開該資料夾 在資料夾中新增一個檔案，命名為webpack.config.js 正式安裝Webpack接著正式安裝，可以先到Webpack getting staretd頁面，參考官方說明，執行後續載入webpack的流程 首先建構初始化專案 1npm init -y 初始化建構執行完畢後，會看到專案中新增了一個package.json檔案，這個檔案中紀錄整個前端專案中用了哪些套件、指令。非常重要！不可刪除！ 接著安裝webpack1npm install webpack --save-dev Webpack4之後的版本都需要額外再安裝webpack-cli1npm install webpack-cli --save-dev 上述安裝完畢後，會發現專案中有幾處變更，如下圖 專案中多了一個node.modules的資料夾，裡面存放webpack在執行時，會依賴的其他第三方套件。 在可以在package.json檔案會發現多紀錄該專案使用多webpack、webpack-cli版本 webpack檔案建置 新增src資料夾，其中包含index.js檔案，在檔案中寫一些ES6程式碼 參考官網的範例程式碼，複製、貼上到檔案中 path:path主要負責路徑處理的轉換，這裡做的事情，就是從node.js的模組抓進webpack中使用 entry：高版本的Javascript output:輸出的版本，(檔案命名可以修正為index.bundle.js)123456789const path = require('path');module.exports = &#123; entry: './src/index.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'bundle.js' &#125;&#125;; 在package.json檔案的script部分加入 “build”: “webpack” 啟用Webpack 在vscode的terminal輸入指令，啟動webpack1npm run build 自動將原先高版本的JS檔案-index.js，轉變為在dist資料夾中的index.bundle.js內容，可以看到轉換後仍是ES6語法，因為還差掛載loader作轉換 使用Babel-loader轉換語法為了讓webpack識別原先的ES6程式碼內容，因此需要掛載Babel-loader 進到github開源頁面，依照提示安裝Babel-loader 將下方指令貼到vscode terminal中，”-D”會自動寫入package.json中 1npm install -D babel-loader @babel/core @babel/preset-env webpack 接著來編輯webpack.config.js，將程式碼複製貼上 1234567891011121314module: &#123; rules: [ &#123; test: /\\.m?js$/, exclude: /(node_modules|bower_components)/, use: &#123; loader: 'babel-loader', options: &#123; presets: ['@babel/preset-env'] &#125; &#125; &#125; ]&#125; 最後再執行一次webpack指令 1npm run build 可以看到右邊是重新編譯後的內容，將原先左邊高版本ES6的箭頭函示，編譯為JS基本的function語法 在HTML中引入最後，在HTML中引入js檔時，僅需引入一隻webpack bundle處理後的JS檔案 執行不同版本的webpack編譯在package.json中的scripts中新增不同的簡化指令內容(命名可以不受限，但最好是大家有共識的命名方式) watch：監看 start：開發版本 deploy：發行版本，會進行壓縮1234567\"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"build\": \"webpack\", \"watch\": \"webpack --mode development --watch\", \"start\": \"webpack --mode development\", \"deploy\": \"webpack --mode production\" &#125;, 參考來源YouTube影片：Webpack 前端自動化開發超入門","categories":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/categories/Webpack/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/tags/Webpack/"},{"name":"Babel","slug":"Babel","permalink":"http://yoursite.com/tags/Babel/"}]},{"title":"NVM-安裝及控管Node.js的版本","slug":"NVM-安裝及控管Node.js的版本","date":"2019-04-23T07:34:37.414Z","updated":"2019-04-23T16:08:09.344Z","comments":true,"path":"2019/04/23/NVM-安裝及控管Node.js的版本/","link":"","permalink":"http://yoursite.com/2019/04/23/NVM-安裝及控管Node.js的版本/","excerpt":"","text":"什麼是NVM?NVM(Node Version Manager) 是Node.js的版本管理控制工具 什麼情況會需要/建議使用NVM?當電腦要配置Node.js環境時，有兩種安裝方法： 方法一：直接從Node.js官網下載並安裝到電腦 方法二：透過NVM，下載並切換各個版本的Node.js 通常在團隊中開發大型專案，有可能會接手他人的專案程式碼，若同事的Node.js版本較舊，與自己電腦中的本不同，就必須要安裝並切換不同版本來開發。 因此一般都會使用方法二，透過NVM，即可在同一台電腦上，快速下載、切換Node.js的版本。 安裝NVM(for Mac)參考github開源的操作說明 首先，在terminal中執行下方指令：1curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bash 接著，如圖中藍色區塊中的說明「先將terminal關閉，再次執行下方的指令」：12export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm 輸入下方指令，確認是否安裝完畢1nvm --version 若成功秀出如下圖nvm版本，代表安裝成功 安裝Node.js使用指令秀出目前所有可以使用的版本1nvm ls-remote 參考並選擇要下載的Node.js版本 使用下方指令安裝版本(這裡選擇以LTS v10.15.3最新的穩定版本作為示範)1nvm install v10.15.3 執行安裝完畢查看目前電腦本機端中載有的版本1nvm list 切換不同版本(以10.15.3版本作為示範)1nvm use 10.15.3","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"},{"name":"NVM","slug":"NVM","permalink":"http://yoursite.com/tags/NVM/"}]},{"title":"Webpack-前端建置工具的發展背景及入門介紹","slug":"Webpack-基本入門介紹","date":"2019-04-23T07:34:28.561Z","updated":"2019-04-23T16:11:59.731Z","comments":true,"path":"2019/04/23/Webpack-基本入門介紹/","link":"","permalink":"http://yoursite.com/2019/04/23/Webpack-基本入門介紹/","excerpt":"","text":"Webpack是當下流行的「前端建置工具」之一。 首先了解建置工具建置工具出現的來龍去脈？過去：早期前端工程師寫網頁，僅透過前端三大元素「JavaScript、CSS、HTML」開發web應用。 現今：近年前端發展出許多新思維，出現了「模組化」的概念、「新框架」的出現、「新語言」的誕生，讓傳統的作法不再流行，各種可以加強開發效率的新工具出現。 模組化：模組化是將一個複雜的系統，分解為多個模組以方便程式開發。例：ES6模組化是國際標準組織ECMA提出的JavaScript模組化標準，他在語言層面上實現模組化，成為瀏覽器和伺服器通用的模組化解決方案。 新框架：在web應用變的龐大時，直接操作DOM會使程式變得複雜難以維護，因此出現React、Vue、Augular前端框架。 新語言：ES6、TypeScript、Flow、SCSS… 然而，前端技術發展之快，卻有一個共同點：這些工具的原始碼無法直接執行，必須透過「轉換」才可以正常執行，因此，「建置工具」就誕生了。 建置工具實際做了什麼？「建置」就是將原始程式碼，轉換成可以執行的JavaScript、CSS、HTML。 程式轉換：將TypeScript編譯為JavaScript，將SCSS編譯為CSS。 檔案最佳化：壓縮JavaScript、CSS、HTML程式，壓縮合併圖片。 程式分割：分析首頁不需要執行的部分程式，讓其非同步載入。 模組合併：採用模組化建置的專案中的有多個模組、檔案，透過建置功能，將模組合併為一個檔案。 自動更新：監聽本機端程式碼的變動，自動重新建置、更新瀏覽器。 程式驗證：在程式被傳送到倉庫前，需要驗證程式是否符合標準，以及單元測試是否通過。 自動發布：更新程式後，自動建置出現上發布程式，並傳輸給發布系統。 「建置」的目的最主要就是工程化、自動化。 常見的「建置工具」按誕生的時間排序 Npm Script：Node.js附帶的套件管理員 Grunt：自動化執行依賴的工作 Gulp：以串流為基礎的自動化建置工 Fis3：整合各種Web開發需要的建置功能 Webpack：包裝模組化JavaScript的工具 Rollup：專注於ES6的模組包裝工具 時空背景： 在Npm Script和Grunt時代，Web開發要做的事情變多、流程變複雜，自動化的思維興起，用於簡化流程。 在Gulp時代，新語言出現，流式處理思想出現是為了簡化檔案轉換的流程。 在Webpack的時代，由於單頁應用的流行，網頁的功能和實現程式變得複雜、龐大，因此Web開發相模組化改進。Webpack究竟是什麼?專注於建構模組化的專案在Webpack裡的所有檔案皆被視為模組，透過Loader轉換檔案，透過Plugin植入鉤子，最後輸出為一個由「多個模組合成的檔案」。所以一個專案中的所有檔案，包含JavaScript、CSS、SCSS、圖片、範本，在經過Webpack的處理，最後會輸出為瀏覽器可以使用的靜態資源。 使用方法如下：12345678module.expert=&#123; //所有模組的入口，Webpack從入口開始遞迴解析出所有依賴的模組 entry: &apos;./app/js&apos;, output:&#123; //將入口所依賴的所有模組包裝成一個檔案bundle.js輸出 filename: &apos;bundle.js&apos; &#125;&#125; 參考資料來源 JS高手昇華之路Webpack是唯一的路徑-吳浩麟 著","categories":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/categories/Webpack/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/tags/Webpack/"},{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"Vue-(十)表單綁定","slug":"Vue-(十)表單綁定","date":"2019-04-19T07:52:31.905Z","updated":"2019-04-23T16:10:59.273Z","comments":true,"path":"2019/04/19/Vue-(十)表單綁定/","link":"","permalink":"http://yoursite.com/2019/04/19/Vue-(十)表單綁定/","excerpt":"","text":"10-1.文字輸入：text input與textarea (影片)單行文字綁定，用input 大括號雙向綁定1234&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;msg&quot;&gt;&lt;/input&gt; &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;&lt;/div&gt; 123456new Vue(&#123; el:\"#app\", data:&#123; msg:'', &#125;,&#125;) input事件偵聽該元素的value用動態綁定，當input事件發生時，執行change函式1234&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; :value=&quot;msg&quot; @input=&quot;change&quot;&gt;&lt;/input&gt; &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;&lt;/div&gt; event.target找到事件發生的元素，其value則是user剛剛輸入的資料1234567891011new Vue(&#123; el:\"#app\", data:&#123; msg:'', &#125;, methods:&#123; change(event)&#123; this.msg = event.target.value; &#125; &#125;&#125;) 多行文字綁定，用textarea1234&lt;div id=&quot;app&quot;&gt; &lt;textarea v-model=&quot;msg&quot;&gt;&lt;/textarea&gt; &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;&lt;/div&gt; 但是換行字元’\\n’無法被反映到h1標籤中，因此可以改用pre標籤(preserve)1234&lt;div id=&quot;app&quot;&gt; &lt;textarea v-model=&quot;msg&quot;&gt;&lt;/textarea&gt; &lt;pre&gt;&#123;&#123;msg&#125;&#125;&lt;/pre&gt;&lt;/div&gt; 或是在css中定義1234&lt;div id=&quot;app&quot;&gt; &lt;textarea v-model=&quot;msg&quot;&gt;&lt;/textarea&gt; &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;&lt;/div&gt; 123h1&#123; white-space: pre; &#125; 10-2.打勾按鈕：checkbox (影片)綁定單個屬性boolean值1234567&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;status&quot;&gt;Agree&lt;/input&gt; &lt;br/&gt; &lt;h3&gt;&#123;&#123;status&#125;&#125;&lt;/h3&gt; &lt;br/&gt; &lt;button @click=&quot;submit&quot;&gt;Submit&lt;/button&gt;&lt;/div&gt; 123456789101112131415new Vue(&#123; el:\"#app\", data:&#123; status:false, &#125;, methods:&#123; submit()&#123; if(this.status)&#123; alert(\"Success!\"); &#125;else&#123; alert(\"Please agree first!\"); &#125; &#125; &#125;&#125;) 綁定至array中1234567891011&lt;div id=&quot;app&quot;&gt; &lt;h2&gt;請選擇可以送達的時間：&lt;/h2&gt; &lt;input id=&quot;optA&quot; type=&quot;checkbox&quot; v-model=&quot;options&quot; value=&quot;Morning&quot;/&gt; &lt;label for=&quot;optA&quot;&gt;Morning&lt;/label&gt; &lt;input id=&quot;optB&quot; type=&quot;checkbox&quot; v-model=&quot;options&quot; value=&quot;Afternoon&quot;/&gt; &lt;label for=&quot;optB&quot;&gt;Afternoon&lt;/label&gt; &lt;input id=&quot;optC&quot; type=&quot;checkbox&quot; v-model=&quot;options&quot; value=&quot;Evening&quot;/&gt; &lt;label for=&quot;optC&quot;&gt;Evening&lt;/label&gt; &lt;br/&gt; &lt;h3&gt;&#123;&#123;options&#125;&#125;&lt;/h3&gt;&lt;/div&gt; 123456new Vue(&#123; el:\"#app\", data:&#123; options:[], &#125;,&#125;) 10-3.圓點單選按鈕：radio (影片)123456789&lt;div id=&quot;app&quot;&gt; &lt;input id=&quot;female&quot; type=&quot;radio&quot; v-model=&quot;gender&quot; value=&quot;f&quot;/&gt; &lt;label for=&quot;female&quot;&gt;Female&lt;/label&gt; &lt;input id=&quot;male&quot; type=&quot;radio&quot; v-model=&quot;gender&quot; value=&quot;m&quot;/&gt; &lt;label for=&quot;male&quot;&gt;Male&lt;/label&gt; &lt;input id=&quot;other&quot; type=&quot;radio&quot; v-model=&quot;gender&quot; value=&quot;o&quot;/&gt; &lt;label for=&quot;other&quot;&gt;Other&lt;/label&gt; &lt;h2/&gt;&#123;&#123;gender&#125;&#125;&lt;/h2&gt;&lt;/div&gt; 123456new Vue(&#123; el:\"#app\", data:&#123; gender:'', &#125;,&#125;) 10-4.下拉選單：select與option (影片)綁定單一個屬性若沒有定義option中的value，會自動將option標籤中的內容當作value123456789&lt;div id=&quot;app&quot;&gt; &lt;select v-model=&quot;year&quot;&gt; &lt;option disable value=&quot;&quot;&gt;Select Year&lt;/option&gt; &lt;option value=&quot;17&quot;&gt;2017&lt;/option&gt; &lt;option&gt;2018&lt;/option&gt; &lt;option&gt;2019&lt;/option&gt; &lt;/select&gt; &lt;h2&gt;&#123;&#123;year&#125;&#125;&lt;/h2&gt;&lt;/div&gt; 123456new Vue(&#123; el:\"#app\", data:&#123; year:'', &#125;&#125;) 綁定至array中，使用multiple123456789&lt;div id=&quot;app&quot;&gt; &lt;select v-model=&quot;years&quot; multiple&gt; &lt;option disable value=&quot;&quot;&gt;Select Year&lt;/option&gt; &lt;option value=&quot;17&quot;&gt;2017&lt;/option&gt; &lt;option&gt;2018&lt;/option&gt; &lt;option&gt;2019&lt;/option&gt; &lt;/select&gt; &lt;h2&gt;&#123;&#123;years&#125;&#125;&lt;/h2&gt;&lt;/div&gt; 123456new Vue(&#123; el:\"#app\", data:&#123; years:[], &#125;&#125;) 使用v-for綁定option1234567&lt;div id=&quot;app&quot;&gt; &lt;select v-model=&quot;selectedYear&quot;&gt; &lt;option disable value=&quot;&quot;&gt;select year&lt;/option&gt; &lt;option v-for=&quot;item in years&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/option&gt; &lt;/select&gt; &lt;h2&gt;&#123;&#123;selectedYear&#125;&#125;&lt;/h2&gt;&lt;/div&gt; 1234567new Vue(&#123; el:\"#app\", data:&#123; years:[2017,2018,2019], selectedYear:'', &#125;&#125;)","categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://yoursite.com/categories/Vue-js/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://yoursite.com/tags/Vue-js/"},{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Vue-(九)事件處理","slug":"Vue-(九)事件處理","date":"2019-04-19T07:49:44.233Z","updated":"2019-04-23T16:10:34.947Z","comments":true,"path":"2019/04/19/Vue-(九)事件處理/","link":"","permalink":"http://yoursite.com/2019/04/19/Vue-(九)事件處理/","excerpt":"","text":"9-1.處理事件的兩種方式 (影片)在methods中定義函式方法當執行內容較多時，建議定義為函式方法1234&lt;div id=&apos;app&apos;&gt; &lt;h1&gt;&#123;&#123;count&#125;&#125;&lt;/h1&gt; &lt;button @click=&quot;add&quot;&gt;Add&lt;/button&gt;&lt;/div&gt; 1234567891011new Vue(&#123; el:\"#app\", data:&#123; count:0, &#125;, methods:&#123; add()&#123; this.count++; &#125; &#125;&#125;) 直接改變data中的變數當執行內容簡短時，可以直接改變屬性1234&lt;div id=&apos;app&apos;&gt; &lt;h1&gt;&#123;&#123;count&#125;&#125;&lt;/h1&gt; &lt;button @click=&quot;count++&quot;&gt;Add&lt;/button&gt;&lt;/div&gt; 123456new Vue(&#123; el:\"#app\", data:&#123; count:0, &#125;,&#125;) 9-2.偵聽滑鼠事件 (影片)v-on綁定事件v-on:click=&quot;&quot;簡寫為@:click=&quot;&quot; 其他滑鼠事件 mouseover：滑鼠經過 mouseout：滑鼠移出 mousedown:滑鼠點下 mouseup:滑鼠點下後‘放開’ mousemove：滑鼠在其上方移動時 9-3.偵聽圖片的load事件 (影片)偵聽圖片loading前後，回傳不同的class樣式12345678&lt;div id='app'&gt; &lt;h2 v-if=\"loading\"&gt;loading&lt;/h2&gt; &lt;h2 v-else&gt;complete&lt;/h2&gt; &lt;image :class='imgClass' @load=\"loading=false\" src=\"https://loremflickr.com/g/320/240/paris\"&gt;&lt;/image&gt;&lt;/div&gt; 12345678.image&#123; transition: all 1s; &#125;.image.hide&#123; opacity:0; transform: scale(3) rotate(180deg);&#125; 123456789101112131415new Vue(&#123; el:\"#app\", data:&#123; loading:true, &#125;, computed:&#123; imgClass()&#123; if(this.loading)&#123; return 'image hide'; &#125;else&#123; return 'image' &#125; &#125; &#125;&#125;) 示範練習 (codepen) 9-4.偵聽按鍵事件 (影片)鍵盤事件 keydown：按鍵被‘按下’時 keyup：按鍵被按下後‘彈起’時修飾符 定義按鍵 v-on:keydown.enter(當「enter」按鍵被按下時)修飾符 防止按鍵內容被輸入 v-on:keydown.a.prevent(當「a」按鍵被按下時，但a的內容不會被放入input中)123456&lt;div id=&quot;app&quot;&gt; &lt;input v-model=&quot;input&quot; v-on:keyup.enter=&quot;add&quot;/&gt; &lt;ul&gt; &lt;li v-for=&quot;item in todo&quot;&gt;&#123;&#123;item&#125;&#125; &lt;/ul&gt;&lt;/div&gt; 12345678910111213new Vue(&#123; el:\"#app\", data:&#123; input:'', todo:[], &#125;, methods:&#123; add()&#123; this.todo.push(this.input); this.input = ''; &#125; &#125;&#125;) 示範練習 (codepen) 9-5.便利的修飾符語法 (影片).prevent：不執行預設效果1234567&lt;div id=&quot;app&quot;&gt; &lt;a href=&quot;https://www.google.com&quot; target=&quot;_blank&quot; @click=&quot;linkClick&quot;&gt; google&lt;/a&gt;&lt;/div&gt; 123456789new Vue(&#123; el:\"#app\", methods:&#123; linkClick(event)&#123; event.preventDefault(); alert(\"Don't do it!\"); &#125; &#125;&#125;) 改用修飾符.prevent的便利寫法1234567&lt;div id=&quot;app&quot;&gt; &lt;a href=&quot;https://www.google.com&quot; target=&quot;_blank&quot; @click.prevent=&quot;linkClick&quot;&gt; google&lt;/a&gt;&lt;/div&gt; 12345678new Vue(&#123; el:\"#app\", methods:&#123; linkClick()&#123; alert(\"Don't do it!\"); &#125; &#125;&#125;) .stop：不讓event傳到外層123456789&lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;box&quot; @click=&quot;clickA&quot;&gt; &lt;div class=&quot;box&quot; @click=&quot;clickB&quot;&gt; &lt;div class=&quot;box&quot; @click=&quot;clickC&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;&lt;/div&gt; 1234567.box&#123; border:2px solid blue; min-width:30px; min-height:30px; padding:10px; margin:10px;&#125; 1234567891011121314151617181920new Vue(&#123; el:\"#app\", data:&#123; msg:'null', &#125;, methods:&#123; clickA(event)&#123; event.stopPropagation(); this.msg = 'A'; &#125;, clickB(event)&#123; event.stopPropagation(); this.msg = 'B'; &#125;, clickC(event)&#123; event.stopPropagation(); this.msg = 'C'; &#125; &#125;&#125;) 改用修飾符.stop的便利寫法123456789&lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;box&quot; @click.stop=&quot;msg=&apos;A&apos;&quot;&gt; &lt;div class=&quot;box&quot; @click.stop=&quot;msg=&apos;B&apos;&quot;&gt; &lt;div class=&quot;box&quot; @click.stop=&quot;msg=&apos;C&apos;&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;&lt;/div&gt; .self：只執行自己發出的event123456789&lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;box&quot; @click.self=&quot;msg=&apos;A&apos;&quot;&gt; &lt;div class=&quot;box&quot; @click.self=&quot;msg=&apos;B&apos;&quot;&gt; &lt;div class=&quot;box&quot; @click.self=&quot;msg=&apos;C&apos;&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;&lt;/div&gt; .once：只執行一次1234&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;&#123;&#123;num&#125;&#125;&lt;/h1&gt; &lt;button @click.once=&quot;num+=1&quot;&gt;+Add &lt;/button&gt;&lt;/div&gt; 123456new Vue(&#123; el:\"#app\", data:&#123; num:0, &#125;,&#125;) 更多修飾符，參考(Vue文件)","categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://yoursite.com/categories/Vue-js/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://yoursite.com/tags/Vue-js/"},{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Vue-(八)列表渲染","slug":"Vue-(八)列表渲染","date":"2019-04-19T07:46:29.651Z","updated":"2019-04-23T16:10:48.387Z","comments":true,"path":"2019/04/19/Vue-(八)列表渲染/","link":"","permalink":"http://yoursite.com/2019/04/19/Vue-(八)列表渲染/","excerpt":"","text":"8-1.用v-for把陣列轉換為一組元素 (影片)v-for項目基本語法12345&lt;div id=&quot;app&quot;&gt; &lt;ol&gt; &lt;li v-for=&quot;item in colors&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; 123456new Vue(&#123; el:'#app', data:&#123; colors:['學習javascrip','學會vue框架','做作品','準備面試'] &#125;,&#125;) 補充：HTML ul 與 ol 差異== 將item拿出來當作屬性1234567&lt;div id=&quot;app&quot;&gt; &lt;ol&gt; &lt;li v-for=&quot;item in todo&quot; v-bind:class=&apos;item.key&apos;&gt; &#123;&#123;item.date&#125;&#125; &#123;&#123;item.content&#125;&#125; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; 123456.first&#123; color:red;&#125;.second&#123; color:green;&#125; 123456789new Vue(&#123; el:'#app', data:&#123; todo:[&#123;key:'first',date:'3/9',content:'學習javascrip'&#125;, &#123;key:'second',date:'3/10',content:'學會vue框架'&#125;, &#123;key:'second',date:'3/11',content:'做作品'&#125;, &#123;key:'second',date:'3/12',content:'準備面試'&#125;] &#125;,&#125;) 用index綁定value12345&lt;div id=&quot;app&quot;&gt; &lt;select &gt; &lt;option v-for=&quot;(item,index) in monthes&quot; :value=&quot;index&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/option&gt; &lt;/select&gt;&lt;/div&gt; 123456new Vue(&#123; el:'#app', data:&#123; monthes:['1月','2月','3月','4月','5月','6月','7月','8月','9月','10月','11月','12月'], &#125;,&#125;) 8-2.用v-for把物件轉換為一組元素 (影片)注意v-forrender出來的順序不一定會跟物件中的順序一樣，所以如果是需要遵從順序的情況，盡可能使用陣列123&lt;div id=&quot;app&quot;&gt; &lt;span v-for=&quot;(value,key) in me&quot;&gt;&#123;&#123;key&#125;&#125;-&#123;&#123;value&#125;&#125;&lt;br/&gt;&lt;/span&gt;&lt;/div&gt; 12345678910new Vue(&#123; el:'#app', data:&#123; me:&#123; name:'Leah', age:26, gender:\"Female\", &#125; &#125;&#125;) 8-3.修改陣列或物件的注意事項 (影片)陣列新增、刪減、排列基本語法 push(ew item)從陣列後面新增 pop()從陣列後面刪減 unshift(new item)從陣列前面新增 shift()從陣列前面刪減 123456789&lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in steps&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;button @click=&quot;push&quot;&gt;Push&lt;/button&gt; &lt;button @click=&quot;pop&quot;&gt;Pop&lt;/button&gt; &lt;button @click=&quot;shift&quot;&gt;Shift&lt;/button&gt; &lt;button @click=&quot;unshift&quot;&gt;Unshift&lt;/button&gt;&lt;/div&gt; 123456789101112131415161718192021new Vue(&#123; el:'#app', data:&#123; steps:[1,2,3,4,5], &#125;, methods:&#123; push()&#123; this.steps.push(this.steps.length+1); &#125;, pop()&#123; this.steps.pop(); &#125;, shift()&#123; this.steps.shift(); &#125;, unshift()&#123; this.steps.unshift(0); &#125;, &#125;&#125;) splice(index,length)從陣列中切割第一個參數index代表陣列中要開始被切割的元素索引，第二個length參數代表要被切割掉的長度(元素數量) 123splice()&#123;//切除陣列中倒數第二個元素 this.steps.splice(this.steps.length-2,1);&#125; splice(index,length,...)從陣列中切除，並添加新的元素 123splice()&#123;//從steps[1]開始切除0個，並從該位置添加元素'new1','new2','new3' this.steps.splice(1,0,'new1','new2','new3'); &#125; slice(from,to)從陣列中取出部分元素，並重組出一個新的陣列==slice()不會改變原先的陣列，會產出一個新的陣列== 123456789slice()&#123; this.steps = this.steps.slice(1,4); &#125;,``` * `sort()`從陣列中的元素從小到大排列```javascript=sort()&#123; this.steps.sort(); &#125; reverse()從陣列中的元素反過來從後面到前面排列 123reverse()&#123; this.steps.reverse(); &#125; filter()從陣列中的過濾符合條件的元素，並重組出一個陣列 1234567//將steps中的每個元素一個個檢查//若符合(item%2===0)，則會被放入新陣列中//最後將新的陣列作為filter()的回傳值//並重新assign給this.stepsfilter()&#123; this.steps = this.steps.filter(item =&gt; item%2 === 0); &#125; 注意！！！！ this.steps[0]=10, 不會修改陣列元素的值，應用splice()達到此目的 this.steps.length=0, 沒辦法清空陣列中的元素，應用splice()，或是slice()達到此目的。 this.obj.z=30, 沒有辦法達到新增物件屬性的功能1234&lt;div id=&quot;app&quot;&gt; &lt;h4 v-for=&quot;(value,key) in obj&quot;&gt;&#123;&#123;key&#125;&#125;=&#123;&#123;value&#125;&#125;&lt;/h4&gt; &lt;button @click=&quot;addZ&quot;&gt;Add Z&lt;/button&gt;&lt;/div&gt; this代表Vue實例，Vue實例中有個方法$set()，第一個參數是設定的目標物件，第二個參數代表新增的key，第三個參數代表新增的value1234addZ()&#123; // this.obj.z = 300;//無效 this.$set(this.obj,'z',300); &#125; 或是，這樣寫123addZ()&#123; Vue.set(this.obj,'z',300); &#125; 注意：this.$set()與Vue.set()用於物件原先沒有該屬性的情況;若情況是要修改物件本來就存在的屬性值，直接改寫就可以 8-4.列表的過濾與排序 (影片)12345678&lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in nums&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;button @click=&quot;initiate&quot;&gt;Initiate&lt;/button&gt; &lt;button @click=&quot;filter&quot;&gt;Filter&lt;/button&gt; &lt;button @click=&quot;sort&quot;&gt;Sort&lt;/button&gt;&lt;/div&gt; sort()會改變原先的this.num陣列;又因為data中nums=orgNums，所以最外面的orgNums也被改變了12345678910111213141516171819const orgNums = [5,6,1,2,4,3,8,7,9];new Vue(&#123; el:'#app', data:&#123; nums:orgNums, &#125;, methods:&#123; initiate()&#123; this.nums = orgNums; &#125;, filter()&#123; this.nums = this.nums.filter(item =&gt;item%2===0); &#125;, sort()&#123; this.nums.sort(); &#125;, &#125;&#125;) 因此，若要避免原先的陣列被改動而喚不回初始值，可以利用slice()語法，先複製一個新的陣列12345678910111213141516171819const orgNums = [5,6,1,2,4,3,8,7,9];new Vue(&#123; el:'#app', data:&#123; nums:orgNums, &#125;, methods:&#123; initiate()&#123; this.nums = orgNums; &#125;, filter()&#123; this.nums = this.nums.filter(item =&gt;item%2===0); &#125;, sort()&#123; this.nums = this.nums.slice().sort(); &#125;, &#125;&#125;) 8-5.用v-for渲染templete [(影片)](https://hiskio.com/courses/145/lectures/5382) 每次迴圈需要被render出來的不只一個元素，而是包含多個標籤元素，可以使用&lt;templete&gt;&lt;/templete&gt;，並將v-for指令放在templete標籤中。123456&lt;div id=&quot;app&quot;&gt; &lt;template v-for=&apos;item in header&apos;&gt; &lt;h1&gt;&#123;&#123;item&#125;&#125;&lt;/h1&gt; &lt;hr/&gt; &lt;/template&gt;&lt;/div&gt; 123456789new Vue(&#123; el:'#app', data:&#123; header:['Home','About','Product','Contact'] &#125;, methods:&#123; &#125;&#125;) 8-6.實作：從JSON資料渲染課程列表 [(影片)](https://hiskio.com/courses/145/lectures/5383) 在mounted()階段引入JSON格式資料 用原生的fetch() 12345mounted()&#123; fetch('./data.json') .then(res =&gt; res.json()) .then(lessons =&gt; this.lessons = lessons);&#125;, 引入jquery寫法 12$.getJSON('./data.json') .then(lessons =&gt; this.lessons = lessons); axios寫法 1axios.get('./data.json').then(res =&gt;this.lessons = res.data); 結果呈現 github完整程式碼 補充vscode 擴充套件 - Live Server：可以快速地建造一個本地端的server 8-7.片尾彩蛋：認識JSON格式 [(影片)](https://hiskio.com/courses/145/lectures/5470) 「JSON格式」本身是一個「字串」JSON格式的限制 JSON格式的key一定要有雙引號”” 最後一個value不能有,結尾 value不能是函式（不過可以把它存成字串，之後再轉為函式執行）格式轉換 javascript物件轉為JSON格式：JSON.stringify(); 12345678const data = &#123; name:\"point\", x:100, y:200&#125;const dataJSON = JSON.stringify(data);console.log(dataJSON); 印出結果，用“”代表是一個字串(JSON格式字串) JSON格式轉為javascript物件：JSON.parse(); 12const dataObj = JSON.parse(dataJSON);console.log(dataObj); 印出結果，是一個物件 replacer:重建JSON資料將物件轉換為JSON格式時，只取其中部分的key值。作法：在stringify()的第二個參數放上key字串組成的陣列[‘x’,’y’];若放null，則代表曲全部的資料123456789console.clear();const data = &#123; name:\"point\", x:100, y:200&#125;const dataJSON = JSON.stringify(data,['x','y']);console.log(dataJSON); 印出結果，產出的JSON格式資料中，只有出’x’,’y’ 提高JSON格式易讀性為了易讀性，讓JSON格式排列整齊，每個key值前面補上空格作法：在stringify()的第三個參數空格數量12const dataJSON = JSON.stringify(data,null,2);console.log(dataJSON); 格式JSON搭配try,catch()因為不能保證每次能成功將JSON格式轉換為物件，為了避免城市卡住，通常會搭配try,catch(err)處理錯誤12345try&#123; const data = JSON.parse(dataJSON);&#125;catch(err)&#123; const data = &#123;&#125;;&#125;","categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://yoursite.com/categories/Vue-js/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://yoursite.com/tags/Vue-js/"},{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Vue-(七)條件判斷","slug":"Vue-(七)條件判斷","date":"2019-04-19T07:45:07.200Z","updated":"2019-04-23T16:10:18.276Z","comments":true,"path":"2019/04/19/Vue-(七)條件判斷/","link":"","permalink":"http://yoursite.com/2019/04/19/Vue-(七)條件判斷/","excerpt":"","text":"7-1.v-if (影片)補充:本身並非元素，只是用來包著許多元素的模板12345678&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;show&quot;/&gt;勾選秀出內容 &lt;templete v-if=&quot;show&quot;&gt; &lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt; &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;h3&gt;&#123;&#123;message&#125;&#125;&lt;/h3&gt; &lt;/templete&gt;&lt;/div&gt; 1234567new Vue(&#123; el:'#app', data:&#123; message:'跳樓大拍賣', show:false, &#125;,&#125;) 7-2.v-else (影片)v-else一定要依附在v-if之後，且是同一層的東西12345678910&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;show&quot;/&gt; &lt;span v-if=&apos;show&apos;&gt;隱藏內容&lt;/span&gt; &lt;span v-else&gt;秀出內容&lt;/span&gt; &lt;templete v-if=&quot;show&quot;&gt; &lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt; &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;h3&gt;&#123;&#123;message&#125;&#125;&lt;/h3&gt; &lt;/templete&gt;&lt;/div&gt; ==如果中間有其他東西，v-else會無效1234567891011&lt;div id=\"app\"&gt; &lt;input type=\"checkbox\" v-model=\"show\"/&gt; &lt;span v-if='show'&gt;隱藏內容&lt;/span&gt; &lt;br/&gt;//錯誤：不得再v-if/v-else插入其他東西，會出錯 &lt;span v-else&gt;秀出內容&lt;/span&gt; &lt;templete v-if=\"show\"&gt; &lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt; &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;h3&gt;&#123;&#123;message&#125;&#125;&lt;/h3&gt; &lt;/templete&gt;&lt;/div&gt; 7-3.v-else-if (影片)v-if若有成立，就不會render下面的v-else-if與v-else123456789&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;showRed&quot;/&gt;red &lt;input type=&quot;checkbox&quot; v-model=&quot;showGreen&quot;/&gt;green &lt;input type=&quot;checkbox&quot; v-model=&quot;showBlue&quot;/&gt;blue &lt;h1 v-if=&quot;showRed&quot;&gt;I&apos;m Red.&lt;/h1&gt; &lt;h1 v-else-if=&quot;showGreen&quot;&gt;I&apos;m Green.&lt;/h1&gt; &lt;h1 v-else-if=&quot;showBlue&quot;&gt;I&apos;m Blue.&lt;/h1&gt; &lt;h1 v-else&gt;Non&lt;/h1&gt;&lt;/div&gt; 12345678new Vue(&#123; el:'#app', data:&#123; showRed:false, showGreen:false, showBlue:false, &#125;,&#125;) 7-4.v-show (影片) v-if是讓程式判斷是否被render出來 v-show是用css控制是否在畫面中顯示(意即套用display: none)，所以該元素在原始碼中有被render出來，只是不在畫面顯示 可以搭配v-if使用，代表裡面的東西是否render出來;但是不能用v-show，因為本身並非一個元素，只是一個模板，無法被顯示處理","categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://yoursite.com/categories/Vue-js/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://yoursite.com/tags/Vue-js/"},{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Vue-(六)HTML元素的屬性綁定","slug":"Vue-(六)HTML元素的屬性綁定","date":"2019-04-19T07:43:32.669Z","updated":"2019-04-23T16:10:53.986Z","comments":true,"path":"2019/04/19/Vue-(六)HTML元素的屬性綁定/","link":"","permalink":"http://yoursite.com/2019/04/19/Vue-(六)HTML元素的屬性綁定/","excerpt":"","text":"6-1.綁定資料為一個元素的class (影片)以下寫法：會綁定css中命名為btnEnter的樣式1&lt;button class=\"btnEnter\"&gt;Enter&lt;/button&gt; 以下v-bind寫法：會綁定JS中的屬性btnEnter的回傳值(可以是字串、物件、陣列)1&lt;button v-bind:class=\"btnEnter\"&gt;Enter&lt;/button&gt; 完整案例示範-綁定回傳值：字串1234&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&apos;text&apos;/&gt; &lt;button v-bind:class=&apos;btnEnter&apos;&gt;Enter&lt;/button&gt;&lt;/div&gt; 12345678910111213#app&#123; text-align:center;&#125;.enter&#123; background-color:green; color:white; border:none; border-radius:8px; padding:9px;&#125;.enter.disable&#123; background-color:grey;&#125; 123456789101112131415new Vue(&#123; el:'#app', data:&#123; text:'', &#125;, computed:&#123; btnEnter()&#123; if(this.text.length === 0)&#123; return 'btnEnter disable'; &#125;else&#123; return 'btnEnter'; &#125; &#125;, &#125;&#125;) 改寫-綁定回傳值：物件 btnEnter:true —&gt;render出來的class會含有btnEnter disabled:true —&gt;render出來的class會含有disabled disabled:false —&gt;render出來的class不會含有disabled12345678910111213141516171819202122new Vue(&#123; el:'#app', data:&#123; text:'', &#125;, computed:&#123; btnEnter()&#123; console.log('111'); if(this.text.length === 0)&#123; return &#123; btnEnter:true, disabled:true, &#125; &#125;else&#123; return &#123; btnEnter:true, disabled:false, &#125; &#125; &#125;, &#125;&#125;) 簡化寫法，只有在條件式成立為true時，class才會含有disable這個屬性12345678computed:&#123; btnEnter()&#123; return &#123; btnEnter:true, disabled:this.text.length === 0, &#125; &#125; &#125; 改寫-綁定回傳值：陣列陣列中可以放入多個字串，代表含有這些css樣式1234567891011121314151617new Vue(&#123; el:'#app', data:&#123; text:'', btnEnterAble:['btnEnter'], btnEnterDisabled:['btnEnter','disabled'], &#125;, computed:&#123; btnEnter()&#123; if(this.text.length === 0)&#123; return this.btnEnterDisabled; &#125;else&#123; return this.btnEnterAble; &#125; &#125; &#125;&#125;) 6-2.綁定資料為一個元素的style (影片)以下寫法：在css定義樣式123&lt;div id=&apos;app&apos;&gt; &lt;h1&gt;Hello&lt;/h1&gt;&lt;/div&gt; 123.h1&#123; color:red;&#125; 以下寫法：直接在元素中定義style1&lt;h1 style=&apos;color:red&apos;&gt;Hello&lt;/h1&gt; 以下v-bind寫法：動態綁定在Vue實例中的屬性字串1&lt;h1 v-bind:style=&quot;h1Style&quot;&gt;Hello&lt;/h1&gt; 完整案例示範-綁定回傳值：字串123&lt;div id=&quot;app&quot; :style=&quot;textCenter&quot;&gt; &lt;h1 :style=&quot;h1Style&quot;&gt;Hello&lt;/h1&gt;&lt;/div&gt; 1234567new Vue(&#123; el:\"#app\", data:&#123; textCenter:'text-align:center', h1Style:\"color:red\", &#125;,&#125;) 改寫-綁定回傳值：物件12345678910new Vue(&#123; el:\"#app\", data:&#123; h1Style:&#123; color:'white', fontSize:'20px', backgroundColor:'gray' &#125;, &#125;,&#125;) 改寫-綁定回傳值：陣列陣列中放物件，會依序套用陣列中的物件所定義的樣式補充：樣式的定義中，key要用駝峰式命名，例：”font-size”要寫為”fontSize”123456789101112131415const commonStyle = &#123; fontSize:'20px',&#125;const whiteWord = &#123; color:'white',&#125;const grayBackground = &#123; backgroundColor:'gray'&#125;new Vue(&#123; el:\"#app\", data:&#123; h1Style:[commonStyle,whiteWord,grayBackground] &#125;,&#125;) 實作練習：1234&lt;div id=&quot;app&quot;&gt; &lt;h1 :style=&quot;h1Style&quot;&gt;Hello&lt;/h1&gt; &lt;button @click=&quot;shrink&quot;&gt;縮小&lt;/button&gt;&lt;/div&gt; 12345678910111213141516new Vue(&#123; el:\"#app\", data:&#123; h1Style:&#123; color:'green', fontSize:'30px', &#125; &#125;, methods:&#123; shrink()&#123; const size = parseInt(this.h1Style.fontSize.replace('px'),10); console.log(size); this.h1Style.fontSize = `$&#123;size-1&#125;px`; &#125; &#125;&#125;) 改寫為更精簡化12345678910111213141516171819new Vue(&#123; el:\"#app\", data:&#123; size: 40, &#125;, computed:&#123; h1Style()&#123; return &#123; color:'green', fontSize:`$&#123;this.size&#125;px`, &#125; &#125; &#125;, methods:&#123; shrink()&#123; this.size--; &#125; &#125;&#125;)","categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://yoursite.com/categories/Vue-js/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://yoursite.com/tags/Vue-js/"},{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Vue-(五)Vue實例","slug":"Vue-(五)Vue實例","date":"2019-04-19T07:38:46.934Z","updated":"2019-04-23T16:10:42.150Z","comments":true,"path":"2019/04/19/Vue-(五)Vue實例/","link":"","permalink":"http://yoursite.com/2019/04/19/Vue-(五)Vue實例/","excerpt":"","text":"5-1.創建Vue實例 (影片)「實例」為何？* 類別：廣泛的描述、藍圖 * 實例：具體的個體 1234567// 1.先描述Human類別Human;//Human是一種類別// 2.再創立個體，new是把類別產生一個實例的語法const me = new Human(); //me是一個實例const you = new Human(); //you是另外一個實例 創建Vue實例的語法123new Vue(&#123;&#125;); 也可以宣告一個變數，並將將new出來的實例，assign給該變數123const vm = new Vue(&#123;&#125;); 5-2.元素(el)、掛載($mount)、模板(template) (影片)掛載(mount)？掛載(mount)：將「vue實例」與「html元素」做連結 創建Vue實例之初，在el中用css選擇器，找到元素元素通常只有一個，所以通常都用id，而非class123&lt;div id=&quot;aaa&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt; //Hello&lt;div class=&quot;bbb&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt; //Hi&lt;div class=&quot;bbb&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt; //&#123;&#123;msg&#125;&#125; （一個vue實例只能掛載到一個元素上，所以這裡會出錯） 123456789101112const a = new Vue(&#123; el:'#aaa', data:&#123; msg:'Hello', &#125;&#125;);const b = new Vue(&#123; el:'.bbb', data:&#123; msg:'Hi', &#125;&#125;); 創建Vue實例之初，在el中用元素的參照，找到元素123&lt;div id=&quot;app&quot;&gt; &#123;&#123;message&#125;&#125;&lt;/div&gt; 123456new Vue(&#123; el:document.getElementById('app'), data:&#123; message:'Hello!', &#125;,&#125;) 創造Vue實例時先不掛載，之後當需要的時候再掛載到元素上宣告一個DOM元素，id命名為app123&lt;div id=&quot;app&quot;&gt; &#123;&#123;message&#125;&#125;&lt;/div&gt; 先創建Vue實例12345const vm = new Vue(&#123; data:&#123; message:'Hello!', &#125;,&#125;) 之後再掛載到元素上 方法1：（css選擇器寫法） 1vm.$mount('#app'); 方法2：（元素參照寫法） 1vm.$mount(document.getElementById('app')); 用template模板取代html元素？template裡面的字串內容被解析之後，會取代html元素中的內容，所以html元素可以是空的1&lt;div id=&quot;app&quot;&gt;&lt;/div&gt; 1234567const vm = new Vue(&#123; el:'#app', template:\"&lt;div&gt;&lt;h1&gt;&#123;&#123;message&#125;&#125;&#123;&#123;message&#125;&#125;&lt;/h1&gt;&lt;/div&gt;\", data:&#123; message:'Hello!', &#125;,&#125;) 5-3.狀態(data) (影片)Vue實例中同步宣告data1234567const vm = new Vue(&#123; el:'#app', data:&#123; x:1, y:2, &#125;,&#125;) 先宣告data，再assign到Vue實例中12345678const data = &#123; x:1, y:2,&#125;const vm = new Vue(&#123; el:'#app', data:data,&#125;) data改為shorthand語法12345678const data = &#123; x:1, y:2,&#125;const vm = new Vue(&#123; el:'#app', data,&#125;) 此時，vm.x等同於data.x，是同一個參照123456789101112const data = &#123; x:1, y:2,&#125;const vm = new Vue(&#123; el:'#app', data,&#125;)vm.x = 5;//此時，data.x = 5console.log(data.x === vm.x);//trueconsole.log(vm.$data === data);//true 5-4.方法(methods) (影片)Vue實例中宣告方法注意：methods裡面不能用箭頭函式，因為箭頭函式中的this等於global或window，會出錯1234&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;&#123;&#123;number&#125;&#125;&lt;/h1&gt; &lt;button v-on:click=&quot;add&quot;&gt;+Add &#123;&#123;count&#125;&#125;&lt;/button&gt;&lt;/div&gt; 12345678910111213const vm = new Vue(&#123; el:'#app', data:&#123; number:0, count:0, &#125;, methods:&#123; add()&#123; this.number += this.count; this.count += 1; &#125; &#125;&#125;) 呼叫methods中的方法注意：methods中的函式命名不得與data的屬性命名相同，會出錯1234&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;&#123;&#123;number&#125;&#125;&lt;/h1&gt; &lt;button v-on:click=&quot;add2&quot;&gt;+Add &#123;&#123;count&#125;&#125;&lt;/button&gt;&lt;/div&gt; 12345678910111213141516const vm = new Vue(&#123; el:'#app', data:&#123; number:0, count:0, &#125;, methods:&#123; add()&#123; this.number += this.count; this.count += 1; &#125;, add2()&#123; this.add(); &#125; &#125;&#125;) 5-5.計算屬性(computed) (影片)computed代表計算之後的屬性，用物件的形式宣告 computed中的函式，一定要return一個值==注意：== computed裡面不能用箭頭函式，因為箭頭函式中的this等於global或window，會出錯1234567&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;number&quot; v-model=&apos;a&apos;&gt; + &lt;input type=&quot;number&quot; v-model=&apos;b&apos;&gt; = &lt;span&gt;&#123;&#123;c&#125;&#125;&lt;/span&gt;&lt;/div&gt; 在computed中有一個函式c，其中有使用到a和b，會自動偵聽a與b，當a或b有變動時，會自動重新計算c的返回值123456789101112const vm = new Vue(&#123; el:'#app', data:&#123; a:0, b:0, &#125;, computed:&#123; c()&#123; return parseInt(this.a,10)+parseInt(this.b,10); &#125;, &#125;&#125;) computed中也可以宣告物件，物件中有getter和setter123456789&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;number&quot; v-model=&apos;a&apos;&gt; + &lt;input type=&quot;number&quot; v-model=&apos;b&apos;&gt; = &lt;input type=&quot;number&quot; v-model=&apos;c&apos;&gt; &lt;br/&gt; &#123;&#123;a&#125;&#125; + &#123;&#123;b&#125;&#125; = &#123;&#123;c&#125;&#125;&lt;/div&gt; 1234567891011121314151617const vm = new Vue(&#123; el:'#app', data:&#123; a:0, b:0, &#125;, computed:&#123; c:&#123; get()&#123; return parseInt(this.a,10) + parseInt(this.b,10); &#125;, set(value)&#123; this.b = parseInt(value,10) - parseInt(this.a,10) &#125; &#125;, &#125;&#125;) 5-6.偵聽器(watch) (影片)watch 可以偵聽 data 與 computed 的屬性或方法變動當被偵聽的“data中的屬性”有變動，就會觸發在watch中同名的函式123&lt;div id=&quot;app&quot;&gt; &lt;input/ type=&quot;number&quot; v-model=&quot;value&quot;&gt;&lt;/div&gt; 1234567891011const vm = new Vue(&#123; el:'#app', data:&#123; value:0, &#125;, watch:&#123; value(val, oldVal)&#123; console.log(`$&#123;oldVal&#125;----&gt;$&#123;val&#125;`); &#125; &#125;&#125;) 當被偵聽的“computed中的屬性或方法”有變動，就會觸發在watch中同名的函式1234567891011121314151617const vm = new Vue(&#123; el:'#app', data:&#123; a:0, b:0, &#125;, computed:&#123; c()&#123; return parseInt(this.a, 10) + parseInt(this.b, 10); &#125; &#125;, watch:&#123; c(val, oldVal)&#123; console.log(`$&#123;oldVal&#125;----&gt;$&#123;val&#125;`); &#125; &#125;&#125;) 進階用法：將watch中的屬性宣告為物件watch中的value被改寫為一個物件12345678910111213const vm = new Vue(&#123; el:'#app', data:&#123; value:0, &#125;, watch:&#123; value:&#123; handler(val,oldVal)&#123; console.log(`$&#123;oldVal&#125;----&gt;$&#123;val&#125;`); &#125;, &#125;, &#125;&#125;) 在物件中增加immediate屬性(true or false)true:在Vue實例被創建時，就會跑這個watch 1234567891011121314const vm = new Vue(&#123; el:'#app', data:&#123; value:0, &#125;, watch:&#123; value:&#123; handler(val,oldVal)&#123; console.log(`$&#123;oldVal&#125;----&gt;$&#123;val&#125;`); &#125;, immediate:true,//所以會馬上console出\"undefined----&gt;0\" &#125;, &#125;&#125;) 在物件中增加deep屬性(true or false)true:當被偵聽的屬性為物件或陣列時，會去偵聽該物件或陣列裡面一層的值是否有被改變 123&lt;div id=&quot;app&quot;&gt; &lt;input/ type=&quot;number&quot; v-model=&quot;value.a&quot;&gt;&lt;/div&gt; 被偵聽的value其實沒有改變，被改變的是value物件中的a，因此要新增deep屬性去偵聽value物件內層的a值12345678910111213141516const vm = new Vue(&#123; el:'#app', data:&#123; value:&#123; a:0, &#125; &#125;, watch:&#123; value:&#123; handler(val,oldVal)&#123; console.log(`$&#123;oldVal.a&#125;----&gt;$&#123;val.a&#125;`);//\"1----&gt;1\" &#125;, deep:true, &#125;, &#125;&#125;) 5-7.生命週期 (影片)Vue實例從創建、更新、消滅的過程中，中間過程會去執行生命週期函式(lifecycle hooks function) 主要四個步驟：1.建立—&gt; 2.掛載—&gt; 3.更新—&gt; 4.消滅 建立（唯二兩個在server side rendering） beforeCreate()：Vue建立之前 created()：Vue建立之後，data與computed中的屬性放到Vue實例中，此時用this.拿得到data與computed中的屬性 掛載 beforeMount()：掛載之前 mounted()：掛載之後，經常用ajax取得資料 並且把資料塞進 data123456789101112const vm = new Vue(&#123; el:'#app', data:&#123; list:[], &#125;, mounted()&#123; $.getJSON('...',(data)=&gt;&#123; this.list = data; &#125;) &#125; &#125;&#125;) 更新 beforeUpdate()：更新之前 updated()：更新之後 消滅 beforeDestroy():消滅之前 destroyed()：消滅之後 5-8.實作「密碼強度檢查」 (影片) codepen實作結果1234567&lt;div id=&quot;app&quot;&gt; &lt;input id=&quot;inputBox&quot; v-bind:type=&quot;showType&quot; v-model=&quot;password&quot; placeholder=&quot;請輸入密碼&quot;/&gt; &lt;button id=&quot;statusBtn&quot; v-on:click=&quot;changeStatus&quot;&gt;&#123;&#123;statusBtn&#125;&#125;&lt;/button&gt; &lt;button&gt;確定送出&lt;/button&gt; &lt;br/&gt; &lt;span&gt;密碼強度:&#123;&#123;strength&#125;&#125;&lt;/span&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738const vm = new Vue(&#123; el:'#app', data:&#123; password:'', show:false, statusBtn:'顯示密碼' &#125;, methods:&#123; changeStatus()&#123; this.show = !this.show; &#125; &#125;, computed:&#123; showType()&#123; if(this.show) &#123; this.statusBtn = '隱藏密碼'; return 'text'; &#125; else&#123; this.statusBtn = '顯示密碼'; return 'password'; &#125; &#125;, strength()&#123; let score = this.password.length; if(/[A-Z]/.test(this.password)) score *= 1.25; if(/[a-z]/.test(this.password)) score *= 1.25; if(/[0-9]/.test(this.password)) score *= 1.25; if(/[^A-Za-z0-9]/.test(this.password)) score *= 1.25; if(score&gt;40) return \"Perfect\"; if(score&gt;30) return \"Great\"; if(score&gt;20) return \"Good\"; return \"Weak\" &#125; &#125; &#125;) 5-9.片尾彩蛋：你聽過Single source of truth嗎？ (影片) 以下這種寫法，要找到有‘被選擇的項目’，有兩個data參照來源 a,b,c各自的值 selected陣列有兩種參照來源就不符合single source原則1234567&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;checkbox&quot; :check=&apos;a&apos; @change=&quot;changeStatus(&apos;a&apos;)&quot;&gt;A:&#123;&#123;a&#125;&#125;&lt;/input&gt; &lt;input type=&quot;checkbox&quot; :check=&quot;b&quot; @change=&quot;changeStatus(&apos;b&apos;)&quot;&gt;B:&#123;&#123;b&#125;&#125;&lt;/input&gt; &lt;input type=&quot;checkbox&quot; :check=&quot;c&quot; @change=&quot;changeStatus(&apos;c&apos;)&quot;&gt;C:&#123;&#123;c&#125;&#125;&lt;/input&gt; &lt;br/&gt; &lt;span&gt;Selected：&#123;&#123;selected&#125;&#125;&lt;/span&gt;&lt;/div&gt; 1234567891011121314151617181920new Vue(&#123; el:'#app', data:&#123; a:false, b:false, c:false, selected:[], &#125;, methods:&#123; changeStatus(item)&#123; const index = this.selected.indexOf(item); if(index == -1)&#123; this.selected.push(item); &#125;else&#123; this.selected.splice(index, 1); &#125; this[item] = !this[item] ; &#125;, &#125;,&#125;) 為了符合single source原則，將selected改寫為computed，確保‘被選擇的項目’資料單一一致 12345678910111213141516171819202122new Vue(&#123; el:'#app', data:&#123; a:false, b:false, c:false, &#125;, methods:&#123; changeStatus(item)&#123; this[item] = !this[item] ; &#125;, &#125;, computed:&#123; selected()&#123; const result = []; if(this.a) result.push('A'); if(this.b) result.push('B'); if(this.c) result.push('C'); return result; &#125; &#125;&#125;) 更進一步簡化程式：將input的data改為v-model雙向綁定，且改用filter寫法 1234567&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;checkbox&quot; v-model=&apos;a&apos;&gt;A:&#123;&#123;a&#125;&#125;&lt;/input&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;b&quot;&gt;B:&#123;&#123;b&#125;&#125;&lt;/input&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;c&quot;&gt;C:&#123;&#123;c&#125;&#125;&lt;/input&gt; &lt;br/&gt; &lt;span&gt;Selected options:&#123;&#123;selected&#125;&#125;&lt;/span&gt;&lt;/div&gt; 12345678910111213new Vue(&#123; el:'#app', data:&#123; a:false, b:false, c:false, &#125;, computed:&#123; selected()&#123; return ['a','b','c'].filter(item =&gt; this[item]) &#125; &#125;&#125;) 學習來源 Hiskio-姚偉揚老師-精通 VueJS 前端開發完全指南","categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://yoursite.com/categories/Vue-js/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://yoursite.com/tags/Vue-js/"},{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Vue-(四)模板語法","slug":"Vue-(四)模板語法","date":"2019-04-19T07:28:29.477Z","updated":"2019-04-23T16:11:05.001Z","comments":true,"path":"2019/04/19/Vue-(四)模板語法/","link":"","permalink":"http://yoursite.com/2019/04/19/Vue-(四)模板語法/","excerpt":"","text":"4-1.用括號語法，插入動態的數值或文字 (影片)雙大括號：動態綁定123&lt;div id=&quot;app&quot;&gt; &lt;span v-once&gt;&#123;&#123;message&#125;&#125;&lt;/span&gt;&lt;div&gt; 123456new Vue(&#123; el:\"#app\", data:&#123; message:'Hello', &#125;,&#125;) v-once：模板只渲染一次，不被二次變更第一個”“因為加上v-once，即使按button會執行函式改變message的值，但第二個”“在畫面中，並不會被重新渲染1234567&lt;div id=&quot;app&quot;&gt; &lt;span v-once&gt;&#123;&#123;message&#125;&#125;&lt;/span&gt; &lt;br/&gt; &lt;span&gt;&#123;&#123;message&#125;&#125;&lt;/span&gt; &lt;br/&gt; &lt;button v-on:click=&quot;append&quot;&gt;Append&lt;/button&gt;&lt;/div&gt; 1234567891011new Vue(&#123; el:\"#app\", data:&#123; message:'Hello', &#125;, methods:&#123; append()&#123; this.message += \"!\"; &#125;, &#125;&#125;) v-html：渲染出html字串123&lt;div id=&quot;app&quot;&gt; &lt;span v-html=&quot;message&quot;&gt;&lt;/span&gt;&lt;/div&gt; 123456new Vue(&#123; el:\"#app\", data:&#123; message:'&lt;h1 style=\"color:red;\"&gt;Hello&lt;/h1&gt;' &#125;,&#125;) 使用v-html的風險：因為允許使用者輸入的內容包含html，使用者可以故意用 ‘xxxx‘，裡面包了挖礦或攻擊程式。所以使用v-html時，要確保資料來源，資料來源應當是資料庫中的安全內容。 4-2.v-bind, v-on指令 (影片)v-bind：透過資料綁定，改變某個屬性的值123&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;checkbox&quot; v-bind:checked=&quot;check_status&quot;&gt;&lt;/div&gt; 123456new Vue(&#123; el:\"#app\", data:&#123; check_status:false, &#125;,&#125;) v-on：用來偵聽DOM事件，以改變資料 v-on:click v-on:load v-on:mouseover ….其他事件1234&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;checkbox&quot; v-bind:checked=&quot;check_status&quot;&gt; &lt;button v-on:click=&quot;change&quot;&gt;Change status&lt;/button&gt;&lt;/div&gt; 1234567891011new Vue(&#123; el:\"#app\", data:&#123; check_status:false, &#125;, methods:&#123; change()&#123; this.check_status = !this.check_status; &#125; &#125;&#125;) v-bind也可以加入表達式表達式：用()括起來會是一個值，就代表它是一個表達式12345&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;&#123;&#123;count&#125;&#125;&lt;/h1&gt; &lt;input type=&quot;checkbox&quot; v-bind:checked=&quot;(count%2==0)&quot;&gt; &lt;button v-on:click=&quot;add&quot;&gt;Add&lt;/button&gt;&lt;/div&gt; 123456789101112new Vue(&#123; el:\"#app\", data:&#123; count:0, check_status:false, &#125;, methods:&#123; add()&#123; this.count += 1; &#125; &#125;&#125;) 雙大括號中也可以使用表達式1234&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;&#123;&#123;count*2&#125;&#125;&lt;/h1&gt; &lt;button v-on:click=&quot;add&quot;&gt;Add&lt;/button&gt;&lt;/div&gt; 1234567891011new Vue(&#123; el:\"#app\", data:&#123; count:0, &#125;, methods:&#123; add()&#123; this.count += 1; &#125; &#125;&#125;) 4-3.v-bind, v-on的縮寫 (影片) v-on：click ——–&gt; @click v-bind：xxx ——–&gt; :xxx 4-4.雙向綁定的v-model (影片)v-model12345&lt;div id=&quot;app&quot;&gt; &lt;span&gt;&#123;&#123;message&#125;&#125;&lt;/span&gt; &lt;br/&gt; &lt;input type=&quot;text&quot; v-model=&quot;message&quot;/&gt;&lt;/div&gt; 123456new Vue(&#123; el:\"#app\", data:&#123; message:'', &#125;,&#125;) 重點釐清 v-bind: 單向綁定 v-model: 雙向綁定 學習來源Hiskio-姚偉揚老師-精通 VueJS 前端開發完全指南","categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://yoursite.com/categories/Vue-js/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://yoursite.com/tags/Vue-js/"},{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Vue-(三)基本概念","slug":"Vue-(三)基本概念","date":"2019-04-19T07:24:38.026Z","updated":"2019-04-23T16:10:24.606Z","comments":true,"path":"2019/04/19/Vue-(三)基本概念/","link":"","permalink":"http://yoursite.com/2019/04/19/Vue-(三)基本概念/","excerpt":"","text":"3-1.關於Vue (影片)followMVVM架構 透過DOM裡面的監聽event來控制/影響View Model，然後去修改Model中的資料內容; 當Model中的資料變更，會讓View Model知道，再去修改相對應DOM中的內容 Vue的學習重點 3-2.Hello World (影片)創建新的html模板![](https://i.imgur.com/8t8CEQP.png) 加入vue的cdn在cdnjs網站上，搜尋vue，將其cdn複製貼上html的head中，為一個script tag，即可使用vue 的library12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/vue/2.6.8/vue.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 在html的body中創建一個容器讓這個容器可以跟vue做綁定，習慣用div，並給予一個id(習慣會命名為app)123&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt; 在html的body中宣告一個vue先有一個script tag，接這用new vue的方式去宣告出一個vue的實體(vue裡面是一個{}物件)12345678&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script&gt; new Vue(&#123; &#125;); &lt;/script&gt;&lt;/body&gt; 將該vue綁定到某個元素(id)上面在Vue實例中，使用el屬性，其值為html中定義的元素，兩者作綁定 12345678910111213new Vue(&#123; el:&quot;#app&quot;,&#125;);``` ### 定義vue中的data在Vue實例中，使用data屬性，並以物件的寫法，將資料放於其中```htmlmixed=new Vue(&#123; el:&quot;#app&quot;, data:&#123; message:&quot;Hello world!&quot;, &#125; &#125;); data被呼叫使用用大括號呼叫出data12345678910111213141516171819&lt;div id=&quot;app&quot;&gt; &#123;&#123;message&#125;&#125;&lt;/div&gt;``` ### html模板與vue的綁定大功告成！存檔之後，點開html檔案，在瀏覽器上可以看到message被呈現出來![](https://i.imgur.com/Q2IBvDL.png) ## 3-3.相對於「命令式」與「宣告式」渲染 [(影片)](https://hiskio.com/courses/145/lectures/5327)### 製作一個計數器(聲明式寫法)：給他一個目標先在html中宣告一個div容器，命名id為counter，裡面有一個文字h1其中顯示data中的count;另外有一個按鈕button，如果被點按會執行add函式```htmlmixed=&lt;div id=&quot;counter&quot;&gt; &lt;h1&gt;&#123;&#123;count&#125;&#125;&lt;/h1&gt; &lt;button v-on:click=&quot;add&quot;&gt;點我+1&lt;/button&gt;&lt;/div&gt; 改為jquery(命令式寫法)：一個口令一個動作1234&lt;div id=&quot;counter&quot;&gt; &lt;h1&gt;0&lt;/h1&gt; &lt;button&gt;點我+1&lt;/button&gt;&lt;/div&gt; 當button被點按，會執行{}中的流程：將h1中的文字轉為10進位的數字型態int，宣告其為count，完成count+=1之後，再將count存回h1中12345$('button').click(()=&gt;&#123; let count = parseInt ($('h1').text(),10); count += 1; $('h1').text(count);&#125;) ![](https://i.imgur.com/RmCLUp5.png) 主流框架皆為聲明式寫法 聲明式(舉一反三): React, Vue, Angular 命令式(一個口令): jQuery 3-4.if-else:流程控制與迴圈 (影片)v-if與v-else:如果為true成立，則…v-if可以單獨存在;但是，v-else不可以單獨存在，前面一定要搭配v-if使用1234567891011121314151617&lt;div id=&quot;app&quot;&gt; &lt;span v-if=&quot;see&quot;&gt;Now you see mee.&lt;/span&gt; &lt;span v-else&gt;Now you don&apos;t.&lt;/span&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el:&quot;#app&quot;, data:&#123; see:true, &#125;, methods:&#123; change_status()&#123; this.see = ! this.see; &#125;, &#125; &#125;)&lt;/script&gt; v-for在v-for=”step in steps”語法中，定義每次從steps中拿出來的東西是step;接著，再用”“將step的內容顯示出來1234567891011121314151617&lt;div id=&quot;app&quot;&gt; &lt;div v-for=&quot;step in steps&quot;&gt;&#123;&#123;step&#125;&#125;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el:&quot;#app&quot;, data:&#123; see:true, steps:[&apos;步驟一&apos;,&apos;步驟二&apos;,&apos;步驟三&apos;] &#125;, methods:&#123; change_status()&#123; this.see = ! this.see; &#125;, &#125; &#125;)&lt;/script&gt; 3-5.處理使用者輸入 (影片)偵聽事件v-on按鈕button被偵聽點按click事件，每當click事件發生，就會執行remove123456&lt;div id=&quot;counter&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in counts&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;button v-on:click=&quot;remove&quot;&gt;remove a number&lt;/button&gt;&lt;/div&gt; 每當remove()函式被呼叫執行，就會從this.counts陣列中拿走一個項目1234567891011new Vue(&#123; el:'#counter', data:&#123; counts:[1,2,3,4,5], &#125;, methods:&#123; remove()&#123; this.counts.pop(); &#125;, &#125;&#125;) 自動雙向綁定v-model透過v-model語法將input跟show_word綁定，若input中的內容改變，會自動更新到data的show_word1234&lt;div id=&quot;inputer&quot;&gt; &lt;h1&gt;&#123;&#123;show_word&#125;&#125;&lt;/h1&gt; &lt;input type=&quot;text&quot; v-model=&quot;show_word&quot; placeholder=&quot;請輸入文字內容&quot;/&gt;&lt;/div&gt; 123456new Vue(&#123; el:'#inputer', data:&#123; show_word:'', &#125;,&#125;) 3-6.實作：老梗才是好梗「Todo List」 (影片)用內容比對刪除如果內容重複，只會找到第一筆一樣的資料，會出錯12345678910111213141516171819202122232425262728293031&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;input&quot;&gt;&lt;/input&gt; &lt;button v-on:click=&quot;addItem&quot;&gt;add&lt;/button&gt; &lt;ul&gt; &lt;li v-for=&quot;item in lists&quot;&gt; &lt;span&gt; &#123;&#123;item&#125;&#125;&lt;button v-on:click=&quot;removeItem(item)&quot;&gt;delete&lt;/button&gt; &lt;span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el:&apos;#app&apos;, data:&#123; input:&apos;&apos;, lists:[], &#125;, methods:&#123; addItem()&#123; this.lists.push(this.input); this.input=&apos;&apos; &#125;, removeItem(item)&#123; //只找到第一筆內容符合的項目，會出錯 const idx = this.lists.indexOf(item); this.lists.splice(idx,1); &#125; &#125;, &#125;) &lt;/script&gt; 用index刪除直接指定該index的數值，刪除在陣列中第(index+1)筆資料1234567891011121314151617181920212223242526272829&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;input&quot;&gt;&lt;/input&gt; &lt;button v-on:click=&quot;addItem&quot;&gt;add&lt;/button&gt; &lt;ul&gt; &lt;li v-for=&quot;(item, index) in lists&quot;&gt; &lt;span&gt; 第&#123;&#123;index+1&#125;&#125;點：&#123;&#123;item&#125;&#125;&lt;button v-on:click=&quot;removeItem(index)&quot;&gt;delete&lt;/button&gt; &lt;span&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el:&apos;#app&apos;, data:&#123; input:&apos;&apos;, lists:[], &#125;, methods:&#123; addItem()&#123; this.lists.push(this.input); this.input=&apos;&apos; &#125;, removeItem(index)&#123; this.lists.splice(index,1); &#125; &#125;,&#125;)&lt;/script&gt; 3-7.Vue/React/Angular，我該上哪部攻城車？ (影片) React需要較多的JS基礎，因此若JS功力深厚者，React可以很快上手 若為初學JS，建議可以從Vue開始學習 Angular學習框架成本高","categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://yoursite.com/categories/Vue-js/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://yoursite.com/tags/Vue-js/"},{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Vue-(一)課程前言、(二)行前準備","slug":"Vue-(一)課程前言、(二)行前準備","date":"2019-04-17T08:15:12.750Z","updated":"2019-04-23T16:10:08.897Z","comments":true,"path":"2019/04/17/Vue-(一)課程前言、(二)行前準備/","link":"","permalink":"http://yoursite.com/2019/04/17/Vue-(一)課程前言、(二)行前準備/","excerpt":"","text":"1-1.老師的話 (文章)如何設計出好架構，如何寫出好程式?許多人問過我，要如何設計出好架構，寫出好程式 我回答的都是同一個方法: 空氣朋友 在你寫 code 時請你想像一個不存在的朋友 你要向他解釋你寫出來的每一行程式碼，他甚至可能提問 如果在某處你無法流暢清晰的解釋 代表那個地方你必須想的更深更廣，作更多的研究 長此以往，必定可以有顯著的進步! 2-1：課程準備(影片) 在vscode中安裝Vue 2 Snippets套件針對編譯器中coding，做不同文字顏色的呈現，便於檢視code 在codepen中載入Vuejavascript的地方新增框架vue，即可使用vue 2-2：取代var的let與const(影片) var是全域變數 1234全域變數var i可以在所有地方被使用for(var i=0;i&lt;3;i++)&#123;&#125;console.log(i);//會印出3 let與const是區域變數區域變數let i只在for迴圈中可以被使用 123for(let i=0;i&lt;3;i++)&#123;&#125;console.log(i);//錯誤：i is not defined const 宣告出來的變數是無法被re-assign的123for(const i=0;i&lt;3;i++)&#123;&#125;console.log(i);//錯誤：i無法被修改 若const被宣告為物件，是可以改變其中的內容const若被宣告為物件，const本身無法被重新re-assign，但是物件{}其中的內容是可以重新被re-assign 12const c =&#123;x:0&#125;;c.x = 3; javascript的hoisting特性可以先執行Function，再補宣告 123a();//先呼叫執行function a()&#123; //再補宣告&#125; 可以先呼叫a,再補宣告var;但是，不能補宣告let12a+=1;var a; 12a+=1;//會報錯，找不到alet a; 2-3：簡潔快速的縮寫shorthands(影片) object中的屬性縮寫當object裡的內容，其key與value是同名的情況（key=value=x)，1234567function makePoint(x,y)&#123; return&#123; x:x,//左邊的x代表key,右邊的x代表value y:y, name:name, &#125;&#125; 可以改寫為1234567function makePoint(x,y)&#123; return&#123; x,//x key的value也是‘x’,所以會往上找到參數‘x’ y, name, &#125;&#125; 補充：物件object物件的內容是由屬性組成的，而屬性是由 key-value pair 構成，value 可為任意資料型別的值，並且值是以參考型別（reference)的方式（存位置）儲存。 如何存取物件的屬性呢？有兩種方式121. 特性存取（property access），使用 .2. 鍵值存取（key access），使用 [ ] 12345const obj = &#123; &apos;a&apos;: &apos;Hello World&apos;,&#125;;console.log(obj.a);&lt;!--&quot;Hello World&quot; --&gt;console.log(obj[&apos;a&apos;]);&lt;!--&quot;Hello World&quot; --&gt; 計算屬性若object中的key為動態的，key可以用中括號[]括起來，代表[]裡面是計算後的屬性。 12345678function createObj(key,value)&#123; const obj=&#123;&#125;; obj[key]=value; return obj;&#125;const person = createObj('name','John');// 會生成出一個物件// person=&#123;name:'John'&#125; 改寫為 12345678function createObj(key,value)&#123; const obj=&#123; [key]:value; &#125;; return obj;&#125;const person = createObj('name','John');const cat = createObj('legs',4); []裡面也可以放運算子123456function createObj(key,value)&#123; const obj=&#123; [key+1]:value; &#125;; return obj;&#125; 函式縮寫當物件中有函式function()12345678910const options=&#123; name:'Options', level:3, created:function()&#123; &#125;, mounted:function()&#123; &#125;, &#125;; 可以改寫為12345678910const options=&#123; name:'Options', level:3, created()&#123; &#125;, mounted()&#123; &#125;, &#125;; 2-4：便利的取出元素：解構賦值(影片)解構賦值(Destructuring assignment)語法是一種 JavaScript 運算式，可以將陣列或物件中的資料取出成獨立變數。 陣列解構（拿多個） 1234const nums = [111,222,333];const first = nums[0];const second = nums[1];const third = nums[2]; 可以將陣列解構，改寫為 1234const nums = [111,222,333];// const [first,second] = nums;const [first,second,third,forth]=nums;//forth會是undefineconst result = first+second+third+forth;//錯誤：因為forth是undefine 陣列解構（預設值）若想避免為undefined，可以在解構的同時給予預設值 12const nums = [111,222,333];const[first, second, third, forth=0 ]=nums;//forth會是undefine 陣列解構（忽略元素，拿一個）假設只要拿出third為333，前面可以忽略 12const nums = [111,222,333];const [,,third] = nums; 陣列解構(變數交換) 12345let a = 1;let b = 2;let temp = a;a = b;b = temp; 利用解構賦值做變數交換的改寫123let a = 1;let b = 2;[a,b]=[b,a] 陣列解構(剩餘部分) 12345const nums = [1,2,3,4];const[first,...others]=nums;//// first = 1;// others = [2,3,4] 物件解構 123456const point=&#123; x:100, y:150,&#125;const x = point.x;const y = point.y; 物件解構可以用大括號{}改寫 12345const point=&#123; x:100, y:150,&#125;const &#123;x,y&#125;= point; 物件解構(預設值)為了避免undefined，可以在解構的同時給予預設值 12345const point=&#123; x:100, y:150, &#125;const &#123;x, y, z = 0&#125; = point; 物件解構(指派新名稱)透過冒號：給予新名稱 1234567const point = &#123; x:100, y:150,&#125;const[x:px, y:py] = point;const result = px*py;const result = x*y;//錯誤：找不到x,y 解構函式參數計算point到圓點的距離數學算式：（x平方＋y評分）=&gt;再開根號 1234567const point = &#123; x:100, y:150,&#125;function distance(point)&#123; return Math.sqrt(point.x*point.x + point.y*point.y);&#125; 可以改寫為1234function distance(point)&#123; const&#123;x,y&#125; = point; return Math.sqrt(x*x + y*y);&#125; 或是直接在函式的參數中作解構123function distance(&#123;x,y&#125;)&#123; return Math.sqrt(x*x + y*y);&#125; 甚至還可以在參數中給予預設值，並重新命名123function distance(&#123;x:px=0;y:py=0&#125;)&#123; return Math.sqrt(px*px + py*py);&#125; 2-5：更強的字串：字串模板與多行字串(影片) 字串模板(string templete)原始寫法1234function greet(name)&#123; console.log('Hello, ' + name + '!');&#125;greet('Jack');//印出 Hello, Jack! 改寫用backtick`宣告字串模板，在要放入變數的地方用＄{}將變數括起來123function greet(name)&#123; console.log(`Hello, $&#123;name&#125;!`); &#125; 補充：表達式(expression)vs.陳述式(statement)陳述式statement:只做行動但不立即產生結果表達式expression:用小括號()將內容包起來，()裡面是值12const a;//陳述式(a+1);//表達式 字串模板中插入表達式1234function greet(name,days)&#123; const hours = days * 24; console.log(`Hello, $&#123;name&#125;! It's been $&#123;hours&#125; hours!`);&#125; 在字串模板中，加入表達式的改寫123function greet(name,days)&#123; console.log(`Hello, $&#123;name&#125;!It's been $&#123;days * 24&#125; hours!`);&#125; 字串模板中加入三元判斷式三元判斷式解釋：若(days&lt;7)成立，則回傳’’,否則回傳’Long time no see.’ 123456function greet(name,days)&#123; console.log(`Hello, $&#123;name&#125;! $&#123;(days&lt;7)?'':'Long time no see.'&#125;`)&#125;greet('Jack',3);//Hello, Jack!greet('Peter',8);//Hello, Peter! Long tome no see. 多行字串長文章斷行，宣告多行字串不能斷行，若要換行只能使用+ 1const words = 'aaa\\n'+'bbbb\\n'+'ccccc'; 用字串模板改寫（字串模板支援多行字串）12345const words = ` aaa bbbb ccccc`; 2-6：不只更簡短：箭頭函式(影片) 箭頭函式，語法簡短123var double = function(x)&#123; return x*2;&#125; 123const double = (x) =&gt; &#123; return x*2;&#125; 如果參數只有一個，可以將小括號()省略123const double = x =&gt; &#123;&#125; 如果函式本體只有一行，而且是return，可以省略{}，將return內容直接寫在後面，1const double = x =&gt; x*2; 箭頭函式，自動綁定箭頭函式內部的this與外部相同12345const a =()=&gt;&#123; console.log(this);//等於外面的this&#125;console.log(this);//第2行、第4行執行的this，指向同一個 1234567const a = () =&gt;&#123; console.log(this); const aa = () =&gt;&#123; console.log(this);/等於外面的this &#125;&#125;//第2行、第4行執行的this，指向同一個 補充：函式裡面的this是什麼？this是函式的context，情境不同，執行結果也不同 直接執行：“this”代表window(瀏覽器的global是window) 12345var name = 'Heisenburg';var sayMyName = function()&#123; console.log(this.name);&#125;sayMyName();//Heisenburg 宣告一個物件，將函式作為該物件的成員函式：“this”代表該物件 12345var teacher = &#123; name:'Jack',&#125;teacher.sayMyName = sayMyName;//物件的成員函式teacher.sayNyName();//Jack 作為DOM中的監聽函式：“this”代表該DOM元素 假設html中有一個button1&lt;button id=&quot;btn&quot; name=&quot;Btn-click&quot;&gt;click me!&lt;/button&gt; 當button被按下之後，會執行函式sayMyName12btn.addEventListener('click',sayMyName);//Btn-click ==但是，若將函式改為箭頭函式…==箭頭函式中的this代表外面的this，所以三種執行結果的name都ㄧ樣1234567891011121314var name = 'Heisenburg';var sayMyName = () =&gt;&#123; console.log(this.name);&#125;var teacher = &#123; name = 'Jack',&#125;teacher.sayMyName = sayMyName;sayMyName();//Heisenburgteacher.sayMyName();//Heisenburgbtn.addEventListener('click',sayMyName);//Heisenburg 2-7：片尾彩蛋：ES5、ES6、Es2017!?到底是什麼東西？(影片) ECMAScript(往往被稱作JavaScript) ECMA組織訂出JavaScript的語法規範，再讓各家瀏覽器依照規範實作 學習來源 Hiskio-姚偉揚老師-精通 VueJS 前端開發完全指南","categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://yoursite.com/categories/Vue-js/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://yoursite.com/tags/Vue-js/"},{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"CSS-將footer置底","slug":"CSS-將footer置底","date":"2019-04-16T10:50:13.935Z","updated":"2019-04-23T15:59:45.446Z","comments":true,"path":"2019/04/16/CSS-將footer置底/","link":"","permalink":"http://yoursite.com/2019/04/16/CSS-將footer置底/","excerpt":"","text":"通常一個頁面中包含三個部分：header、main-content、footer，可是當main-content中的內容不足以撐開整個頁面高度，footer下方就會出現一塊空白區域。這種情況，如果希望footer可以維持底部，整理兩種做法： 方法1. 設定main-content的最小高度為100%方法2. 在最外部再包一層wrapper，設定期高度為100% ; 且讓footer設定為絕對定位bottom:0 方法1.設定main-content的最小高度為100% html, body 高度為100%main-content 最小高度為100% 上、下padding空間，作為放置header、footer的空間 header 使用絕對定位，top為0 設定z-index確保在最上方 footer 使用相對定位，top為自己的高度 123456&lt;!-- html --&gt;&lt;body&gt; &lt;header class=&apos;header&apos;&gt;&lt;/header&gt; &lt;div class=&quot;main-content&quot;&gt;&lt;/div&gt; &lt;footer class=&quot;footer&quot;&gt;&lt;/footer&gt;&lt;/body&gt; 1234567891011121314151617181920html,body&#123; height: 100%; /* background-color: azure; */&#125;.header&#123; height: 50px; position: absolute; top:0; z-index: 900;&#125;.main-content&#123; min-height: 100%; padding-top:50px; padding-bottom:50px;&#125;.footer&#123; position: relative; top: -100px; height: 50px;&#125; 方法2.在最外部再包一層wrapper html, body 高度為100% wrapper 最小高度為100% footer 使用絕對定位，bottom為0 12345678&lt;!-- html --&gt;&lt;body&gt; &lt;div class=&apos;wrapper&apos;&gt; &lt;header class=&apos;header&apos;&gt;&lt;/header&gt; &lt;div class=&quot;main-content&quot;&gt;&lt;/div&gt; &lt;footer class=&quot;footer&quot;&gt;&lt;/footer&gt; &lt;/div&gt;&lt;/body&gt; 12345678910html, body&#123; height: 100%&#125;.wrapper&#123; min-height: 100%;&#125;.footer&#123; position: absolute; bottom: 0;&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"layuot","slug":"layuot","permalink":"http://yoursite.com/tags/layuot/"}]},{"title":"jQuery-改變CSS樣式","slug":"jQuery-改變CSS樣式","date":"2019-04-16T10:49:34.889Z","updated":"2019-04-23T16:06:46.486Z","comments":true,"path":"2019/04/16/jQuery-改變CSS樣式/","link":"","permalink":"http://yoursite.com/2019/04/16/jQuery-改變CSS樣式/","excerpt":"","text":"語法結構1$(&apos;選擇器&apos;).css(&apos;屬性&apos;,&apos;值&apos;); $()函式的功能是將HTML元素轉換為jQuery特殊元素，經此方法轉換後的HTML元素稱為「jQuery物件」 css()中所定義的指令是「jQuery方法」，意即「jQuery其js中定義了的css()這個函式」 選擇器：與CSS相同的選擇器 屬性：CSS的屬性 值：若為字串，需用單引號或雙引號（&quot;&quot;、&#39;&#39;)括號起來;若值為數值，則不需要。 補充：jQuery可以修改元素的CSS屬性中的值，但若有使用!important的項目仍會優先套用。 語法執行概念 先利用$()函式，將作為指令對象的HTML元素，轉換為jQuery物件 針對jQuery物件呼叫方法，以進行相關操作簡易範例 12345$(function()&#123; $('#typo').css('color','#556A5B'); $('#typo').css('transform','rotate(10deg)') $('#typo .inner').css('opacity',0.5)&#125;)","categories":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/categories/HTML/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"jQuery-事件處理","slug":"jQuery-事件處理","date":"2019-04-16T10:49:25.993Z","updated":"2019-04-23T16:06:39.011Z","comments":true,"path":"2019/04/16/jQuery-事件處理/","link":"","permalink":"http://yoursite.com/2019/04/16/jQuery-事件處理/","excerpt":"","text":"事件處理函式語法結構123$(&apos;選擇器&apos;).on(&apos;事件類型&apos;, function()&#123; 任意處理程序&#125;) $()函式的功能是將HTML元素轉換為jQuery特殊元素，經此方法轉換後的HTML元素稱為「jQuery物件」 on()是設定「當某事件發生時，執行某指令」的方法。 第一個參數是「事件類型(Event Type)」：事件觸發的條件 第二個參數是「處理程序(Event Handler)」：事件被觸發後，接著要调用的方法。 語法執行概念 先利用$()函式，將作為指令對象的HTML元素，轉換為jQuery物件 針對jQuery物件呼叫on()方法 在on()方法中傳入兩個參數，定義要被觸發的「事件類型」以及接下來要執行的「處理程序」 簡易範例當滑鼠移入#typo，接著會執行：透過css樣式修改#typo的顏色 12345$function()&#123; $('#typo').on('mouseover',function()&#123; $('#typo').css('color','#ebc000') &#125;)&#125; 多個處理程序在.on()方法中的第一個參數「事件類型」被觸發之後，第二個參數「處理程序函式」中可以執行數個個別處理的程序 語法結構12345$(&apos;選擇器&apos;).on(&apos;事件類型&apos;, function()&#123; 處理1; 處理2; 處理3...;&#125;) 簡易範例 當滑鼠移入#typo，接著會執行： 透過css樣式修改#typo的顏色 透過css樣式修改header的背景顏色123456$function()&#123; $('#typo').on('mouseover',function()&#123; $('#typo').css('color','#ebc000') ; $('header').css('background-color','#ffffff') &#125;)&#125; 設定多個事件類型一個jQuery物件，可以有多個.on()方法，例如：當A事件(滑鼠移入)時要執行a程序，而當B事件(滑鼠移出)時要執行b程序 方法鏈串語法多個方法如鎖鏈一般串連起來，針對$()產生的同一個jQuery物件作為執行對象，程式會從左到右開始執行。1$(&apos;選擇器&apos;).事件A().事件B().事件C().... 簡易案例 當滑鼠移入#typo元素時，會改變文字即背景顏色 當滑鼠移出#typo元素時，會回復為原本的顏色 多個事件一般寫法(效能差) 針對同一個物件，寫兩次$()函式，瀏覽器花時間分析HTML並取得目標元素，會造成CPU負擔1234567891011121314$(function()&#123; $('#typo').on('mouseover',function()&#123; $('#typo').css(&#123; color:'#ebc000', backgroundColor:'#ae5e96' &#125;); &#125;); $('#typo').on('mouseout',function()&#123; $('#typo').css(&#123; color:'', backgroundColor:'' &#125;); &#125;);&#125;) 修改為鏈串寫法(效能佳) 只需要使用一次$()函式，除了簡化程式碼，也提稱程式處理速度123456789101112131415$(function()&#123; $('#typo') .on('mouseover',function()&#123; $('#typo').css(&#123; color:'#ebc000', backgroundColor:'#ae5e96' &#125;) &#125;) .on('mouseout',function()&#123; $('#typo').css(&#123; color:'', backgroundColor:'' &#125;) &#125;)&#125;) 主要的事件類型 jQuery中，大部分的操作都基於HTML DOM，所以必須確定頁面文件已經完全下載好，才能開始執行程式。jQuery 提供下面這個函式來處理 DOM ready事件 當DOM載入後，執行ready()方法。123$(document).ready(function() &#123; // 這裡放你要執行的程式碼&#125;); 也可以這樣寫123$function()&#123; // 這裡放你要執行的程式碼&#125;","categories":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/categories/HTML/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"Hexo-使用靜態生成器，建立blog(3/3)變更主題","slug":"Hexo-使用靜態生成器，建立blog(3_3)變更主題","date":"2019-04-11T08:50:43.538Z","updated":"2019-04-23T16:20:18.777Z","comments":true,"path":"2019/04/11/Hexo-使用靜態生成器，建立blog(3_3)變更主題/","link":"","permalink":"http://yoursite.com/2019/04/11/Hexo-使用靜態生成器，建立blog(3_3)變更主題/","excerpt":"","text":"系列文章 Hexo-使用靜態生成器，建立blog(1/3)本地端 Hexo-使用靜態生成器，建立blog(2/3)推上github Hexo-使用靜態生成器，建立blog(3/3)變更主題複製主題到自己的專案 將別人的製作好的主題repository clone下來的時候，可能會連.git 一起 clone下來，出現「Git Submodule」 「Git Submodule」就是原先的repository中，還內嵌一到多個外部repository 查看clone下來的repository是否含有.git123//進入themes資料夾，查看檔案列表$ cd themes$ ls -al 123//進入內部主題資料夾，查看其中檔案列表$ cd hiero$ ls -al 刪除內部主題資料夾中的.git123//強制刪除.git（-rf : recursive + force）$ rm -rf .git$ ls -al 刪除快取 1$ git rm --cached themes/hiero -f 查看尚未commit的當案 1$ git status 新增檔案 1$ git add &lt;file name&gt; 使用git管理檔案 1$ git commit -m&quot;&lt;commit message&gt;&quot; 檢視提交紀錄(也可以用soursetree檢視) 1$ git log 使用hexo產生靜態網頁hexo 是把產生出來的網站push到github(可以理解為，hexo的deploy指令會先把原始碼變成網站瀏覽器可以閱讀的程式碼 再push到github)1$ hexo deploy -g","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"blog","slug":"blog","permalink":"http://yoursite.com/tags/blog/"},{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/tags/GitHub/"}]},{"title":"Hexo-使用靜態生成器，建立blog(2/3)推上github","slug":"Hexo-使用靜態生成器，建立blog(2_3)推上github","date":"2019-04-11T08:50:37.359Z","updated":"2019-04-23T16:22:41.592Z","comments":true,"path":"2019/04/11/Hexo-使用靜態生成器，建立blog(2_3)推上github/","link":"","permalink":"http://yoursite.com/2019/04/11/Hexo-使用靜態生成器，建立blog(2_3)推上github/","excerpt":"","text":"系列文章 Hexo-使用靜態生成器，建立blog(1/3)本地端 Hexo-使用靜態生成器，建立blog(2/3)推上github Hexo-使用靜態生成器，建立blog(3/3)變更主題push上github 先在github新增一個repository，命名邏輯為 12[github account].github.io例：leahlin912.github.io 複製該repository的網址(例：`git@github.com:leahlin912/leahlin912.github.io.git`) 用vscode(或其他編譯器)打開_config.yml檔案，並修改# Deployment的部分 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: git@github.com:leahlin912/leahlin912.github.io.git branch: master 安裝git 1$ npm install hexo-deployer-git --save 輸入指令，將網站佈署到伺服器上 1$ hexo deploy -g 設定repository的主題在github的該repository頁面，進入「setting」往下滑，點按「change theme」 在瀏覽器中查看網址，成功！https://leahlin912.github.io/ 若有檔案更新，則重複輸入指令 1hexo deploy -g 更換主題 選擇要套用的主題[Themes](https://hexo.io/themes/index.html) 點進該主題的github頁面 在README.md中，依照install指令複製起來，並在terminal中進入blog資料夾中執行指令完畢 用vscode開啟blog資料夾，並進入_config.yml檔案中，修改主題theme(參考readme中開發者定義的theme名稱) 因為檔案有更新，所以需要在terminal輸入指令 1hexo deploy -g","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"blog","slug":"blog","permalink":"http://yoursite.com/tags/blog/"},{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/tags/GitHub/"}]},{"title":"Hexo-使用靜態生成器，建立blog(1/3)本地端","slug":"Hexo-使用靜態生成器，建立blog(1_3)本地端","date":"2019-04-11T08:50:30.497Z","updated":"2019-04-23T16:21:07.585Z","comments":true,"path":"2019/04/11/Hexo-使用靜態生成器，建立blog(1_3)本地端/","link":"","permalink":"http://yoursite.com/2019/04/11/Hexo-使用靜態生成器，建立blog(1_3)本地端/","excerpt":"","text":"系列文章 Hexo-使用靜態生成器，建立blog(1/3)本地端 Hexo-使用靜態生成器，建立blog(2/3)推上github Hexo-使用靜態生成器，建立blog(3/3)變更主題環境安裝 先確認電腦已經安裝下列軟體 Node.js(補充：檢查電腦是否已經安裝Node.js，可以在terminal中輸入node -v) Git Mac需要先關閉系統完整保護(SIP) (當在Mac上嘗試開啟一些第三方軟體的時候，可能會受到SIP的限制而無法正常使用。) 先查看SIP開啟/關閉狀態在terminal中輸入csrutil status 如果看到「System Integrity Protection status: enabled」代表SIP開啟 如果看到「System Integrity Protection status: disabled」，代表 SIP是關閉的。 在Mac上關閉SIP step1. 重新啟動Mac開機鍵時，同時按Command+R鍵 step2. 出現彈出視窗後，在螢幕左上方的「工具程式」選單中點按「終端機」。 step3. 啟動「終端機」視窗後，在「終端機(terminal)」中輸入csrutil disable step4. 關閉「終端機」視窗，並重新開機。 補充： 待整個回合(下載Hexo完畢)結束之後，記得修改SIP狀態為開啟，重複上述動作，在「終端機(terminal)」中輸入csrutil enable。 正式開始下載Hexo開始透過npm安裝Hexo，在terminal中輸入安裝指令： 1$ npm install hexo-cli -g 初始化資料夾使用指令建立資料夾，在建立的同時給予命名，並自動初始化資料夾內的檔案結構(示範：以’blog’作為資料夾名稱)，請依序執行下方指令 123$ hexo init &lt;folder name&gt;$ cd &lt;folder name&gt;$ npm install 建立完成後，專案資料夾會有下列檔案： 在本地端開啟blog網頁完成上述流程後，在terminal輸入啟用本地端伺服器的指令 1$ hexo server 本地端伺服器已經啟用 即可在瀏覽器中檢視blog畫面(http://localhost:4000) 新增文章在blog中在blog資料夾的內層中找到_posts資料夾，並將.md檔案拖曳至於其中","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"blog","slug":"blog","permalink":"http://yoursite.com/tags/blog/"}]},{"title":"使用Hexo，建立blog(上)新增文章","slug":"使用Hexo，建立blog(上)新增文章","date":"2019-04-08T01:48:12.000Z","updated":"2019-04-23T16:13:09.397Z","comments":true,"path":"2019/04/08/使用Hexo，建立blog(上)新增文章/","link":"","permalink":"http://yoursite.com/2019/04/08/使用Hexo，建立blog(上)新增文章/","excerpt":"","text":"使用Hexo，建立blog(上)新增文章若要更換主題，可以參考下一篇文章使用Hexo，建立blog(下)自定義主題 環境安裝 先確認電腦已經安裝下列軟體 Node.js(補充：檢查電腦是否已經安裝Node.js，可以在terminal中輸入node -v) Git Mac需要先關閉系統完整保護(SIP) (當在Mac上嘗試開啟一些第三方軟體的時候，可能會受到SIP的限制而無法正常使用。) 先查看SIP開啟/關閉狀態在terminal中輸入csrutil status 如果看到「System Integrity Protection status: enabled」代表SIP開啟 如果看到「System Integrity Protection status: disabled」，代表 SIP是關閉的。 在Mac上關閉SIP step1. 重新啟動Mac開機鍵時，同時按Command+R鍵 step2. 出現彈出視窗後，在螢幕左上方的「工具程式」選單中點按「終端機」。 step3. 啟動「終端機」視窗後，在「終端機(terminal)」中輸入csrutil disable step4. 關閉「終端機」視窗，並重新開機。 補充： 待整個回合(下載Hexo完畢)結束之後，記得修改SIP狀態為開啟，重複上述動作，在「終端機(terminal)」中輸入csrutil enable。 正式開始下載Hexo開始透過npm安裝Hexo，在terminal中輸入安裝指令： 1$ npm install hexo-cli -g 初始化資料夾使用指令建立資料夾，在建立的同時給予命名，並自動初始化資料夾內的檔案結構(示範：以’blog’作為資料夾名稱)，請依序執行下方指令 123$ hexo init &lt;folder name&gt;$ cd &lt;folder name&gt;$ npm install 建立完成後，專案資料夾會有下列檔案： 在本地端開啟blog網頁完成上述流程後，在terminal輸入啟用本地端伺服器的指令 1$ hexo server 本地端伺服器已經啟用 即可在瀏覽器中檢視blog畫面(http://localhost:4000) 新增文章在blog中在blog資料夾的內層中找到_posts資料夾，並將.md檔案拖曳至於其中","categories":[{"name":"github","slug":"github","permalink":"http://yoursite.com/categories/github/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://yoursite.com/tags/blog/"},{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"使用Hexo，建立blog(下)自定義主題","slug":"使用Hexo，建立blog(下)自定義主題","date":"2019-04-08T01:32:28.000Z","updated":"2019-04-23T16:13:15.216Z","comments":true,"path":"2019/04/08/使用Hexo，建立blog(下)自定義主題/","link":"","permalink":"http://yoursite.com/2019/04/08/使用Hexo，建立blog(下)自定義主題/","excerpt":"","text":"使用Hexo，建立blog(下)自定義主題接續上一篇文章使用Hexo，建立blog(上)新增文章 push上github 先在github新增一個repository，命名邏輯為 12[github account].github.io例：leahlin912.github.io 複製該repository的網址(例：`git@github.com:leahlin912/leahlin912.github.io.git`) 用vscode(或其他編譯器)打開_config.yml檔案，並修改# Deployment的部分 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: git@github.com:leahlin912/leahlin912.github.io.git branch: master 安裝git 1$ npm install hexo-deployer-git --save 輸入指令，將網站佈署到伺服器上 1$ hexo deploy -g 設定repository的主題在github的該repository頁面，進入「setting」往下滑，點按「change theme」 在瀏覽器中查看網址，成功！https://leahlin912.github.io/ 若有檔案更新，則重複輸入指令 1hexo deploy -g 更換主題 選擇要套用的主題[Themes](https://hexo.io/themes/index.html) 點進該主題的github頁面 在README.md中，依照install指令複製起來，並在terminal中進入blog資料夾中執行指令完畢 用vscode開啟blog資料夾，並進入_config.yml檔案中，修改主題theme(參考readme中開發者定義的theme名稱) 因為檔案有更新，所以需要在terminal輸入指令 1hexo deploy -g","categories":[{"name":"github","slug":"github","permalink":"http://yoursite.com/categories/github/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://yoursite.com/tags/blog/"},{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"JavaScript-使用API串接公開第三方資源","slug":"JS-使用API串接公開第三方資源","date":"2019-04-08T01:27:02.000Z","updated":"2019-05-03T06:22:08.691Z","comments":true,"path":"2019/04/08/JS-使用API串接公開第三方資源/","link":"","permalink":"http://yoursite.com/2019/04/08/JS-使用API串接公開第三方資源/","excerpt":"","text":"何為API?API(Application Program Interface)意即應用程式的接口，用於定義軟體與軟體之間銜接所需的溝通方法。換句話說，API是讓軟體與軟體互相串接溝通橋樑。 網站可以使用Web APIs 銜接第三方軟體，獲得第三方端點(endpoint)中含有JSON格式的資料。 Web APIs透過HTTP協議方法，向第三方的公開URL端點發出需求。 開始串接一個API 閱讀API文件：Studio Ghibli API documentation 取得API endpoint：在API文件中，滑到films部分，右側會看到GET /films，其中的URL就是API endpoint，點進這個URL會看到一個陣列中包含多個物件，並以JSON格式呈現 使用HTTP請求獲取資料： 在.js檔案中，創造一個「XMLHttpRequest」物件，並指派給request變數。 使用open()函式連接，必要的參數包含「請求方法(‘GET’)」及「API端點的URL」 請求完畢後，我們就有權限進使用onload()函式，進到資料中 最後，send()正式送出請求12345678910111213// Create a request variable and assign a new XMLHttpRequest object to it.var request = new XMLHttpRequest()// Open a new connection, using the GET request on the URL endpointrequest.open('GET', 'https://ghibliapi.herokuapp.com/films')request.onload = function () &#123; // Begin accessing JSON data here &#125;&#125;// Send requestrequest.send() 處理HTTP回傳資料： 回傳值為JSON格式，必須先使用用JSON.parse()將JSON轉換為javascript物件 接下來就可以對資料做處理了。例：這裡的資料為陣列，所以下方用forEach()一一讀取陣列中的物件，並且印出每個物件的title 1234567// Begin accessing JSON data herevar data = JSON.parse(this.response)data.forEach(movie =&gt; &#123; // Log each movie's title console.log(movie.title)&#125;) 處理錯誤error：每次HTTP發出請求，就會回傳status code，常見的錯誤為404(Not found)，成功為200(OK)。判斷request.status，如果成功就執行印出資料，否則就印出error 12345678910// Begin accessing JSON data herevar data = JSON.parse(this.response)if (request.status &gt;= 200 &amp;&amp; request.status &lt; 400) &#123; data.forEach(movie =&gt; &#123; console.log(movie.title) &#125;)&#125; else &#123; console.log('error')&#125; 接續，在頁面上顯示API資料 index.html中有一個div容器，設為id=’root’ 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;script src=&quot;scripts.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 在script.js取得root元素 1const app = document.getElementById('root') 在網頁左上放一個logo 1const logo = document.createElement('img') 新增一個div標籤元素，並且用class定義其css樣式 12const container = document.createElement('div')container.setAttribute('class', 'container') 將新增的元素放到網頁上 12app.appendChild(logo)app.appendChild(container) 繼續在container中填充回傳值資料 123456789101112131415161718192021data.forEach(movie =&gt; &#123; // Create a div with a card class const card = document.createElement('div') card.setAttribute('class', 'card') // Create an h1 and set the text content to the film's title const h1 = document.createElement('h1') h1.textContent = movie.title // Create a p and set the text content to the film's description const p = document.createElement('p') movie.description = movie.description.substring(0, 300) // Limit to 300 chars p.textContent = `$&#123;movie.description&#125;...` // End with an ellipses // Append the cards to the container element container.appendChild(card) // Each card will contain an h1 and a p card.appendChild(h1) card.appendChild(p)&#125;) 成果 github完整程式碼 網頁呈現 參考來源 How to Connect to an API with JavaScript","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"API","slug":"API","permalink":"http://yoursite.com/tags/API/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"使用github page顯示靜態網頁","slug":"使用github page顯示靜態網頁","date":"2019-04-07T23:29:12.000Z","updated":"2019-04-23T16:12:33.048Z","comments":true,"path":"2019/04/08/使用github page顯示靜態網頁/","link":"","permalink":"http://yoursite.com/2019/04/08/使用github page顯示靜態網頁/","excerpt":"","text":"使用github page顯示靜態網頁設定github綁定金鑰 在本地端新增ssh資料夾 取得公鑰、私鑰，將公鑰貼上github 新增ssh完成 repository推上GitHub 在github 新增 repository git commit git remote add origin git@github.com:leahlin912/111.git git push -u origin master repository推上GitHub Page 建立新的branch: git branch gh-pages 推上github: git push origin gh-pages 需要注意的是首頁要命名為index.html 到[github name].github.io/[repository name]網址查看，你的網頁已經展示在這個網址。 補充說明 切換分支：git checkout &lt;branch name&gt;(切換分支的同時，新增分支git checkout -b &lt;branch name&gt;) 合併分支：git merge &lt;another branch name&gt; 更新到伺服器端：git push 補充-第一次更新到伺服器：git push -u origin master(設定預設的remote為origin ; 設定預設的branch為master)","categories":[{"name":"github","slug":"github","permalink":"http://yoursite.com/categories/github/"}],"tags":[{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"}]},{"title":"申請API憑證-以Youtube Data API為例","slug":"申請API憑證-以Youtube Data API為例","date":"2019-04-07T03:21:04.000Z","updated":"2019-04-23T16:14:40.471Z","comments":true,"path":"2019/04/07/申請API憑證-以Youtube Data API為例/","link":"","permalink":"http://yoursite.com/2019/04/07/申請API憑證-以Youtube Data API為例/","excerpt":"","text":"申請API憑證-以Youtube Data API為例流程概念 申請憑證 將key加入到專案中 申請API Key 使用google帳號，進入Google Cloud Platform(GCP) 從左上漢堡標籤，進入「API和服務&gt;資訊主頁」 點按「啟用API」按鈕 進到到API函式庫頁面，選擇要使用的API(也可以透過搜尋bar找到該API) 選擇啟用該API 頁面中提示要先「建立憑證」 依照專案需求，填寫表格 依照個人需求、必要，限制金鑰 應用程式限制：若無限制，任何人皆可在任何裝置上使用這組API金鑰；若有限制，則會進行審核，資料符合的使用者才可使用 API限制：可限制該API僅可用來獲取哪些服務Google服務，避免因使用其他服務導致流量超過配額，或被其他人用來獲取其他服務 勾選起該憑證 將Key複製到自己的專案中 將Key加入至專案中","categories":[{"name":"API","slug":"API","permalink":"http://yoursite.com/categories/API/"}],"tags":[{"name":"API","slug":"API","permalink":"http://yoursite.com/tags/API/"}]},{"title":"API金鑰的使用時機(未完)","slug":"API金鑰的使用時機(未完)","date":"2019-04-07T02:19:40.000Z","updated":"2019-04-23T15:50:24.055Z","comments":true,"path":"2019/04/07/API金鑰的使用時機(未完)/","link":"","permalink":"http://yoursite.com/2019/04/07/API金鑰的使用時機(未完)/","excerpt":"","text":"API金鑰的使用時機(未完)API金鑰 VS. 使用者憑證tokenGoogle Cloud Endpoints 能夠處理 API 金鑰與驗證機制，『API 金鑰用於專案，驗證則是用於使用者』 API 金鑰：用於識別呼叫的專案 (即應用程式或網站)，以便讓呼叫任務對應至正確的API 使用者驗證token：用於辨識使用者，即使用應用程式或網站的使用者 API金鑰API金鑰提供功能 專案識別：辨識發出API呼叫的應用程式與專案 專案授權：檢查該應用程式是否已獲得呼叫API的存取權，並且確認應用程式是否已經在專案中開啟API 使用者憑證token使用token驗證機制有兩大目的 使用者驗證：安全地驗證進行呼叫的使用者是否符合其宣稱的身分 使用者授權：檢查使用者是否擁有權限發出要求","categories":[{"name":"API","slug":"API","permalink":"http://yoursite.com/categories/API/"}],"tags":[{"name":"API","slug":"API","permalink":"http://yoursite.com/tags/API/"}]},{"title":"Bootstrap-使用Lightbox影像燈箱","slug":"Bootstrap-使用Lightbox影像燈箱","date":"2019-04-04T11:35:46.000Z","updated":"2019-04-23T15:51:12.974Z","comments":true,"path":"2019/04/04/Bootstrap-使用Lightbox影像燈箱/","link":"","permalink":"http://yoursite.com/2019/04/04/Bootstrap-使用Lightbox影像燈箱/","excerpt":"","text":"bootstrap-使用Lightbox影像燈箱什麼是Lightbox？ 網路上有多種他人設計好的燈箱插件，通常都是響應式jQuery燈箱函式庫，用來快速建立及設計漂亮的彈出式影像燈箱，優化網頁中photo gallery的展示效果。引入Lightbox 參考lightbox for bootstrap的指令，首先將cdn複製到專案中 CSS放在&lt;head&gt;中1&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/ekko-lightbox/5.3.0/ekko-lightbox.css&quot; /&gt; JS放在&lt;body&gt;結束前1&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/ekko-lightbox/5.3.0/ekko-lightbox.min.js&quot;&gt;&lt;/script&gt; 概念主要功能是點選其中一張照片，該張照片會以燈箱方式展開 結構分為兩層 外層&lt;a&gt;定義燈箱展示的照片，以及展示後的大小 內層&lt;img&gt;定義原始照片 在外層&lt;a&gt;使用bootstrap自定義的data-toggle設定啟用lightbox功能;data-lightbox將多張照片群組起來，在左右切換照片時可以辨識為同一群組的照片 最後添加jquery程式碼，避免預設效果，而採用引入的lightbox效果展示實作12345678910111213141516171819202122 &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-4&quot;&gt; &lt;a href=&quot;https://mymodernmet.com/wp/wp-content/uploads/2017/12/free-images-national-gallery-of-art-2.jpg&quot; data-toggle=&quot;lightbox&quot; data-gallery=&quot;img-gallery&quot; data-height=&quot;560&quot; data-width=&quot;560&quot;&gt; &lt;img src=&quot;https://mymodernmet.com/wp/wp-content/uploads/2017/12/free-images-national-gallery-of-art-2.jpg&quot; alt=&quot;&quot; class=&quot;img-fluid&quot;&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;col-4&quot;&gt; &lt;a href=&quot;https://mymodernmet.com/wp/wp-content/uploads/2017/12/free-images-national-gallery-of-art-3.jpg&quot; data-toggle=&quot;lightbox&quot; data-gallery=&quot;img-gallery&quot; data-height=&quot;560&quot; data-width=&quot;560&quot;&gt; &lt;img src=&quot;https://mymodernmet.com/wp/wp-content/uploads/2017/12/free-images-national-gallery-of-art-3.jpg&quot; alt=&quot;&quot; class=&quot;img-fluid&quot;&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;col-4&quot;&gt; &lt;a href=&quot;https://mymodernmet.com/wp/wp-content/uploads/2017/12/free-images-national-gallery-of-art-7.jpg&quot; data-toggle=&quot;lightbox&quot; data-gallery=&quot;img-gallery&quot; data-height=&quot;560&quot; data-width=&quot;560&quot;&gt; &lt;img src=&quot;https://mymodernmet.com/wp/wp-content/uploads/2017/12/free-images-national-gallery-of-art-7.jpg&quot; alt=&quot;&quot; class=&quot;img-fluid&quot;&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 1234$(document).on(&apos;click&apos;, &apos;[data-toggle=&quot;lightbox&quot;]&apos;, function(event) &#123; event.preventDefault(); $(this).ekkoLightbox();&#125;); 成果My Project-MoMA Museum-Collection page","categories":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/categories/Bootstrap/"}],"tags":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/tags/Bootstrap/"}]},{"title":"Bootstrap-使用輪播幻燈片Carousal","slug":"Bootstrap-使用輪播幻燈片Carousal","date":"2019-04-04T11:35:36.000Z","updated":"2019-04-23T15:52:52.080Z","comments":true,"path":"2019/04/04/Bootstrap-使用輪播幻燈片Carousal/","link":"","permalink":"http://yoursite.com/2019/04/04/Bootstrap-使用輪播幻燈片Carousal/","excerpt":"","text":"Bootstrap-使用輪播幻燈片Carousal元件結構carousal由三個小元件組成，controllers跟indicators 可以選擇性的增加 sliders controls indicators sliders 套用的class分為三層 carousal carousal-inner carousal-item .carousal為一個外層容器，在這一層添加data-ride=&quot;carousel&quot;讓輪播器自動播放。 .carousal-inner主要是讓空間寬度為全版width: 100%; .carousal-item代表一個slide的，裡面可以置放所有文字、圖片內容。在該層添加active代表輪播一開始的畫面12345678910111213&lt;div id=&quot;carouselExample&quot; class=&quot;carousel slide&quot; data-ride=&quot;carousel&quot;&gt; &lt;div class=&quot;carousel-inner&quot;&gt; &lt;div class=&quot;carousel-item active&quot;&gt; &lt;img class=&quot;d-block w-100&quot; src=&quot;img/bg1.jpg&quot; alt=&quot;First slide&quot;&gt; &lt;/div&gt; &lt;div class=&quot;carousel-item&quot;&gt; &lt;img class=&quot;d-block w-100&quot; src=&quot;img/bg2.jpg&quot; alt=&quot;Second slide&quot;&gt; &lt;/div&gt; &lt;div class=&quot;carousel-item&quot;&gt; &lt;img class=&quot;d-block w-100&quot; src=&quot;img/bg3.jpg&quot; alt=&quot;Third slide&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; controls 程式碼位置，包在carousal中 左按鈕，套用的class分為兩層 &lt;a&gt;標籤中，套用carousel-control-prev &lt;span&gt;標籤中，套用carousel-control-prev-icon 右按鈕，套用的class分為兩層 &lt;a&gt;標籤中，套用carousel-control-prev &lt;span&gt;標籤中，套用carousel-control-next-icon 在&lt;a&gt;層主要是定義按鈕的作用目的位置 href放上作用caroudal的id(也就是外層carousal的id) data-slide=&quot;prev&quot;是bootstrap自定義的屬性，用來轉換上一個或下一個項目 role＝”bottom”用來幫助殘障人士，可以借助閱讀器判斷該元件為按鈕 在&lt;span&gt;層主要就比較純粹定義按鈕的樣式 每個&lt;a&gt;中包含兩個&lt;span&gt;，一個是給一般使用者看的，另外一個是給身障人士可以透過screen reader讀取辨識的 aria-hidden=true&quot; 可以讓朗讀軟體讀不到此元件。相反的，sr-only 這個 class 是只有使用朗讀程式才可以讀取到的 1234567891011121314&lt;!-- &lt;div id=&quot;carouselExample&quot; class=&quot;carousel slide&quot; data-ride=&quot;carousel&quot;&gt; --&gt;&lt;!-- 位置放在carousal中 --&gt; &lt;a class=&quot;carousel-control-prev&quot; href=&quot;#carouselExample&quot; role=&quot;button&quot; data-slide=&quot;prev&quot;&gt; &lt;span class=&quot;carousel-control-prev-icon&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; &lt;span class=&quot;sr-only&quot;&gt;Previous&lt;/span&gt; &lt;/a&gt; &lt;a class=&quot;carousel-control-next&quot; href=&quot;#carouselExample&quot; role=&quot;button&quot; data-slide=&quot;next&quot;&gt; &lt;span class=&quot;carousel-control-next-icon&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; &lt;span class=&quot;sr-only&quot;&gt;Next&lt;/span&gt; &lt;/a&gt; &lt;!-- &lt;/div&gt; --&gt; indicators 程式碼位置，包在carousal中 使用&lt;ol&gt;及&lt;li&gt;列表結構 &lt;ol&gt;標籤中，套用carousel-indicators 每一個&lt;li&gt;標籤，就搭配到一個slide，若為預設可視的slide，class則添加active 12345678910&lt;!-- &lt;div id=&quot;carouselExample&quot; class=&quot;carousel slide&quot; data-ride=&quot;carousel&quot;&gt; --&gt;&lt;!-- 位置放在carousal中 --&gt;&lt;ol class=&quot;carousel-indicators&quot;&gt; &lt;li data-target=&quot;#carouselExample&quot; data-slide-to=&quot;0&quot; class=&quot;active&quot;&gt;&lt;/li&gt; &lt;li data-target=&quot;#carouselExample&quot; data-slide-to=&quot;1&quot;&gt;&lt;/li&gt; &lt;li data-target=&quot;#carouselExample&quot; data-slide-to=&quot;2&quot;&gt;&lt;/li&gt;&lt;/ol&gt; &lt;!-- &lt;/div&gt; --&gt; ==Use data attributes to easily control the position of the carousel. data-slide accepts the keywords prev or next, which alters the slide position relative to its current position. Alternatively, use data-slide-to to pass a raw slide index to the carousel data-slide-to=”2”, which shifts the slide position to a particular index beginning with 0.== 補：改變每一張slide停留的時間Bootstrap 預設每張幻燈片停留時間為5000毫秒(5秒)，可以用interval改變停留時間(單位為毫秒)。123$(&apos;.carousel&apos;).carousel(&#123; interval: 1000&#125;) 補：滑鼠滑入slide，不暫停輪播Bootstrap 預設當滑鼠滑入slide時，輪播會暫停，可以修改為pause:false。123$(&apos;.carousel&apos;).carousel(&#123; pause: false&#125;) 參考bootstrap部分原始碼 .carousel-inner .carousel-item .carousel-item .actice .carousel-control-prev .carousel-control-next .carousel-control-prev-icon .carousel-control-next-icon .carousel-indicators 成果My Project-LonelyPlanet-Home page-Header","categories":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/categories/Bootstrap/"}],"tags":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/tags/Bootstrap/"},{"name":"carousal","slug":"carousal","permalink":"http://yoursite.com/tags/carousal/"}]},{"title":"建立boiler樣板(下)-引入Font Awesome","slug":"建立boiler樣板(下)-引入Font Awesome","date":"2019-04-04T10:15:42.000Z","updated":"2019-04-23T16:14:24.817Z","comments":true,"path":"2019/04/04/建立boiler樣板(下)-引入Font Awesome/","link":"","permalink":"http://yoursite.com/2019/04/04/建立boiler樣板(下)-引入Font Awesome/","excerpt":"","text":"建立boiler樣板(下)-引入Font Awesome什麼是Font Awesome？ 用於網頁中加入icon的圖示庫，原理是把圖示icon都製作成文字的字型(fonts)，再透過CSS的去呼叫icon顯示出來。 相較於載入一張圖片，loading的負擔較低 可以透過指令放大縮小，不會造成像素失真的問題引入fontawesome 進入fontawesome的「start」頁面 將cdn複製貼上到&lt;head&gt;中 &lt;link rel=&quot;stylesheet&quot; href=&quot;https://use.fontawesome.com/releases/v5.8.1/css/all.css&quot; integrity=&quot;sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf&quot; crossorigin=&quot;anonymous&quot;&gt; 即可開始使用","categories":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/categories/Bootstrap/"}],"tags":[{"name":"awesomefont","slug":"awesomefont","permalink":"http://yoursite.com/tags/awesomefont/"},{"name":"library","slug":"library","permalink":"http://yoursite.com/tags/library/"},{"name":"boiler","slug":"boiler","permalink":"http://yoursite.com/tags/boiler/"}]},{"title":"建立boiler樣板(上)-引入Bootstrap","slug":"建立boiler樣板(上)-引入Bootstrap","date":"2019-04-04T10:15:30.000Z","updated":"2019-04-23T16:13:37.498Z","comments":true,"path":"2019/04/04/建立boiler樣板(上)-引入Bootstrap/","link":"","permalink":"http://yoursite.com/2019/04/04/建立boiler樣板(上)-引入Bootstrap/","excerpt":"","text":"建立boiler樣板(上)-引入Bootstrap創建資料夾結構 先新增一個資料夾 再用vscode開啟該資料夾，並建立起資料夾結構12345boiler|_index.html|_img|_css |_style.css 將index.html與style.css檔做連結 引入bootstrapCSS 進入bootstrap網站「Get Start」頁面，將CSS stylesheet連結放在&lt;head&gt;的中，放置於所有stylesheet的最上方 1&lt;link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css\" integrity=\"sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T\" crossorigin=\"anonymous\"&gt; JS 進入bootstrap網站「Get Start」頁面，將JS的plugin 放在&lt;/body&gt;結束前12&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js\" integrity=\"sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js\" integrity=\"sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; jQuery 進入jQuery頁面，將最新版本的minified複製放在&lt;/body&gt;結束前 1234&lt;script src=\"http://code.jquery.com/jquery-3.3.1.min.js\" integrity=\"sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;","categories":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/categories/Bootstrap/"}],"tags":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/tags/Bootstrap/"},{"name":"boiler","slug":"boiler","permalink":"http://yoursite.com/tags/boiler/"}]},{"title":"Font Awesome-使用免費icon","slug":"Font Awesome-使用免費icon","date":"2019-04-04T10:13:54.000Z","updated":"2019-04-23T16:18:17.761Z","comments":true,"path":"2019/04/04/Font Awesome-使用免費icon/","link":"","permalink":"http://yoursite.com/2019/04/04/Font Awesome-使用免費icon/","excerpt":"","text":"Font Awesome-使用免費icon引入Font Awesome 參考文章：建立boiler樣板-(下)引入Font Awesome使用icon 在fontawesome的gaooery找到適合的icon 將&lt;i&gt;整段複製到要使用的html檔中 調整為不同尺寸(optional) 調整為不同顏色(optional) 實作1234567891011&lt;i class=&quot;fas fa-eye&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fas fa-eye-slash&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fas fa-thumbs-up fa-3x&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fas fa-thumbs-down fa-3x&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fab fa-gratipay fa-3x&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fas fa-comment fa-3x&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fab fa-youtube fa-5x&quot; style=&quot;color:#FF0000&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fab fa-line fa-5x&quot; style=&quot;color:#00c300&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fab fa-facebook-square fa-5x&quot; style=&quot;color:#3b5998&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fab fa-facebook-messenger fa-5x&quot; style=&quot;color:#0884F9&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fab fa-instagram fa-5x&quot; style=&quot;color:#BB2C8A&quot;&gt;&lt;/i&gt;","categories":[{"name":"library","slug":"library","permalink":"http://yoursite.com/categories/library/"}],"tags":[{"name":"awesomefont","slug":"awesomefont","permalink":"http://yoursite.com/tags/awesomefont/"}]},{"title":"Slick-快速打造一個carousel","slug":"Slick-快速打造一個carousel","date":"2019-04-04T09:18:10.000Z","updated":"2019-04-23T16:09:31.343Z","comments":true,"path":"2019/04/04/Slick-快速打造一個carousel/","link":"","permalink":"http://yoursite.com/2019/04/04/Slick-快速打造一個carousel/","excerpt":"","text":"Slick-快速打造一個carouselSlick是什麼？提供多種輪播樣式，以多組圖片輪播切換的套件，可應用於更多張圖片的展示。附上原始碼，複製貼上，即可使用現成的sliders樣式。 操作流程 引入slick cdn CSS搜尋slick cdn，找到slick-carousel cdn資源，將slick.css及slick-theme.css主題樣式複製到&lt;head&gt;中12&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/slick-carousel/1.9.0/slick.css&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/slick-carousel/1.9.0/slick-theme.css&quot; /&gt; JS再將slick.js複製到&lt;/body&gt;結束前且jquery後1&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/slick-carousel/1.9.0/slick.js&quot;&gt;&lt;/script&gt; 先在html建立好carousel的內容結構，並在外層給予一個class作為標記12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;div class=&quot;slider&quot;&gt; &lt;div&gt;slide 1&lt;/div&gt; &lt;div&gt;slide 2&lt;/div&gt; &lt;div&gt;slide 3&lt;/div&gt; &lt;div&gt;slide 4&lt;/div&gt; &lt;div&gt;slide 5&lt;/div&gt;&lt;/div&gt;``` 4. 進入[slick](http://kenwheeler.github.io/slick/)，選擇sliders樣式，複製下方的語法到`&lt;body&gt;&lt;script&gt;`中![](https://i.imgur.com/3VT5R1U.png)### optional控制元素* **arrows**: (boolean值)是否顯示左右箭頭功能* **dots**:(boolean值)是否顯示下方小圓點功能* **autoplay**：(boolean值)是否自動播放* **autoplaySpeed**:(毫秒值)自動播放的速度* **slidesToShow**:(數量值)一次主要顯現幾個slides* **slidesToScroll**:(數量值)每次滑動幾張slides* **fade**:(boolean值)是否採用淡出/淡入效果* **infinite**：(boolean值)滑到最後一張，是否繼續從回到一開始同向循環(4&gt;1&gt;2&gt;3&gt;...)，或是逆轉向循環(4&gt;3&gt;2&gt;...)* **centerMode**:(boolean值)是否同時顯現前後兩張slide的部分內容* **centerPadding**:(px值)搭配`centerMode:true`使用，表示前後兩張slide要顯現多少範圍* **responsive**:(陣列)針對不同尺寸做額外設定 * **breakpoint**:(螢幕尺寸) * **settings**:(&#123;物件&#125;)包含各種設定### 實作```htmlmixed= &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;slider&quot;&gt; &lt;div class=&quot;slide-1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;slide-2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;slide-3&quot;&gt;&lt;/div&gt; &lt;div class=&quot;slide-4&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; &lt;script&gt; $(&apos;.slider&apos;).slick(&#123; centerMode:true, centerPadding: &apos;100px&apos;, slidesToShow: 1, slidesToScroll: 1, autoplaySpeed: 2000, dots: true, arrows: true, &#125;); &lt;/script&gt; 成果My Project-LonelyPlanet-About page","categories":[{"name":"library","slug":"library","permalink":"http://yoursite.com/categories/library/"}],"tags":[{"name":"library","slug":"library","permalink":"http://yoursite.com/tags/library/"},{"name":"carousel","slug":"carousel","permalink":"http://yoursite.com/tags/carousel/"},{"name":"Slick","slug":"Slick","permalink":"http://yoursite.com/tags/Slick/"}]},{"title":"CSS-常見display屬性的值","slug":"CSS-常見display屬性的值","date":"2019-04-04T01:15:38.000Z","updated":"2019-04-23T16:00:00.999Z","comments":true,"path":"2019/04/04/CSS-常見display屬性的值/","link":"","permalink":"http://yoursite.com/2019/04/04/CSS-常見display屬性的值/","excerpt":"","text":"CSS-常見display屬性的值display: none display設為none這個東西就不見了，不佔空間。 補充：visibility:hidden是隱形看不見，不過還是有佔空間。 display: inline display : inline 的元素連在一起會在同一行，「不會換行」。 要讓 display : inline 元素水平置中的方式是在此元素的父元素加上 text-align : center。 &lt;a&gt;、&lt;span&gt;、&lt;b&gt;、&lt;i&gt;、&lt;iframe&gt;、&lt;img&gt;這幾個 HTML 元素預設的 display 屬性是 inline 可以針對左右做縮排(margin-left 、 margin-right 、 padding-left 、 padding-right「有效」) 上下縮排會失效，且寬高為內容本身寬高，無法自定義寬高。 (margin-top 、 margin-bottom 、 padding-top 、 padding-bottom 、 width 、 height 、 background-image 皆「無效」) display: block 不論前後元素為何，display:block 元素會直接「換行」開始。 &lt;div&gt;、&lt;p&gt;、&lt;h1&gt;、&lt;h2&gt;、&lt;iframe&gt;、&lt;img&gt;這幾個 HTML 元素預設的 display 屬性是 block 可以自定義寬高或縮排(margin 、 padding 、 width 、 height 、 background-image 皆「有效」) display: inline-block 內部元素水平排列，而且不需要額外設定clear，也不會讓接著的元素疊上來。 可以理解為：外面是inline，裡面是block。所以元素「不會換行」，但是又可以設定元素的padding-top 、 padding-bottom 、 width 、 height 、 background-image 。","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"layout","slug":"layout","permalink":"http://yoursite.com/tags/layout/"}]},{"title":"Bootstrap-排版Grid system","slug":"Bootstrap-排版Grid system","date":"2019-04-03T22:11:56.000Z","updated":"2019-04-23T15:52:43.276Z","comments":true,"path":"2019/04/04/Bootstrap-排版Grid system/","link":"","permalink":"http://yoursite.com/2019/04/04/Bootstrap-排版Grid system/","excerpt":"","text":"Bootstrap-排版Grid system概念 Bootstrap的排版是使用css flexbox 結構上要分為兩層： 外層為row： 內層為一到多個col- row容器就是一個flexbox Bootstrap的概念是將row容器中，一行分成12等分 col-後面接的數字，就是在一行中，佔有幾個「1/12的空間」。例：col-3就代表佔了3/12的寬度空間 針對不同尺寸螢幕，可以定義各種尺寸的佔有空間。例：col-lg-3, col-sm-6會在lg size時佔有3/12，而在sm size時佔有6/12 如果一行中有兩欄，其加總空間未滿12/12，可以用offset製造空欄的效果。12345&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-lg-3 col-sm-4&quot;&gt;col-lg-3 col-sm-4&lt;/div&gt; &lt;div class=&quot;col-lg-5 col-sm-4&quot;&gt;col-lg-5 col-sm-4&lt;/div&gt; &lt;div class=&quot;col-lg-2 col-lg-offset col-sm-4&quot;&gt;col-lg-2 col-lg-offset col-sm-4&lt;/div&gt; &lt;/div&gt; 實作 Large時，一排四個 Medium時，一排兩個 Extra small時，一排一個12345678&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-lg-3 col-md-6&quot;&gt; &lt;div class=&quot;col-lg-3 col-md-6&quot;&gt; &lt;div class=&quot;col-lg-3 col-md-6&quot;&gt; &lt;div class=&quot;col-lg-3 col-md-6&quot;&gt; &lt;div class=&quot;col-lg-3 col-md-6&quot;&gt; &lt;div class=&quot;col-lg-3 col-md-6&quot;&gt;&lt;/div&gt; 成果My Project-LonelyPlanet-Author section","categories":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/categories/Bootstrap/"}],"tags":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/tags/Bootstrap/"},{"name":"grid","slug":"grid","permalink":"http://yoursite.com/tags/grid/"}]},{"title":"Bootstrap-展開Collapse & Accordion","slug":"Bootstrap-展開Collapse & Accordion","date":"2019-04-03T03:26:30.000Z","updated":"2019-04-23T15:51:48.123Z","comments":true,"path":"2019/04/03/Bootstrap-展開Collapse & Accordion/","link":"","permalink":"http://yoursite.com/2019/04/03/Bootstrap-展開Collapse & Accordion/","excerpt":"","text":"Bootstrap-展開Collapse &amp; Accordion概念 給予一個button 在collapse-content(事件作用目標物)上面給予一個id 在button標籤中，用bootstrap自訂屬性data-toggle定義觸發事件，以及與data-target定義作用的目標物 Collapse實作 預設值為關閉collapse狀態，若要預設為展開開狀態，可以添加show12345678&lt;div class=&quot;card&quot;&gt; &lt;button data-toggle=&quot;collapse&quot; data-target=&quot;#collapse1&quot;&gt; Button 1 &lt;/button&gt; &lt;div id=&quot;collapse1&quot; class=&quot;collapse&quot; Collapse-content-1 &lt;/div&gt;&lt;/div&gt; Accordion12345678910111213141516171819202122232425262728293031323334353637&lt;div id=&quot;accordion&quot;&gt; &lt;div class=&quot;card&quot;&gt; &lt;div class=&quot;card-header&quot;&gt; &lt;div href=&apos;#collapse1&apos; data-toggle=&quot;collapse&quot; data-parent=&quot;#accordion&quot;&gt; Button 1 &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;collapse1&quot; class=&quot;collapse show&quot;&gt; &lt;div class=&quot;card-body&quot;&gt; Collapse-content-1 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;card&quot;&gt; &lt;div class=&quot;card-header&quot;&gt; &lt;div href=&apos;#collapse1&apos; data-toggle=&quot;collapse&quot; data-parent=&quot;#accordion&quot;&gt; Button 2 &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;collapse2&quot; class=&quot;collapse&quot;&gt; &lt;div class=&quot;card-body&quot;&gt; Collapse-content-2 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;card&quot;&gt; &lt;div class=&quot;card-header&quot;&gt; &lt;div href=&apos;#collapse3&apos; data-toggle=&quot;collapse&quot; data-parent=&quot;#accordion&quot;&gt; Button 3 &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;collapse1&quot; class=&quot;collapse&quot;&gt; &lt;div class=&quot;card-body&quot;&gt; Collapse-content-3 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 成果My Project-LonelyPlanet-Mission section","categories":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/categories/Bootstrap/"}],"tags":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/tags/Bootstrap/"}]},{"title":"CSS-用hover選擇器增加滑鼠互動效果","slug":"CSS-用hover選擇器增加滑鼠互動效果","date":"2019-04-03T02:52:02.000Z","updated":"2019-04-23T16:00:46.143Z","comments":true,"path":"2019/04/03/CSS-用hover選擇器增加滑鼠互動效果/","link":"","permalink":"http://yoursite.com/2019/04/03/CSS-用hover選擇器增加滑鼠互動效果/","excerpt":"","text":"CSS-用hover選擇器增加滑鼠互動效果原理 先設定元件的初始樣式 再用css選擇器，添加:hover，並定義滑鼠移過的樣式 實作12345678.card&#123; color: #6C757D ; background-color: #ffffff;&#125;.card:hover&#123; color: #fff; background-color: #f2ac34;&#125; 成果My Project-LonelyPlanet-Author section 補充 hover經常被用在&lt;a&gt;標籤上 123a:hover&#123; background-color:yellow;&#125; 其他a標籤的連結效果 1234a:link &#123;color:blue;&#125;a:visited &#123;color:blue;&#125;a:hover &#123;color:red;&#125;a:active &#123;color:yellow;&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"Html-一頁式網頁使用href滑頁","slug":"Html-一頁式網頁使用href滑頁","date":"2019-04-03T02:20:16.000Z","updated":"2019-04-23T16:04:32.490Z","comments":true,"path":"2019/04/03/Html-一頁式網頁使用href滑頁/","link":"","permalink":"http://yoursite.com/2019/04/03/Html-一頁式網頁使用href滑頁/","excerpt":"","text":"Html-一頁式網頁使用href滑頁原理 在每個區塊div設定id，讓 在menu的項目中設定每個項目的href目的位置為區塊div的id 用jquery增加scroller效果 實作 menu中的item使用&lt;a&gt;標籤，並將href設定為目標section的#id1234567891011&lt;ul class=&quot;navbar-nav&quot;&gt; &lt;li&gt; &lt;a href=&quot;#section1&quot;&gt;item 1&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#section2&quot;&gt;item 2&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#section3&quot; &gt;item 3&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; 123&lt;div id=&quot;section1&quot;&gt;&lt;/div&gt;&lt;div id=&quot;section2&quot;&gt;&lt;/div&gt;&lt;div id=&quot;section3&quot;&gt;&lt;/div&gt; 在body標籤中新增id 1&lt;body data-spy=&quot;scroll&quot; data-target=&quot;#main-nav&quot; id=&quot;home&quot;&gt; 用jQuery初始化scrollspy 1$(&apos;body&apos;).scrollspy(&#123; target:&apos;#mail-nav&apos;&#125;); 添加Smooth Scrolling 所有在#main-nav中的&lt;a&gt;被click，就會執行函式1234567891011121314151617$(&apos;#main-nav a&apos;).on(&apos;click&apos;,function(event)&#123;&lt;!--check for a hash value --&gt; if(this.hash !==&quot;&quot;)&#123; &lt;!-- prevent default behavior --&gt; event.preventDefault(); &lt;!-- Store hash --&gt; const hash = this.hash; $(&apos;html,body&apos;).animate(&#123; scrollTop: $(hash).offset().top &#125;, 800, function()&#123;&lt;!-- Add hush to URL after scroll --&gt; window.location.hash = hash; &#125;) &#125;&#125;) 成果My Project-LonelyPlanet","categories":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/categories/HTML/"}],"tags":[{"name":"實作","slug":"實作","permalink":"http://yoursite.com/tags/實作/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"Bootstrap-自定義重新設定Sass","slug":"Bootstrap-自定義重新設定Sass","date":"2019-04-03T01:39:56.000Z","updated":"2019-04-23T15:54:30.545Z","comments":true,"path":"2019/04/03/Bootstrap-自定義重新設定Sass/","link":"","permalink":"http://yoursite.com/2019/04/03/Bootstrap-自定義重新設定Sass/","excerpt":"","text":"Bootstrap-自定義重新設定Sass用koala設定 在專案資料夾中新增scss資料夾，以及style.scss檔案 進入Bootstrap-download，下載Source files 下載解壓縮後，將所有下載的scss資料夾中的所有檔案複製到自己專案的scss資料夾中 下載koala 用koala打開專案資料夾，取消不必被compile的項目 將bootstrap.scss重新輸出路徑到專案的css資料夾中，並且再回到koala執行Compile。Compile之後，就可以看到bootstrap.css出現在專案中 style.scss也重複上述動作，輸出路徑可以覆蓋原先css中的style.css檔案，一樣再執行Compile 用vscode打開專案，將舊的「bootstrap.css」與「style.css」刪除 在index.html中，重新設定bootstrap的引入設定，指定為專案中的bootstrap.css 在scss檔案中即可修改設定","categories":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/categories/Bootstrap/"}],"tags":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/tags/Bootstrap/"},{"name":"Sass","slug":"Sass","permalink":"http://yoursite.com/tags/Sass/"}]},{"title":"Bootstrap-自適應navbar","slug":"Bootstrap-自適應navbar","date":"2019-04-02T23:53:46.000Z","updated":"2019-04-23T15:54:45.581Z","comments":true,"path":"2019/04/03/Bootstrap-自適應navbar/","link":"","permalink":"http://yoursite.com/2019/04/03/Bootstrap-自適應navbar/","excerpt":"","text":"Bootstrap-自適應navbar概念 透過navbar-expand定義在何種尺寸，menu項目的呈現會改為「漢堡折疊」樣式效果 使用bootstrap自定義的data-toggle及data-target，決定按鈕點下之後，menu的div要以collapse方式展開實作 首先class套用navbar，預設讓它是一個dispaly:flex的彈性盒子，且內部item會水平置中對齊(可以參考bootstrap的原始碼查看css設定) navbar-expand-sm則是決定當螢幕尺寸小於sm時，會改為以「折疊漢堡」顯示menu項目;若從頭到尾都希望以「折疊漢堡」顯示，則不要在class使用任何navbar-expand 如果希望navbar不會受瀏覽頁面捲動而消失，會一直顯示在最上方，則在class加上fixed-top button就是畫面中的「漢堡折疊」，需套用navbar-toggler類。基本上就會被navbar-expand-sm的定義影響在什麼螢幕尺寸顯示，什麼尺寸隱藏(可以參考bootstrap的原始碼查看css設定) data-toggle是bootstrap自訂的屬性data-toggle=&quot;collapse&quot;，意思是當點擊它按鈕時，會觸發了”collapse”事件 data-target也是bootstrap自訂的屬性，當”collapse”事件觸發，它的目標是#navbarCollapse，所以下面的#navbarCollapse這個div就會展開。 #navbarCollapse這個div的class需套用collapse、navbar-collapse，基本上也就是會被navbar-expand-sm的定義影響在什麼螢幕尺寸顯示，什麼尺寸隱藏。 123456789101112131415161718192021222324&lt;nav id=&quot;main-nav&quot; class=&quot;navbar navbar-expand-sm navbar-dark fixed-top&quot; style=&quot;background-color:#24243c;&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;a href=&quot;index.html&quot; class=&quot;navbar-brand&quot;&gt;LonelyPlanet&lt;/a&gt; &lt;button class=&quot;navbar-toggler&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#navbarCollapse&quot;&gt; &lt;span class=&quot;navbar-toggler-icon&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;div id=&quot;navbarCollapse&quot; class=&quot;collapse navbar-collapse&quot; &gt; &lt;ul class=&quot;navbar-nav ml-auto&quot;&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a href=&quot;#home-section&quot; class=&quot;nav-link&quot;&gt;Home&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a href=&quot;#explore-head-section&quot; class=&quot;nav-link&quot;&gt;Explore&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a href=&quot;#author-head-section&quot; class=&quot;nav-link&quot;&gt;Author&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a href=&quot;#mission-head-section&quot; class=&quot;nav-link&quot;&gt;Mission&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/nav&gt; 參考bootstrap部分原始碼 navbar navbar-expand-sm narvar-collapse narvar-toggler 成果My Project-LonelyPlanet-Menu","categories":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/categories/Bootstrap/"}],"tags":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/tags/Bootstrap/"},{"name":"navbar","slug":"navbar","permalink":"http://yoursite.com/tags/navbar/"}]},{"title":"CSS-文字向左右對齊，並垂直置中","slug":"CSS-文字向左右對齊，並垂直置中","date":"2019-04-02T08:50:02.000Z","updated":"2019-04-23T16:00:16.520Z","comments":true,"path":"2019/04/02/CSS-文字向左右對齊，並垂直置中/","link":"","permalink":"http://yoursite.com/2019/04/02/CSS-文字向左右對齊，並垂直置中/","excerpt":"","text":"CSS-文字向左右對齊，並垂直置中目標效果 方法一 將外層容器定義為flex容器，且其中的items向容器中間對齊 定義外層容器中的item與item之間保持相同的空間距離 實作方法一12345678&lt;div class=&quot;header&quot;&gt; &lt;div class=&quot;left&quot;&gt; 我是左邊文字 &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; 我是右邊文字內容 &lt;/div&gt;&lt;/div&gt; 12345.header&#123; display: inline-flex; align-items: center; justify-content: space-between;&#125; 補充：當定義元素為彈性容器，而它的子元素們就會變成彈性項目。 flex 值會讓彈性容器變成塊級元素（block-level element） inline-flex 則會讓彈性容器成為單一的行內元素（atomic inline-level element）。 方法二 定義外層容器為彈性容器 定義內層item的寬度佔比為1:1填滿整個容器 內層item的文字各自靠左及靠右實作方法二123456789101112.header&#123; display: flex; align-items: center;&#125;.left&#123; flex: 1; text-align: left;&#125;.right&#123; flex: 1; text-align: right;&#125; 成果My Project-Profile-Projects page","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"實作","slug":"實作","permalink":"http://yoursite.com/tags/實作/"},{"name":"layuot","slug":"layuot","permalink":"http://yoursite.com/tags/layuot/"}]},{"title":"CSS-由左到右、由右到左，利用direction-reserve排版","slug":"CSS-由左到右、由右到左，利用direction-reserve排版","date":"2019-04-02T08:49:50.000Z","updated":"2019-04-23T16:01:01.074Z","comments":true,"path":"2019/04/02/CSS-由左到右、由右到左，利用direction-reserve排版/","link":"","permalink":"http://yoursite.com/2019/04/02/CSS-由左到右、由右到左，利用direction-reserve排版/","excerpt":"","text":"CSS-由左到右、由右到左，利用direction-reserve排版 概念 定義外層容器為一個靈活盒子 使用flex-direction定義「由右到左」、「由左到右」的兩種排版類別 兩種排版交互使用實作 定義外層容器display: flex flex-direction:row:row方向預設值為「由左到右」 flex-direction:row-reverse:方向反轉則為「由右到左」1234567891011121314&lt;div class=&quot;pieces-group&quot;&gt; &lt;div class=&quot;piece content-right&quot;&gt; &lt;div class=&quot;piece-photo&quot;&gt;&lt;/div&gt; &lt;div class=&quot;piece-content&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;piece content-left&quot;&gt; &lt;div class=&quot;piece-photo&quot;&gt;&lt;/div&gt; &lt;div class=&quot;piece-content&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;piece content-right&quot;&gt; &lt;div class=&quot;piece-photo&quot;&gt;&lt;/div&gt; &lt;div class=&quot;piece-content&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123456789.piece&#123; display: flex;&#125;.content-right&#123; flex-direction:row;&#125;.content-left&#123; flex-direction:row-reverse;&#125; 定義小螢幕尺寸時，容器內的items方向為column「由上到下」12345@media screen and (max-width: 994px)&#123; #projects-section .piece&#123; flex-direction:column; &#125;&#125; 成果My Project-Profile-Education page","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"layout","slug":"layout","permalink":"http://yoursite.com/tags/layout/"},{"name":"實作","slug":"實作","permalink":"http://yoursite.com/tags/實作/"}]},{"title":"CSS-使用Flexbox，垂直置中float元素","slug":"CSS-使用Flexbox，垂直置中float元素","date":"2019-04-02T06:13:10.000Z","updated":"2019-04-23T15:57:07.944Z","comments":true,"path":"2019/04/02/CSS-使用Flexbox，垂直置中float元素/","link":"","permalink":"http://yoursite.com/2019/04/02/CSS-使用Flexbox，垂直置中float元素/","excerpt":"","text":"CSS-使用Flexbox，垂直置中float元素目標效果讓兩個浮動元素，可以垂直對齊 原始情況放置兩個浮動元素，它們各自都向上靠其所在的容器12&lt;div class=&quot;box1&quot;&gt;box1&lt;/div&gt;&lt;div class=&quot;box2&quot;&gt;box2&lt;/div&gt; 123456789101112131415.margin&#123; margin-top:50px;&#125;.box1&#123; width:200px; background: #F0780D; height:100px; float:left;&#125;.box2&#123; width:300px; background: #F0C7B2; height:50px; float:right;&#125; 作法在外層容器中，使用display: flex，並且置中12345.container&#123; margin-top:50px; display: flex; align-items: center;&#125; 垂直對齊vertical-align: middle無效在css官方文件中說明：“vertical-align屬性，僅能使用於inline 或 table-cell box”，所以flaot元素無法使用此方法 1234&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;box1&quot;&gt;box1&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;box2&lt;/div&gt;&lt;/div&gt; 123.container&#123; vertical-align: middle;&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"layout","slug":"layout","permalink":"http://yoursite.com/tags/layout/"}]},{"title":"CSS-刻出一個timeline","slug":"CSS-刻出一個timeline","date":"2019-04-02T03:57:24.000Z","updated":"2019-04-23T15:58:32.370Z","comments":true,"path":"2019/04/02/CSS-刻出一個timeline/","link":"","permalink":"http://yoursite.com/2019/04/02/CSS-刻出一個timeline/","excerpt":"","text":"CSS-刻出一個timeline概念 設定一個最外層div空間 直線：利用偽元素(Pseudo Element)」::after的繼承特性，會繼承原本元素的屬性，畫出一個與空間一樣高的元素。定義該偽元素的邊框，製作出直線的效果。並且運用絕對定位，讓直線可以定位在中間。 時間文字：在卡片前後各自放上時間開始、結束時間的div空間 時間圓圈：利用偽元素::before繪製出，以「時間文字」座位定位參考點，使用絕對定位讓兩這位置呈現水平對齊。 卡片：最後再針對自己的喜好定義卡片的樣式 若要製作出左右交叉的效果，再使用class分類針對左右交叉的卡片各自做定位定義 最後在針對小螢幕，使用＠medis定義位置、樣式 實現 html佈局：參考要呈現畫面的效果，由上到下規劃好div空間 123456789101112&lt;div class=&quot;timeline-section&quot;&gt; &lt;div class=&quot;container left&quot;&gt; &lt;div class=&quot;time&quot;&gt; &lt;span&gt;2019 MAR&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;card&quot;&gt; &lt;/div&gt; &lt;div class=&quot;time&quot;&gt; &lt;span&gt;2019 FEB&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; timeline-section因為最外層的timeline-section空間，將被用來作偽元素timeline的定位基準點，所以切記要定義position屬性 1234.timeline-section&#123; position: relative; background-color: #EDEEF0;&#125; timeline 使用偽元素::after，製作出一個timeline元素 其定位方式為絕對定位position: absolute，才可以製作出元素重疊的效果(畫面中呈現，timeline::after是重疊在timeline-section上方) 使用top、left、bottom、right定位 使用height: 100%，是強制它的高度跟一樣高 定義border，繪製出線條 因為我們運用這個偽元素只是要用邊框製造出線條，其中並不會放置內容物，所以content屬性定義為空 若想製作出實心效果，定義width為0;相反地，如果想要有空心效果，可以定義為其他數值，也可以定義background-color填充中間的色彩1234567891011.timeline::after&#123; position: absolute; top:0; height: 100%; left:50%; border:3px solid #56332e; content:''; width: 0px; background-color: #56332e; margin-left: -3px;&#125; time因為time會被內層元素用來做定位，所以切記要定義position屬性 12345678910.time&#123; position: relative; width: 120px; font-weight: bolder; &#125;.time span,&#123; color: #56332e; position: absolute; top:-10px;&#125; 時間圓圈 使用偽元素::before，製作出一個元素 其定位方式為絕對定位position: absolute，才可以製作出元素重疊的效果 為了確保出現在最上層，可以定義z軸 定義該空間的寬高 繪製該空間邊框border、圓角border-radius 因為我們運用這個偽元素只是要用邊框製造出線條，其中並不會放置內容物，所以content屬性定義為空12345678910.time span:before&#123; position: absolute; z-index: 1; width: 25px; height: 25px; border: 4px solid #56332e; border-radius: 50%; background-color: white; content:'';&#125; card依個人喜好，定義好卡片的樣式 1234567.card&#123; padding:20px 5px; background-color: #fff; border: none; color: #56332e; box-shadow: 0px 1px 15px rgba(86, 51, 46, 0.6);&#125; 左右交叉 額外在html中給予right、left類別 利用css選擇器，針對左右的卡片的內容物，給予不同的定義12345678910111213141516171819202122&lt;div class=&quot;timeline-section&quot;&gt; &lt;div class=&quot;container left&quot;&gt; &lt;div class=&quot;time&quot;&gt; &lt;span&gt;2019 MAR&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;card&quot;&gt; &lt;/div&gt; &lt;div class=&quot;time&quot;&gt; &lt;span&gt;2019 FEB&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;container right&quot;&gt; &lt;div class=&quot;time&quot;&gt; &lt;span&gt;2019 MAR&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;card&quot;&gt; &lt;/div&gt; &lt;div class=&quot;time&quot;&gt; &lt;span&gt;2019 FEB&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011121314.left .content&#123; padding-right:15px; left:0;&#125;.left .time&#123; left:50%;&#125;.left .time span:before&#123; text-align: left; left: -30px;&#125;.left .time span&#123; left:18px;&#125; 12345678910111213141516.right .content&#123; padding-left:15px; left:50%;&#125;.right .time&#123; left: 50%;&#125;.right .time span:before&#123; text-align: right; left: 80px;&#125;.right .time span &#123; left:-92px;&#125; 針對小螢幕做調整如果螢幕尺寸低於380px，就套用以下設定 註：如果針對「(max-width: 576px)」有額外定義，程式碼需寫在上方，數字越大，要先寫123456789101112131415161718192021222324252627282930313233343536373839@media screen and (max-width: 380px)&#123; .timeline::after&#123; left:60px; &#125; #timeline-section .container&#123; padding-left: 10px; &#125; #timeline-section .left .content, #timeline-section .right .content&#123; width: 70%; left:25%; text-align: left; &#125; #timeline-section .left .time, #timeline-section .right .time&#123; left:30px; right: 0; width: 10px; text-align: right; line-height: 15px; font-size: 12px; &#125; #timeline-section .left .time span, #timeline-section .right .time span &#123; left:-30px; &#125; #timeline-section .right .time span:before,#timeline-section .left .time span:before&#123; text-align: right; left: 40px; &#125; #timeline-section .right .time span:before, #timeline-section .left .time span:before&#123; content:''; position: absolute; width: 20px; height: 20px; background-color: white; border: 3px solid #2B6073; border-radius: 50%; z-index: 1; &#125;&#125; 成果My Project-Profile-Programing section","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"layout","slug":"layout","permalink":"http://yoursite.com/tags/layout/"},{"name":"偽元素","slug":"偽元素","permalink":"http://yoursite.com/tags/偽元素/"},{"name":"實作","slug":"實作","permalink":"http://yoursite.com/tags/實作/"}]},{"title":"CSS-圖片邊框","slug":"CSS-圖片邊框","date":"2019-04-02T01:00:40.000Z","updated":"2019-04-23T15:59:18.462Z","comments":true,"path":"2019/04/02/CSS-圖片邊框/","link":"","permalink":"http://yoursite.com/2019/04/02/CSS-圖片邊框/","excerpt":"","text":"CSS-圖片邊框概念分為兩層div空間 先定義下方piece空間的邊框角度 再定義上方piece-photo空間的邊框角度 最後定義上方piece-photo的背景，用background-imgage屬性引入圖片 實作外層：定義外層div空間的寬高、原角邊框等樣式設定內層： 先定義「內層空間的寬高」、原角邊框 background-image引入圖片之後，要定義「被引入圖片的寬高」、定位等設定 補充：更多圖片屬性設定參考 html&amp;CSS-插入(背景)圖片的作法-從css選擇器中定義背景123&lt;div class=&quot;piece&quot;&gt; &lt;div class=&quot;piece-photo&quot;&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516.piece&#123; width: 300px; background-color:white; border-radius: 0.25rem; &#125;.piece-photo&#123; background-size: 300px; border-top-left-radius: 0.25rem; border-top-right-radius: 0.25rem; background-image: url(\"../img/meal1.jpg\"); background-position: 50% 50%; background-attachment: scroll; width: 300px; height: 200px;&#125; 成果My Project-Profile-Education page","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"實作","slug":"實作","permalink":"http://yoursite.com/tags/實作/"}]},{"title":"CSS-設置背景overlay","slug":"CSS-設置背景overlay","date":"2019-04-02T00:59:32.000Z","updated":"2019-04-23T16:01:20.428Z","comments":true,"path":"2019/04/02/CSS-設置背景overlay/","link":"","permalink":"http://yoursite.com/2019/04/02/CSS-設置背景overlay/","excerpt":"","text":"CSS-設置背景overlay概念將「下方圖片」、「上方覆蓋色塊」分為兩層(兩個div) 外層的背景為一張圖片 內層的背景為透明色彩 註：外層div會先畫，因此在畫面會呈現在下方;相反的，內層div會後畫，在畫面中會呈現蓋在上方 實作最外層div的背景使用一張圖片(background-image屬性)，內層div的背景使用rgba的透明色彩123&lt;div cless=&quot;section&quot;&gt; &lt;div class=&quot;white-overlay&quot;&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011.section&#123; background-image: url(\"../img/education-bg.jpg\"); background-repeat: no-repeat ; background-size: cover; background-attachment: fixed; min-height: 1200px;&#125;.white-overlay&#123; background-color: rgba(255, 255, 255, 0.3); min-height: 1200px;&#125; 成果My Project-Profile-Notes page","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"實作","slug":"實作","permalink":"http://yoursite.com/tags/實作/"}]},{"title":"CSS-置中(align-items＆justify-content)","slug":"CSS-置中(align-items＆justify-content)","date":"2019-04-02T00:10:56.000Z","updated":"2019-04-23T16:01:12.064Z","comments":true,"path":"2019/04/02/CSS-置中(align-items＆justify-content)/","link":"","permalink":"http://yoursite.com/2019/04/02/CSS-置中(align-items＆justify-content)/","excerpt":"","text":"CSS-置中(align-items＆justify-content)用flex完成內容垂直置中 flex屬性解釋連結：在容器中分配並行空間(flex) 參考置中作法 display屬性為flex 透過align-items屬性，控制垂直定位 透過justify-content，控制水平定位12345.box&#123; display:flex; align-items: center; justify-content: center;&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"layout","slug":"layout","permalink":"http://yoursite.com/tags/layout/"}]},{"title":"CSS-在容器中分配並行空間(flex)","slug":"CSS-在容器中分配並行空間(flex)","date":"2019-03-28T04:46:52.000Z","updated":"2019-04-23T15:59:33.927Z","comments":true,"path":"2019/03/28/CSS-在容器中分配並行空間(flex)/","link":"","permalink":"http://yoursite.com/2019/03/28/CSS-在容器中分配並行空間(flex)/","excerpt":"","text":"CSS-在容器中分配並行空間(flex)使用時機希望容器之內的物件可以並行接續排列，並且每個物件都有固定比例占據該容器 CSS語法 外層容器的display屬性為flex 123.container&#123; display: flex;&#125; 在內層物件中，各自定義佔據的寬度或剩餘空間的分配比例 當 ==外層容器的空間足夠== 的情況： box1有設定width，會佔據固定寬度300px box2有設定width，會佔據固定寬度200px box3、box4沒有設定固定寬度，僅設定flex比例，則會依比例分配剩餘的空間 為了避免 ==外層容器空間不足== ，可以min-width輔助定義最小的寬度 box2因為沒有設定min-width，所以被擠壓到完全沒有空間 定義是否自動換行(flex-wrap) 定義「不換行」（flex-wrap預設值即為no-wrap，可省略不寫），可能會壓縮內層物件的寬度 1234.container&#123; display: flex; flex-wrap: no-wrap;&#125; 定義「自動換行」 1234.container&#123; display: flex; flex-wrap: wrap;&#125; 定義「換行後反轉」 12345.container&#123; display: flex; flex-direction: row; flex-wrap: wrap-reverse;&#125; 定義排序方向(flex-direction) 定義排序方向為「左到右」（flex-direction預設值即為row，可省略不寫） 1234.container&#123; display: flex; flex-direction: row; &#125; 定義排序方向為「右到左」 1234.container&#123; display: flex; flex-direction: row; &#125; 定義排序方向為「上到下」 1234.container&#123; display: flex; flex-direction: column;&#125; 定義排序方向為「下到上」 1234.container&#123; display: flex; flex-direction: column-reverse;&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"layout","slug":"layout","permalink":"http://yoursite.com/tags/layout/"}]},{"title":"html-建立第一個Hello world網頁","slug":"html-建立第一個Hello world網頁","date":"2019-03-28T00:07:18.000Z","updated":"2019-04-23T16:05:33.282Z","comments":true,"path":"2019/03/28/html-建立第一個Hello world網頁/","link":"","permalink":"http://yoursite.com/2019/03/28/html-建立第一個Hello world網頁/","excerpt":"","text":"html-建立第一個Hello world網頁使用工具 Mac電腦(ios系統) VScode編譯器步驟 開啟電腦內建的「文字編譯」，新增一個檔案 暫時先命名為index，並且設定為「純文字格式」 輸入內容「Hello world!」，並儲存 更改檔案副檔名「.html」 直接點選開檔案，或拖曳到瀏覽器打開檔案，即可看到網頁成功顯示","categories":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/categories/HTML/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"Git基本指令","slug":"Git基本指令","date":"2019-03-27T23:58:30.000Z","updated":"2019-04-23T16:02:25.257Z","comments":true,"path":"2019/03/28/Git基本指令/","link":"","permalink":"http://yoursite.com/2019/03/28/Git基本指令/","excerpt":"","text":"Git基本指令終端機環境系統指令不同的作業系統，指令也會不太一樣。|Windows| MacOs | 說明 ||——–| ——– | ——–|| cd | cd | 切換目錄 || cd | cd| 切換目前所在位置 || dir | ls| 列出目前檔案列表 ||mkdir| mkdir | 建立新的目錄||無| touch | 建立檔案||copy| cp | 複製檔案||move| mv | 移動檔案||del| rm | 刪除檔案||cls| clear | 清除畫面上的內容| 目錄切換及顯示123456789101112131415//切換到/tmp目錄(絕對路徑)$ cd/tmp//切換到my_project目錄(絕對路徑)$ cd my_project//切換到上一層目錄(相對路徑)$ cd ..//切換到使用者的home目錄中的project裡的namecards目錄// \"~\"這個符號代表home目錄$ cd ~/project/namecards//顯示目前所在的目錄$ pwd 檔案列表ls指令可列出在目前目錄所有的檔案及目錄，後面接的 -al 參數，a 是指連小數點開頭的檔案（例如.gitignore）也會顯示，l 則是完整檔案的權限、擁有者以及建立、修改時間12345//列出目前所在目錄的所有檔案及目錄$ ls//列出目前所在目錄的所有檔案及目錄，包含副檔名及檔案權限等資訊$ls -al 目錄切換及顯示開啟終端機(terminal)，並試著操作以下指令，從建立一個全新的目錄開始。12345$ cd /tmp //切換至 /tmp 目錄$ mkdir git-practice //建立 git-practice 目錄$ cd git-practice //切換至 git-practice 目錄$ git init //初始化這個目錄，讓 Git 對這個目錄開始進行版控Initialized empty Git repository in /Users/leah/git-practice/.git/ :::info小數點開頭的目錄或檔案名稱（例如 .git），在一些作業系統中預設是隱藏的，需要開啟檢視隱藏檔之類的設定才看得到。::: :::infoShift+Command+ .就可以顯示出隱藏的檔案::: 把檔案交給Git控管先查詢目前目錄的狀態，下面產生的訊息意思是「現在沒東西可以提交（nothing to commit）」。1234567//查詢現在這個目錄的狀態$ git status On branch masterNo commits yetnothing to commit (create/copy files and use \"git add\" to track) 接下來， 建立一個檔案(也可以用一般的文字編輯器或檔案管理員來完成)12//在這個目錄裡透過系統指令建立一個內容為 “hello, git”$echo \"Hello,git\" &gt; welcome.html 檢查目錄，確實多了一個welcome.html檔案 並且，再次檢查目前目錄的狀態 welcome.html 檔案目前的狀態是 Untracked files，意思是這個檔案尚未被加到 Git 版控系統裡，還沒開始正式被 Git「追蹤」，它只是剛剛才加入這個目錄而已。1234567891011$ git statusOn branch masterNo commits yetUntracked files: (use \"git add &lt;file&gt;...\" to include in what will be committed) welcome.htmlnothing added to commit but untracked files present (use \"git add\" to track) 把 welcome.html 這個檔案交給 Git，讓 Git 開始「追蹤」它12//新增檔案讓git追蹤$ git add welcome.html 最後再檢查一次狀態123456789$ git statusOn branch masterNo commits yetChanges to be committed: (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) new file: welcome.html","categories":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"html-插入圖片路徑<img>","slug":"html-插入圖片路徑","date":"2019-03-27T23:51:58.000Z","updated":"2019-04-23T16:05:50.541Z","comments":true,"path":"2019/03/28/html-插入圖片路徑/","link":"","permalink":"http://yoursite.com/2019/03/28/html-插入圖片路徑/","excerpt":"","text":"html-插入圖片路徑&lt;img&gt;在html中的圖片標籤為img，而其一的屬性src則要放入圖片檔案的位置，位置分為兩種 絕對路徑：放上圖片的url位置 相對路徑：相較於目前檔案的位置，找到圖片檔案的儲存位置1&lt;img src=&quot;&quot; alt=&quot;&quot;&gt; 方法一：絕對路徑 取得圖片的url位置：在圖片上方，點右鍵選取「複製圖片位址」 將url貼在src屬性中，並儲存 重新整理瀏覽器，網頁成功顯示出圖片 方法二：相對路徑 在專案中，先建立「img」資料夾，並在其中放入圖片檔案 在src屬性中，輸入圖片檔案的相對位置，並儲存 重新整理瀏覽器，網頁成功顯示出圖片","categories":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/categories/HTML/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"Sketch to CSS","slug":"Sketch to CSS","date":"2019-03-27T23:47:32.000Z","updated":"2019-04-23T16:08:38.561Z","comments":true,"path":"2019/03/28/Sketch to CSS/","link":"","permalink":"http://yoursite.com/2019/03/28/Sketch to CSS/","excerpt":"","text":"Sketch to CSS學習來源 youtube影片：從 Sketch 設計到 CSS 切版 codepen案例：0913 demo 使用工具 Sketch：UI 設計軟體(補充youtube影片：六角學院 - Sketch 介紹) Codepen：線上編譯器 編譯器初始化設定(Pen Settings)step1.CSS設定為SCSS step2.載入icon服務可以手動直接將下方CDN貼到基本設定欄位中。或是透過畫面中內建的搜尋功能，搜尋：Font-Awesome，CDN將自動被加入欄位中。1https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css step3.設定完成(Save&amp;Close)正式開始切版切版呈現目標 背景色設定step1.(SCSS語法)將顏色命名為一個變數12$bg-color1: #FCF4ED;$bg-color2: #F0C7B2; step2.設計漸層背景 12345body&#123; height:100vh;/*body設定為裝置高度的100%*/ background-image:linear-gradient(175deg,$bg-color1,$bg-color1 50%,$bg-color2 50%) /*角度175度,開始色,開始色比例,結束色比例*/&#125; 中間卡片基本設定step1.先在html中給他一個命名，名為card1&lt;div class=&quot;card&quot;&gt;&lt;/div&gt; step2.在css中定義card的基本樣式123456.card&#123; background-color:#fff; padding:15px; height:60vh; width:600px;&#125; step3.加入：box-sizing屬性 ==當你設定一個元素樣式為 box-sizing: border-box;，這個元素的內距和邊框將不會增加元素本身的寬度。==123.card&#123; box-sizing:border-box;&#125; 或者可以用*{}，代表對所有元素統一做設定123*&#123; box-sizing:border-box;;&#125; step4.為card添加陰影1$card-box-shadow: 0 4px 30px #979797; 123.card&#123; box-shadow:$card-box-shadow;&#125; step5.如何讓card置中整個畫面呢？在body中加入對齊的設定！12345body&#123; display:flex;/*彈性布局*/ justify-content:center;/*//水平置中*/ align-items:center;/*垂直置中*/&#125; 卡片內圖片step1.先在html中給予一個畫面空間1234&lt;div class=&quot;card&quot;&gt; &lt;div class=&quot;brand-bg&quot;&gt;&lt;/div&gt;&lt;!--新增這個div作為圖片空間 --&gt; &lt;h1&gt;About JENDES&lt;/h1&gt;&lt;/div&gt; step2.先將父元素card定位123.card&#123; position:relative;&#125; step3.再將子元素brand-bg(遮色片)定位12345678.brand-bg&#123; position:absolute;/*相較於父元素的定位方式 */ left:0; top:0; bottom:0; width:445px; &#125; step4.載入圖片url，並相較於遮色片做定位12345.brand-bg&#123; background-image:url(https://images.unsplash.com/photo-1550939810-cb345b2f4ad7?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=2632&amp;q=80); background-size:527px 633px;/*載入圖片的尺寸 */ background-position:-41px -10px;/*相較於遮色片的定位 */&#125; step5.遮色片作梯形切割1234.brand-bg&#123; clip-path:polygon(0 0, 339.05px 0,445px 100%,0% 100%); /*四個點的位置依序是 左上,右上,右下,左下*/&#125; 卡片內文字step1.先在html中給文字一個區塊畫面12345678910111213141516171819202122&lt;div class=&quot;card&quot;&gt; &lt;div class=&quot;brand-bg&quot;&gt;&lt;/div&gt; &lt;div class=&quot;card-block&quot;&gt; &lt;div class=&quot;card-header&quot;&gt; &lt;h1&gt;About JENDES&lt;/h1&gt; &lt;/div&gt; &lt;div class=&quot;card-body&quot;&gt; &lt;p&gt;粉橘色，一個溫柔又有個性的顏色。 &lt;br/&gt;柔和色相的背後蘊含著明亮活潑的橘彩，卻同時調入了冷靜灰階。 &lt;br/&gt;有如生活中的我們，一人扮演著多種角色，每個角色充滿著層次、彈性，無法輕易僅以黑白雙色定義。 &lt;/p&gt; &lt;p&gt;讓每道顏色都能在這找到適合的穿著，舒服展現每一個自己。 &lt;br/&gt;由裡到外，穿出自信自在。 &lt;/p&gt; &lt;p&gt;When style shines from inside, no one can define you. &lt;br/&gt;You are just who you are. &lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;card-footer&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;btn&quot;&gt;＋電子報訂閱&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; ==p標籤代表文字段落== ==br標籤代表斷行== step2.定位文字區塊相較於card的位置 1234567891011.card-block&#123; width:318px; /*設定右方文字在左方圖層上面 */ position:relative; x-index:3; /*設定裡面的物件排列為flex*/ /* flex預設是由左至右，可以調整flex-direction:column，改為由上到下== */ display:flex; flex-direction:column;&#125; ==flex跟position是可以一起使用的，兩個沒有關係;float跟display也沒有關係;flex裡面可以再有flex== step3.設定card-footer定位在區塊的最下方1234.card-footer&#123; /*使用auto會自動將空間用空白補滿*/ margin-top:auto;&#125; step4.設定btn樣式 123456789101112$btn-color:#D8D8D8;.btn&#123; background-color:$btn-color; color:#000000; width:292px; padding-top:0.5rem; padding-bottom:0.5rem; display:block;/*設定區塊元素 */ text-decoration:none; text-align:center;&#125; ==display:block - 區塊元素，元素會以區塊方式呈現。一個區塊元素會讓其內容從新的一行開始顯示，並盡可能的撐滿容器。== ==display:inline - 行內元素，所有文字或圖片均不換行，也就是全部都會是同一行的意思。== step5.設定btn的動態hover樣式變化123456.btn&#123; background-color:$btn-color; &amp;:hover,&amp;:focus&#123; background-color:darken($btn-color,15%); &#125;&#125; step6.設定內文字體123456789101112131415161718h1&#123; font-size:32px; font-weight:bolder; &#125;.card-header&#123; color:#AD5E36; font-family:cursive; font-weight:bold;&#125;p&#123; font-size:16px; margin-top:16px; line-height: 20px;&#125;.card-body&#123; font-family:\"STXihei\",\"FangSong\",cursive; color:#6D7278;&#125; 參考資料：CSS 常用中文字型 (Traditional Chinese font family) step7.加上簽名圖片12345678.sign-image&#123; margin-left:203px; margin-top:16px; width:115px; height:39px; background-image:url(https://www.jendesstudio.com/front/assets/images/jenwu.png); background-size:115px 39px; &#125; 結果呈現 codepen編譯檔 github打包檔","categories":[{"name":"Sketch","slug":"Sketch","permalink":"http://yoursite.com/categories/Sketch/"}],"tags":[{"name":"Sketch","slug":"Sketch","permalink":"http://yoursite.com/tags/Sketch/"},{"name":"切版","slug":"切版","permalink":"http://yoursite.com/tags/切版/"}]},{"title":"CSS-Box-sizing屬性","slug":"CSS-Box-sizing屬性","date":"2019-03-27T22:50:10.000Z","updated":"2019-04-23T15:57:26.044Z","comments":true,"path":"2019/03/28/CSS-Box-sizing屬性/","link":"","permalink":"http://yoursite.com/2019/03/28/CSS-Box-sizing屬性/","excerpt":"","text":"CSS-Box-sizing屬性使用情境在預設的情況box-sizing: content-box，padding的寬高，會被計算到元素的長寬中;如果希望元素的內距(padding)和外框(margin)不會增加元素本身的寬高，則可以使用box-sizing: content-box before瀏覽器預設值，box-sizing屬性，其值為content-box ==content-box：元素的實際寬高會再加上padding 和 border== 定義box1的寬為300px，高為50px，可是右方用瀏覽器查看元素時，發現尺寸變成330*80，是因為預設的情況，瀏覽將padding與border也算進元素中 after定義所有元素的box-sizing屬性，其值為border-box 123*&#123; box-sizing: border-box;&#125; ==border-box：元素的實際寬高不受padding 和 border影響== padding不會被增加到元素中，而border則算在元素之內，所以元素實際寬高仍保持為300*50","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"layout","slug":"layout","permalink":"http://yoursite.com/tags/layout/"},{"name":"padding","slug":"padding","permalink":"http://yoursite.com/tags/padding/"},{"name":"margin","slug":"margin","permalink":"http://yoursite.com/tags/margin/"}]},{"title":"JavaScript-函式特性(Functions)","slug":"JS-函式特性(Functions)","date":"2019-03-27T22:46:26.000Z","updated":"2019-05-03T06:20:56.094Z","comments":true,"path":"2019/03/28/JS-函式特性(Functions)/","link":"","permalink":"http://yoursite.com/2019/03/28/JS-函式特性(Functions)/","excerpt":"","text":"學習來源:(Eloquent JavaScript電子書) 提升(Hoisting)javascript的執行環境分為兩階段，在執行程式碼(exection)之前，會經歷創建階段(creation)，在創建階段中會將函式及變數先設置在記憶體中，而這個動作稱作「提升(hoisting)」。 函式提升在執行任何程式碼前，JavaScript 會把「函式宣告初始化」放進記憶體裡面，意思是函式{}的內容都會在創建階段放在記憶體中。 變數提升在創建階段，電腦的記憶體為a空出記憶體，可是他還不知道他的值為何，會先給予一個undefine的值，等到執行階段賦值時，才會將a的值放進記憶體中。也因此下方案例，印出a並不會出錯，只是它的值為undefine。123456console.log(a);b();var num = 6; //只要 num 有被宣告，就不會有錯誤function b()&#123; console.log('b');&#125; 陳述式與表達式 表達式 (expression)，程式碼「會」產生(回傳)出一個值 12345var a=3; //瀏覽器console回傳3，這代表這段程式碼是Expression10+5;//瀏覽器console回傳15，它也是Expressiona === 3;//回傳true(成立)，它也是Expression 陳述式 (statement)，程式碼「不會」回傳出一個值 if()的()，需要放入一個表達式a===3，但if()本身不會有回傳值，也無法將它賦值火指向變數，因此它是一個陳述式 123if(a===3)&#123; console.log('good');&#125; 函式陳述式 (function statement) 程式碼本身不會執行，又稱做函式宣告，在創建階段就先把函式設定進記憶體，等待被呼叫 123funtion doIt()&#123; console.log('finished');&#125; 所以即使先程式碼撰寫先後順序是先呼叫do()再定義funtion do()並不會出錯;因為電腦實際運作的順序是 step0.創建階段先將`funtion do()`設定進記憶體 step1.讓所有程式碼開始執行，此時呼叫`do()`不會出錯 12345doIt();//step1.程式碼執行呼叫funtion doIt()&#123;//step0.創建階段已經被設定進記憶體 console.log('finished');&#125; 函式表達式 (function expression)當程式碼執行到=運算子右邊的程式碼，才建立這個函式物件，將其指向變數do 123var doIt = function()&#123; console.log('finish');&#125; 在創建階段，會先將var do宣告在記憶體中，但沒有定義其值，因此程式碼在執行到do()時會出錯;電腦實際運作的順序是step0.在記憶體中開一個洞命名dostep1.讓程式碼開始執行，由上往下先執行do()，因為do()本身尚未被定義assign值，所以出錯step2.執行到 = function(){}才將此匿名函式assign給do1234doIt();var doIt = function()&#123; console.log('finish');&#125; 全域與區域only functions created new scopes 全域 (global)宣告在function()之外為全域變數，可以在全域被呼叫，所以在function()內、外呼叫x都不會出錯 123456var x = 'x';myF();function myF()&#123; console.log(\"in:\"+x);//in:x&#125;console.log(\"out:\"+x);//out:x 區域 (local)區域變數只能作用在function()區域中，出了function()則無法被呼叫 123456789myF();function myF()&#123; let y = 'y'; var z = 'z'; console.log(\"in:\"+y);//in:y console.log(\"in:\"+z);//in:z&#125;console.log(\"out:\"+y);//undefineconsole.log(\"out:\"+z);//undefine 若在區域中，重新定義assign給全域變數，則該全域變數的值會改變1234567var x = 'x1';myF();function myF()&#123; x = 'x2'; console.log(\"in:\"+x);//\"in:x2\"&#125;console.log(\"out:\"+x);//\"in:x2\" 若在區域中，新增一個同名的變數，則其與外部的全域變數為兩個不相干的變數12345678console.clear();var x = 'x1';myF();function myF()&#123; let x = 'x2' console.log(\"in:\"+x);//\"in:x2\"&#125;console.log(\"out:\"+x);//\"in:x1\" 區域內的變數，不得與function()中的傳入參數的命名相同1234function myF(x)&#123; let x = 'x2'//x已經被宣告過了 console.log(\"in:\"+x);&#125; 引數(argument)與參數(parameter) 引數：用於呼叫函式的傳入「值」 參數：在函式中用來接引數所宣告的「變數」 1234plus(1,2,5);// 1,2,5為引數function plus(a,b,c)&#123; //a,b,c為參數 console.log(arguments)&#125; 參數預設值（Default Parameters） 直接在參數中建立預設值123456var plus = function(a=4,b=5)&#123; return a*b;&#125;console.log(plus(2,3));//6console.log(plus(2,));//10console.log(plus());//20 閉包(Closure)呼叫函式內的函式，將記憶體封存在內層1234567function initial(newMoney)&#123; var money = newMoney || 100 return function(price)&#123;// 這裡是一個閉包 money = money - price;//變數money封存於此記憶體內 return money; &#125;&#125;; 執行結果：p1與p2兩個變數分別創造兩個函式，因此也創造個別的兩個閉包，而閉包內的money值會分別存於各自的記憶體內 若直接執行initial()，其回傳值是一個函式，因此會獲得該匿名函式 遞迴(Recursion)在函式中呼叫自身同名函式，呼叫者(外層函式)會被先放入堆疊記憶體中，等到被呼叫者(內層函式)被執行完之後，再從堆疊記憶體中取出之前被放入的函式繼續執行。==堆疊(stack) 是「先進後出」的資料結構== ，也因此，最先被呼叫的函式，會最後被取出執行。12345678function fun(num)&#123; if(num===0)&#123; return 1; &#125;else&#123; return num*fun(num-1) &#125;&#125;fun(3);//6 執行解讀順序，12345673*fun(2); 2*fun(1); 1*fun(0); 1; 1*1; 2*1;3*2;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"CSS-position定位：absolute＆relative＆fixed","slug":"CSS-position定位：absolute＆relative＆fixed","date":"2019-03-27T22:38:54.000Z","updated":"2019-04-23T15:57:12.262Z","comments":true,"path":"2019/03/28/CSS-position定位：absolute＆relative＆fixed/","link":"","permalink":"http://yoursite.com/2019/03/28/CSS-position定位：absolute＆relative＆fixed/","excerpt":"","text":"CSS-position定位：absolute＆relative＆fixed使用時機當畫面中的元素需要重疊時，建議可以使用position屬性作定位 預設值(static) 在不設定position屬性的情況，瀏覽器的預設值為static 123.box&#123; position:static; &#125; 該元素「不會被特別定位」在頁面上特定位置，而是照著瀏覽器預設的配置自動排版在頁面上 相對定位(relative) css語法 position的值為relative 若’ 沒有 ‘設置其他top、right、bottom、left屬性，則其顯現的位置跟static一樣，會依照瀏覽器預設的配置自動排版在頁面上 若’ 有 ‘設置top、right、bottom、left屬性 ，該元素會「相對地」調整其原本該出現的所在位置123.box&#123; position:relative;&#125; 絕對定位(absolute) css語法 position的值為absolute top、bottom、left、right交互搭配使用，數值可以為負值或百分比 1234567.box&#123; position:absolute; top:0; bottom:0; left:0; right:0;&#125; ==若其外層容器沒有「可以被定位的元素(static以外的元素)」，那麼這個子元素的定位就是相對於該網頁（也就是 元素），作上、下、左、右位置的絕對定位（即使外層有包一個父元素，例：container）== ==Q: 如何以父元素作為定位空間?== ==A: 定義父元素的position== 123.container&#123; position:relative;&#125; ==內層absolute的子元素則會被外層父元素受限，並在父元素的空間作絕對定位== 固定定位(fixed) css語法 position的值為fixed 使用 top、right、bottom、left屬性來定位，可以為負值。12345.inner&#123; position:fixed; right: 0px; bottom: -100px;&#125; 該元素會相對於瀏覽器視窗來定位，即便瀏覽頁面捲動，它還是會固定在相同的位置。 補充：上下疊層(z-index) 在未設置z-index屬性的情況之下，疊層會按照程式碼由上而下畫圖，box1畫完才畫box2，所以box2疊在box1之上 若想要自定義疊層前後，則透過z-index屬性，==「數字越大=越後畫=疊在越上層 」==","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"layout","slug":"layout","permalink":"http://yoursite.com/tags/layout/"}]},{"title":"html&CSS-插入(背景)圖片的作法","slug":"html&CSS-插入(背景)圖片的作法","date":"2019-03-27T03:28:58.000Z","updated":"2019-04-23T16:06:23.653Z","comments":true,"path":"2019/03/27/html&CSS-插入(背景)圖片的作法/","link":"","permalink":"http://yoursite.com/2019/03/27/html&CSS-插入(背景)圖片的作法/","excerpt":"","text":"html&amp;CSS-插入(背景)圖片的作法方法一：使用html的img標籤 html-插入圖片路徑：絕對路徑 or 相對路徑 圖片寬高 直接給予匯入圖片的寬高值，有變形的風險 分別相較於父元素寬高的百分比 ==如果使用百分比的width，而沒有給予height，瀏覽器會固定將圖片寬高比例，避免變形的風險== 用css加上邊框樣式 方法二：從css選擇器中定義背景 先在html中提供一個空間 123&lt;body&gt; &lt;div class=&quot;box1&quot;&gt;box1&lt;/div&gt;&lt;/body&gt; 開始透過css選擇器，定義該空間的樣式(為了顯示整個空間，所以先趁一個底色) 1background-color: antiquewhite; ==定義該空間的寬高(注意：不等同於照片的寬高！)== 12width:1000px;height:600px; 定義要匯入的圖片 1background-image: url(\"https://images.unsplash.com/photo-1553451193-d4d44c036555?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1352&amp;q=80\"); ==定義匯入圖片的長寬== 1background-size:500px 333px; 設定背景圖片不要重複顯示 1background-repeat: no-repeat; 定義圖片會不會跟著瀏覽器跑動可以將背景圖視為下層，透過background-attachment屬性的定義，可以定義下層的背景圖是否要跟著上層的瀏覽的畫面連動位移 background-attachment:scroll不論上層的瀏覽頁面如何捲動，其下方的背景圖會牢牢地跟著上下滑動，所以可視的圖片內容都一樣，不會改變 background-attachment:fixed下層的背景圖片會固定在某個位置，當上層的瀏覽頁面捲動，所視畫面會隨位置的不同而看到不同的圖片內容。甚至，當下層的背景圖片不夠長，即看不到圖片了 定義圖片的位置background-position 屬性是用來指定背景圖案的位置。語法： 兩個字：第一個字為 [top,center,bottom] 中三選一，而第二個字由 [left,center,right] 中三選一。 兩個百分比：第一個百分比為 x軸的百分比，第二個為 y軸的百分比。 兩個數目：第一個數目為 x軸的位置，第二個數目為 y軸的位置。","categories":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/categories/HTML/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"html&CSS-在html環境中插入css檔案","slug":"html&CSS-在html環境中插入css檔案","date":"2019-03-27T01:27:50.000Z","updated":"2019-04-23T16:05:59.565Z","comments":true,"path":"2019/03/27/html&CSS-在html環境中插入css檔案/","link":"","permalink":"http://yoursite.com/2019/03/27/html&CSS-在html環境中插入css檔案/","excerpt":"","text":"html&amp;CSS-在html環境中插入css檔案先建議一個專案 專案本身為一個資料夾，先為其命名，例:test-project 其中有一個index.html檔案 另外新增一個css資料夾，且其中有一個style.css檔案 引入css檔案 先開啟index.html檔案 在head中，加入link標籤，並且指向style.css檔案的位置 成功引入之後，便可以在style.css進行編輯，透過css選擇器定義樣式，去影響index.html的內容css選擇器(簡易示範) 在style.css定義h1、p的顏色樣式，並存檔 再次刷新瀏覽頁面，可以看到h1、p的樣式確實被改變了","categories":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/categories/HTML/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"html-建立html環境","slug":"html-建立html環境","date":"2019-03-26T23:19:58.000Z","updated":"2019-04-23T16:04:51.289Z","comments":true,"path":"2019/03/27/html-建立html環境/","link":"","permalink":"http://yoursite.com/2019/03/27/html-建立html環境/","excerpt":"","text":"html-建立html環境基本環境架構 定義網頁的格式因為html的時代悠久，有許多不同的html版本格式，因此若使用html5格式，需在第一行新增一行定義 1&lt;!DOCTYPE html&gt; 所有撰寫內容，都先用html包起來，裡面有裡面有兩個標籤： head、body 12345678&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; head:放置網頁的相關資訊，例：網頁名稱、支援中文編碼模式、載入的css版本、載入的JS版本12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;My first web&lt;/title&gt;//網頁名稱 &lt;meta charset=&quot;UTF-8&quot;&gt;//支援中文編碼模式 &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 該網頁的頁籤變更為「My first web」 body:所有關於html的程式碼(網頁內容)，都放在body中1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;My first web&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;標題&lt;/h1&gt; &lt;p&gt;這是文字內容...這是文字內容...這是文字內容...這是文字內容...&lt;/p&gt; &lt;a href=&quot;https://www.google.com/&quot;&gt;連結&lt;/a&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/categories/HTML/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"CSS-浮動定位(float)、清除浮動(clear)","slug":"CSS-浮動定位(float)、清除浮動(clear)","date":"2019-03-25T23:18:34.000Z","updated":"2019-04-23T16:00:32.810Z","comments":true,"path":"2019/03/26/CSS-浮動定位(float)、清除浮動(clear)/","link":"","permalink":"http://yoursite.com/2019/03/26/CSS-浮動定位(float)、清除浮動(clear)/","excerpt":"","text":"CSS-浮動定位(float)、清除浮動(clear)浮動定位(float)float使用時機&lt;div&gt;本身是區塊元素(block)，即使元素本身長度短於頁面行寬，仍會自動換行 12&lt;div class=&quot;box1&quot;&gt;box1&lt;/div&gt;&lt;div class=&quot;box2&quot;&gt;box2&lt;/div&gt; 12345678910.box1&#123; width:200px; background: #F0C7B2; height:50px;&#125;.box2&#123; width:200px; background: #F0780D; height:50px;&#125; 若希望&lt;div&gt;元素可以並行排列，則需要使用float屬性 123456.box1&#123; float:left;&#125;.box2&#123; float:left;&#125; css語法解釋1float: 浮動方向; 浮動方向可以用的值有 left（靠左浮動） right（靠右浮動） none（預設值，也就是不浮動） inherit（繼承自父層的屬性） 123456789101112.box1&#123; width:200px; background: #F0C7B2; height:50px; float:left;&#125;.box2&#123; width:200px; background: #F0780D; height:50px; float:right;&#125; 換行狀況即使使用float定位，當排列元素的累積寬度已經超過頁面行寬，就會自動換行 123456789101112.box1&#123; width:200px; background: #F0C7B2; height:50px; float:left;&#125;.box2&#123; width:800px; background: #F0780D; height:50px; float:left;&#125; 清除浮動(clear)使用時機當前面的元素為浮動元素，後續的區塊元素會從父階層容器開始的地方堆疊起123&lt;div class=&quot;box1&quot;&gt;box1&lt;/div&gt;&lt;div class=&quot;box2&quot;&gt;box2&lt;/div&gt;&lt;div class=&quot;box3&quot;&gt;box3&lt;/div&gt; 1234567891011121314151617.box1&#123; width:200px; background: #F0780D; height:50px; float:left;&#125;.box2&#123; width:300px; background: #AEB6B8; height:50px; float:left;&#125;.box3&#123; width:100%; background: #F0C7B2; height:100px;&#125; 當後面的元素不想要有float的浮動效果時，為了避免重疊狀況，必須在最後一個浮動元素後方，增加一個元素，並使用clear屬性1234&lt;div class=&quot;box1&quot;&gt;box1&lt;/div&gt;&lt;div class=&quot;box2&quot;&gt;box2&lt;/div&gt;&lt;div class=&quot;clearFloat&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box3&quot;&gt;box3&lt;/div&gt; 123.clearFloat&#123; clear:both;&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"layout","slug":"layout","permalink":"http://yoursite.com/tags/layout/"}]},{"title":"CSS-區塊元素(block)與行內元素(inline)","slug":"CSS-區塊元素(block)與行內元素(inline)","date":"2019-03-25T22:43:08.000Z","updated":"2019-04-23T15:59:01.674Z","comments":true,"path":"2019/03/26/CSS-區塊元素(block)與行內元素(inline)/","link":"","permalink":"http://yoursite.com/2019/03/26/CSS-區塊元素(block)與行內元素(inline)/","excerpt":"","text":"CSS-區塊元素(block)與行內元素(inline)區塊元素(block) 在新的一行開始 若沒有定義該元素長寬，則會100%佔滿所在空間 例：&lt;div&gt;會佔滿整個區塊(整行) css語法：display:block; 12345&lt;div class=&quot;block-section&quot;&gt; &lt;h1&gt;title&lt;/h1&gt; &lt;small&gt;small subtitle&lt;/small&gt; &lt;p&gt;here is the content&lt;/p&gt;&lt;/div&gt; 123456789.block-section h1&#123; display:block;&#125;.block-section small&#123; display:block;&#125;.block-section p&#123; display:block;&#125; 行內元素(inline) 不一定會在新的一行開始 該元素佔有的空間為其內容本身(文字或圖片)之長寬 無法重新自定義長寬 可能其他元素並排(視空間寬度而定) 例：&lt;span&gt;會接續前方元素，不會換行 css語法：display:inline;12345&lt;div class=&quot;inline-section&quot;&gt; &lt;h1&gt;title&lt;/h1&gt; &lt;small&gt;small subtitle&lt;/small&gt; &lt;p&gt;here is the content&lt;/p&gt;&lt;/div&gt; 123456789.inline-section h1&#123; display:inline;&#125;.inline-section small&#123; display:inline;&#125;.inline-section p&#123; display:inline;&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"layout","slug":"layout","permalink":"http://yoursite.com/tags/layout/"}]}]}